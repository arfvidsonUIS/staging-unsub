diff --git a/drivers/staging/unisys/Kconfig b/drivers/staging/unisys/Kconfig
index b3d4219..003eb2e 100644
--- a/drivers/staging/unisys/Kconfig
+++ b/drivers/staging/unisys/Kconfig
@@ -15,14 +15,15 @@ source "drivers/staging/unisys/visorchipset/Kconfig"
 source "drivers/staging/unisys/uislib/Kconfig"
 source "drivers/staging/unisys/virtpci/Kconfig"
 source "drivers/staging/unisys/virthba/Kconfig"
+source "drivers/staging/unisys/virtnic/Kconfig"
 source "drivers/staging/unisys/visorclientbus/Kconfig"
 source "drivers/staging/unisys/visorbus/Kconfig"
-source "drivers/staging/unisys/visordiag/Kconfig"
-source "drivers/staging/unisys/virtnic/Kconfig"
 source "drivers/staging/unisys/visornoop/Kconfig"
+source "drivers/staging/unisys/visornic/Kconfig"
+source "drivers/staging/unisys/visordiag/Kconfig"
 source "drivers/staging/unisys/visorserial/Kconfig"
 source "drivers/staging/unisys/visorvideoclient/Kconfig"
-source "drivers/staging/unisys/visorconinclient/Kconfig"
+source "drivers/staging/unisys/visorhid/Kconfig"
 source "drivers/staging/unisys/sparstopdriver/Kconfig"
 
 endif # UNISYSSPAR
diff --git a/drivers/staging/unisys/Makefile b/drivers/staging/unisys/Makefile
index 57ce830..e594775 100644
--- a/drivers/staging/unisys/Makefile
+++ b/drivers/staging/unisys/Makefile
@@ -12,7 +12,8 @@ obj-$(CONFIG_UNISYS_VISORBUS)		+= visorbus/
 obj-$(CONFIG_UNISYS_VISORDIAG)		+= visordiag/
 obj-$(CONFIG_UNISYS_VIRTNIC)		+= virtnic/
 obj-$(CONFIG_UNISYS_VISORNOOP)		+= visornoop/
+obj-$(CONFIG_UNISYS_VISORNIC)		+= visornic/
 obj-$(CONFIG_UNISYS_VISORSERIAL)	+= visorserial/
 obj-$(CONFIG_UNISYS_VISORVIDEOCLIENT)	+= visorvideoclient/
-obj-$(CONFIG_UNISYS_VISORCONINCLIENT)	+= visorconinclient/
+obj-$(CONFIG_UNISYS_VISORHID)		+= visorhid/
 obj-$(CONFIG_UNISYS_SPARSTOP)		+= sparstopdriver/
diff --git a/drivers/staging/unisys/include/uisutils.h b/drivers/staging/unisys/include/uisutils.h
index c7d0ba8..e84fd69 100644
--- a/drivers/staging/unisys/include/uisutils.h
+++ b/drivers/staging/unisys/include/uisutils.h
@@ -65,7 +65,17 @@ struct req_handler_info {
 	struct list_head list_link;	/* links into ReqHandlerInfo_list */
 };
 
+struct req_handler_info *req_handler_add(uuid_le switch_uuid,
+				const char *switch_type_name,
+				int (*controlfunc)(struct io_msgs *),
+				unsigned long min_channel_bytes,
+				int (*svr_channel_ok)(unsigned long
+							 channel_bytes),
+				int (*svr_channel_init)(void *x,
+						unsigned char *client_str,
+						u32 client_str_len, u64 bytes));
 struct req_handler_info *req_handler_find(uuid_le switch_uuid);
+int req_handler_del(uuid_le switch_uuid);
 
 #define uislib_ioremap_cache(addr, size) \
 	dbg_ioremap_cache(addr, size, __FILE__, __LINE__)
@@ -105,7 +115,19 @@ int uisutil_add_proc_line_ex(int *total, char **buffer, int *buffer_remaining,
 
 int uisctrl_register_req_handler(int type, void *fptr,
 			struct ultra_vbus_deviceinfo *chipset_driver_info);
+int uisctrl_register_req_handler_ex(uuid_le switch_guid,
+			const char *switch_type_name,
+			int (*fptr)(struct io_msgs *),
+			unsigned long min_channel_bytes,
+			int (*svr_channel_ok)(unsigned long
+					      channel_bytes),
+			int (*svr_channel_init)(void *x,
+						unsigned char *client_str,
+						u32 client_str_len,
+						u64 bytes),
+			struct ultra_vbus_deviceinfo *chipset_driver_info);
 
+int uisctrl_unregister_req_handler_ex(uuid_le switch_uuid);
 unsigned char *util_map_virt(struct phys_info *sg);
 void util_unmap_virt(struct phys_info *sg);
 unsigned char *util_map_virt_atomic(struct phys_info *sg);
@@ -188,6 +210,15 @@ wait_for_valid_guid(uuid_le __iomem *guid)
 	}
 }
 
+/* CopyFragsInfoFromSkb returns the number of entries added to frags array
+ * Returns -1 on failure.
+ */
+unsigned int uisutil_copy_fragsinfo_from_skb(unsigned char *calling_ctx,
+					     void *skb_in,
+					     unsigned int firstfraglen,
+					     unsigned int frags_max,
+					     struct phys_info frags[]);
+
 static inline unsigned int
 issue_vmcall_io_controlvm_addr(u64 *control_addr, u32 *control_bytes)
 {
diff --git a/drivers/staging/unisys/sparstopdriver/sparstop_main.c b/drivers/staging/unisys/sparstopdriver/sparstop_main.c
index 4c0b21b..146df92 100644
--- a/drivers/staging/unisys/sparstopdriver/sparstop_main.c
+++ b/drivers/staging/unisys/sparstopdriver/sparstop_main.c
@@ -266,8 +266,6 @@ devdata_rw_property_store(struct device *ddev,
 	switch (ix) {
 	case proprw_inprogress:
 		if (!get_ulong_from_buf(buf, count, &val))
-			ERRDEV(devdata->name,
-			       "inprogress must be number (hex or dec)");
 		down_write(&devdata->lock_device);
 		if (val == 1) {
 			TRANSITION_STATE(devdata, state_requested,
@@ -278,10 +276,7 @@ devdata_rw_property_store(struct device *ddev,
 			 */
 			if (TRANSITION_STATE
 			    (devdata, state_in_progress, state_failed)) {
-				if (!devdata->complete_func)
-					ERRDEV(devdata->name,
-					       "no complete_func!");
-				else
+				if (devdata->complete_func)
 					devdata->complete_func(devdata->
 							       complete_context,
 							       -1);
@@ -290,10 +285,7 @@ devdata_rw_property_store(struct device *ddev,
 			/* the stop succeeded */
 			if (TRANSITION_STATE
 			    (devdata, state_in_progress, state_complete)) {
-				if (!devdata->complete_func)
-					ERRDEV(devdata->name,
-					       "no complete_func!");
-				else
+				if (devdata->complete_func)
 					devdata->complete_func(devdata->
 							       complete_context,
 							       0);
@@ -318,7 +310,6 @@ register_ro_devdata_attributes(struct device *dev)
 	struct sparstop_devdata *devdata = dev_get_drvdata(dev);
 	struct device_attribute *pattr = devdata->devdata_ro_property;
 
-	INFODRV("%s:Entered pattr=%p", __func__, pattr);
 	pattr[propro_devmajorminor].attr.name = "devmajorminor";
 	pattr[propro_state].attr.name = "state";
 	pattr[propro_stateno].attr.name = "stateno";
@@ -327,11 +318,8 @@ register_ro_devdata_attributes(struct device *dev)
 		pattr[i].show = devdata_ro_property_show;
 		pattr[i].store = NULL;
 		rc = device_create_file(dev, &pattr[i]);
-		if (rc < 0) {
-			ERRDRV("device_create_file(dev, &pattr[i]): error (status=%d)\n",
-			       rc);
-			goto cleanup;
-		}
+		if (rc < 0)
+				goto cleanup;
 	}
 
 	rc = 0;
@@ -346,18 +334,14 @@ register_rw_devdata_attributes(struct device *dev)
 	struct sparstop_devdata *devdata = dev_get_drvdata(dev);
 	struct device_attribute *pattr = devdata->devdata_rw_property;
 
-	INFODRV("%s:Entered pattr=%p", __func__, pattr);
 	pattr[proprw_inprogress].attr.name = "inprogress";
 	for (i = 0; i < proprw_DEVDATAMAX; i++) {
 		pattr[i].attr.mode = S_IRUGO | S_IWUGO;
 		pattr[i].show = devdata_rw_property_show;
 		pattr[i].store = devdata_rw_property_store;
 		rc = device_create_file(dev, &pattr[i]);
-		if (rc < 0) {
-			ERRDRV("device_create_file(dev, &pattr[i]): error (status=%d)\n",
-			       rc);
-			goto cleanup;
-		}
+		if (rc < 0)
+				goto cleanup;
 	}
 
 	rc = 0;
@@ -371,17 +355,13 @@ register_device_attributes(struct device *dev)
 	int rc = 0;
 
 	rc = register_ro_devdata_attributes(dev);
-	if (rc < 0) {
-		ERRDRV("register_ro_devdata_attributes(dev): error (status=%d)\n",
-		       rc);
-		goto cleanup;
-	}
+	if (rc < 0)
+			goto cleanup;
+
 	rc = register_rw_devdata_attributes(dev);
-	if (rc < 0) {
-		ERRDRV("register_rw_devdata_attributes(dev): error (status=%d)\n",
-		       rc);
-		goto cleanup;
-	}
+	if (rc < 0)
+			goto cleanup;
+
 	rc = 0;
 cleanup:
 	return rc;
@@ -394,7 +374,6 @@ unregister_ro_devdata_attributes(struct device *dev)
 	struct sparstop_devdata *devdata;
 	struct device_attribute *pattr;
 
-	INFODRV("%s:Entered ", __func__);
 	devdata = dev_get_drvdata(dev);
 	pattr = devdata->devdata_ro_property;
 	for (i = 0; i < propro_DEVDATAMAX; i++)
@@ -409,7 +388,6 @@ unregister_rw_devdata_attributes(struct device *dev)
 	struct sparstop_devdata *devdata;
 	struct device_attribute *pattr;
 
-	INFODRV("%s:Entered ", __func__);
 	devdata = dev_get_drvdata(dev);
 	pattr = devdata->devdata_rw_property;
 	for (i = 0; i < proprw_DEVDATAMAX; i++)
@@ -422,10 +400,8 @@ unregister_device_attributes(struct device *dev)
 {
 	int rc = 0;
 
-	INFODRV("%s:Entered ", __func__);
 	unregister_ro_devdata_attributes(dev);
 	unregister_rw_devdata_attributes(dev);
-	INFODRV("%s:Leaving ", __func__);
 	return rc;
 }
 
@@ -437,7 +413,6 @@ devdata_create(struct device *dev)
 
 	devdata = kmalloc(sizeof(*devdata), GFP_KERNEL|__GFP_NORETRY);
 	if (devdata == NULL) {
-		ERRDRV("allocation of sparstop_devdata failed: (status=0)\n");
 		rc = NULL;
 		goto cleanup;
 	}
@@ -446,7 +421,6 @@ devdata_create(struct device *dev)
 	cdev_init(&devdata->cdev_stop, NULL);
 	if (kstrtoint(dev_name(dev) + strlen(SPARSTOP_DEVICEPREFIX), 10,
 		      &devdata->devno) != 0) {
-		ERRDRV("failed to get devno: (status=0)\n");
 		rc = NULL;
 		goto cleanup;
 	}
@@ -457,7 +431,6 @@ devdata_create(struct device *dev)
 	devdata->cdev_stop.owner = THIS_MODULE;
 	if (cdev_add(&devdata->cdev_stop,
 		     MKDEV(MAJOR(major_dev), devdata->devno), 1) < 0) {
-		ERRDRV("failed to create char device: (status=0)\n");
 		rc = NULL;
 		goto cleanup;
 	}
@@ -488,7 +461,6 @@ devdata_release(struct kref *mykref)
 	struct sparstop_devdata *devdata = container_of(mykref,
 							struct sparstop_devdata,
 							kref);
-	INFODEV(devdata->name, "devdata deallocated (no more refs)");
 	spin_lock(&lock_all_devices);
 	list_del(&devdata->list_all);
 	spin_unlock(&lock_all_devices);
@@ -499,7 +471,6 @@ devdata_release(struct kref *mykref)
 static void
 devdata_put(struct sparstop_devdata *devdata)
 {
-	INFODRV("%s:Entered ", __func__);
 	kref_put(&devdata->kref, devdata_release);
 }
 
@@ -514,14 +485,11 @@ remove_stop_device(struct device *dev)
 {
 	struct sparstop_devdata *devdata = dev_get_drvdata(dev);
 
-	INFODRV("%s:Entered ", __func__);
-	if (devdata == NULL) {
-		HUHDRV("no devdata in %s", __func__);
-		goto cleanup;
-	}
+	if (devdata == NULL)
+			return;
+
 	unregister_device_attributes(dev);
 	devdata_put(devdata);	/* 1 less reference to devdata */
-	INFODRV("%s:About to do dev_set_drvdata", __func__);
 	dev_set_drvdata(dev, NULL);
 
 	/* Note that it is still possible to have files open to this device
@@ -532,18 +500,11 @@ remove_stop_device(struct device *dev)
 	 */
 	sprintf(devdata->name, "<dev#%d-history>", devdata->devno);
 	devdata->dev = NULL;
-	INFODRV("%s:About to do devdata_put ", __func__);
 	devdata_put(devdata);
 	/* Undo kref_init(&devdata->kref) from devdata_create(): */
-	INFODRV("%s:About to do put_device ", __func__);
 	put_device(dev);	/* from add_stop_device */
 	/* Undo device_initialize + device_add() from add_stop_device(): */
-	INFODRV("%s:About to do device_unregister ", __func__);
 	device_unregister(dev);	/* Here is where KOBJ_REMOVE hotplug happens */
-	INFODRV("%s:Done ", __func__);
-
-cleanup:
-	INFODRV("%s finished", __func__);
 }
 
 static void
@@ -552,13 +513,10 @@ stop_device_release(struct device *dev)
 	ulong ul;
 
 	if (dev == NULL)
-		return;
-	INFODEV(dev_name(dev),
-		"kernelmode stop device deallocated (no more refs)");
-	if (kstrtoul(dev_name(dev) + strlen(SPARSTOP_DEVICEPREFIX), 10, &ul)) {
-		ERRDEV(dev_name(dev), "invalid device name-not freeing");
-		return;
-	}
+			return;
+	if (kstrtoul(dev_name(dev) + strlen(SPARSTOP_DEVICEPREFIX), 10, &ul))
+			return;
+
 	spin_lock(&devnopool_lock);
 	clear_bit(ul, devnopool);
 	spin_unlock(&devnopool_lock);
@@ -582,14 +540,12 @@ add_stop_device(void)
 	if (devno == MAXDEVICES)
 		devno = -1;
 	if (devno < 0) {
-		ERRDRV("attempt to create more than MAXDEVICES devices??: (status=0)\n");
 		rc = NULL;
 		goto cleanup;
 	}
 
 	dev = kmalloc(sizeof(*dev), GFP_KERNEL|__GFP_NORETRY);
 	if (dev == NULL) {
-		ERRDRV("failed to allocate device: (status=0)\n");
 		rc = NULL;
 		goto cleanup;
 	}
@@ -607,7 +563,6 @@ add_stop_device(void)
 	dev_set_name(dev, "%s%d", SPARSTOP_DEVICEPREFIX, devno);
 	devdata = devdata_create(dev);
 	if (devdata == NULL) {
-		ERRDRV("failed to allocate devdata for device: (status=0)\n");
 		rc = NULL;
 		goto cleanup;
 	}
@@ -621,19 +576,16 @@ add_stop_device(void)
 
 	/* This is where the KOBJ_ADD hotplug event happens */
 	if (device_add(dev) < 0) {
-		ERRDRV("device_add failed: (status=0)\n");
 		rc = NULL;
 		goto cleanup;
 	}
 	/* note: device_register is simply device_initialize + device_add */
 
 	if (register_device_attributes(dev) < 0) {
-		ERRDRV("register_device_attributes failed: (status=0)\n");
 		rc = NULL;
 		goto cleanup;
 	}
 	registered = TRUE;
-	INFODEV(dev_name(dev), "kernelmode stop device 0x%p created", dev);
 	rc = dev;
 cleanup:
 	if (rc == NULL) {
@@ -679,18 +631,8 @@ transition_state_guts(struct sparstop_devdata *devdata,
 		      enum sparstop_state new_state,
 		      char *filename, int lineno)
 {
-	if (devdata->state != old_state) {
-		ERRDEV(devdata->name,
-		       "Can't do state transition %s(%d)-->%s(%d) @%s:%d (old state=%s(%d) invalid)",
-			state_str(old_state), old_state, state_str(new_state),
-			new_state, filename, lineno, state_str(devdata->state),
-			devdata->state);
-		return FALSE;
-	}
-	INFODEV(devdata->name, "state transition %s(%d)-->%s(%d) @%s:%d",
-		state_str(old_state), old_state,
-		state_str(new_state), new_state, filename, lineno);
-	devdata->state = new_state;
+	if (devdata->state != old_state)
+			return FALSE;
 	return TRUE;
 }
 
@@ -699,28 +641,18 @@ sparstop_init(void)
 {
 	int rc = -1;
 
-	INFODRV("driver version %s loaded", VERSION);
-	/* uintpool_test(); */
-	INFODRV("Options:");
-	INFODRV("         major=%d", sparstop_major);
-
 	major_dev = MKDEV(sparstop_major, 0);
 	spin_lock_init(&devnopool_lock);
 	devnopool = kzalloc(BITS_TO_LONGS(MAXDEVICES), GFP_KERNEL);
-	if (devnopool == NULL) {
-		ERRDRV("Unable to create devnopool");
-		goto cleanup;
-	}
-	if (alloc_chrdev_region(&major_dev, 0, MAXDEVICES, MYDRVNAME) < 0) {
-		ERRDRV("Unable to register char device %s", MYDRVNAME);
-		goto cleanup;
-	}
+	if (devnopool == NULL)
+			goto cleanup;
+
+	if (alloc_chrdev_region(&major_dev, 0, MAXDEVICES, MYDRVNAME) < 0)
+			goto cleanup;
+
 	rc = bus_register(&simplebus_type);
-	if (rc < 0) {
-		ERRDRV("allocation of sparstop_devdata failed: (status=%d)\n",
-		       rc);
-		goto cleanup;
-	}
+	if (rc < 0)
+			goto cleanup;
 	rc = 0;
 cleanup:
 	if (rc < 0)
@@ -732,7 +664,6 @@ static void
 sparstop_cleanup(void)
 {
 	sparstop_cleanup_guts();
-	INFODRV("driver unloaded");
 }
 
 int
@@ -742,16 +673,13 @@ sp_stop(void *context, SPARSTOP_COMPLETE_FUNC complete_func)
 	int rc = -1;
 
 	if (standalone_device != NULL) {
-		ERRDRV("%s standalone_device already active, removing it",
-		       __func__);
 		remove_stop_device(standalone_device);
 		standalone_device = NULL;
 	}
 	standalone_device = add_stop_device();
-	if (standalone_device == NULL) {
-		ERRDRV("%s failed to create sparstop device", __func__);
+	if (standalone_device == NULL)
 		goto cleanup;
-	}
+
 	devdata = dev_get_drvdata(standalone_device);
 	devdata->complete_func = complete_func;
 	devdata->complete_context = context;
diff --git a/drivers/staging/unisys/sparstopdriver/sparstop_private.h b/drivers/staging/unisys/sparstopdriver/sparstop_private.h
index 9cc3a03..1c2dd2e 100644
--- a/drivers/staging/unisys/sparstopdriver/sparstop_private.h
+++ b/drivers/staging/unisys/sparstopdriver/sparstop_private.h
@@ -18,7 +18,6 @@
 #ifndef __SPARSTOP_PRIVATE_H__
 #define __SPARSTOP_PRIVATE_H__
 
-#include "uniklog.h"
 #include "timskmod.h"
 #include "version.h"
 #include <linux/ctype.h>
diff --git a/drivers/staging/unisys/uislib/uisutils.c b/drivers/staging/unisys/uislib/uisutils.c
index 26ab765..64e86fb 100644
--- a/drivers/staging/unisys/uislib/uisutils.c
+++ b/drivers/staging/unisys/uislib/uisutils.c
@@ -96,6 +96,58 @@ uisctrl_register_req_handler(int type, void *fptr,
 }
 EXPORT_SYMBOL_GPL(uisctrl_register_req_handler);
 
+int
+uisctrl_register_req_handler_ex(uuid_le switch_uuid,
+			const char *switch_type_name,
+			int (*controlfunc)(struct io_msgs *),
+			unsigned long min_channel_bytes,
+			int (*server_channel_ok)(unsigned long channel_bytes),
+			int (*server_channel_init)(void *x,
+						unsigned char *client_str,
+						u32 client_str_len, u64 bytes),
+			struct ultra_vbus_deviceinfo *chipset_driver_info)
+{
+	struct req_handler_info *req_handler;
+
+	if (!controlfunc) {
+		return 0;
+	}
+	if (!server_channel_ok) {
+		return 0;
+	}
+	if (!server_channel_init) {
+		return 0;
+	}
+	req_handler = req_handler_add(switch_uuid,
+				      switch_type_name,
+				      controlfunc,
+				      min_channel_bytes,
+				      server_channel_ok, server_channel_init);
+	if (!req_handler) {
+		return 0;
+	}
+
+	atomic_inc(&uisutils_registered_services);
+	if (chipset_driver_info) {
+		bus_device_info_init(chipset_driver_info, "chipset",
+				     "uislib", VERSION, NULL);
+		return 1;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(uisctrl_register_req_handler_ex);
+
+int
+uisctrl_unregister_req_handler_ex(uuid_le switch_uuid)
+{
+	if (req_handler_del(switch_uuid) < 0) {
+		return 0;
+	}
+	atomic_dec(&uisutils_registered_services);
+	return 1;
+}
+EXPORT_SYMBOL_GPL(uisctrl_unregister_req_handler_ex);
+
 /*
  * unsigned int uisutil_copy_fragsinfo_from_skb(unsigned char *calling_ctx,
  *					     void *skb_in,
@@ -114,11 +166,111 @@ EXPORT_SYMBOL_GPL(uisctrl_register_req_handler);
  *					    return value indicates number of
  *					    entries filled in frags
  */
+unsigned int
+uisutil_copy_fragsinfo_from_skb(unsigned char *calling_ctx, void *skb_in,
+				unsigned int firstfraglen,
+				unsigned int frags_max,
+				struct phys_info frags[])
+{
+	unsigned int count = 0, ii, size, offset = 0, numfrags;
+	struct sk_buff *skb = skb_in;
+
+	numfrags = skb_shinfo(skb)->nr_frags;
+
+	while (firstfraglen) {
+		if (count == frags_max) {
+			return -1;	/* failure */
+		}
+		frags[count].pi_pfn =
+		    page_to_pfn(virt_to_page(skb->data + offset));
+		frags[count].pi_off =
+		    (unsigned long)(skb->data + offset) & PI_PAGE_MASK;
+		size =
+		    min(firstfraglen,
+			(unsigned int)(PI_PAGE_SIZE - frags[count].pi_off));
+		/* can take smallest of firstfraglen(what's left) OR
+		* bytes left in the page
+		*/
+		frags[count].pi_len = size;
+		firstfraglen -= size;
+		offset += size;
+		count++;
+	}
+	if (!numfrags)
+		goto dolist;
+
+	if ((count + numfrags) > frags_max) {
+		return -1;	/* failure */
+	}
+
+	for (ii = 0; ii < numfrags; ii++) {
+		count = add_physinfo_entries(page_to_pfn(
+				skb_frag_page(&skb_shinfo(skb)->frags[ii])),
+					skb_shinfo(skb)->frags[ii].
+					page_offset,
+					skb_shinfo(skb)->frags[ii].
+					size, count, frags_max,
+					frags);
+		if (count == 0) {
+			return -1;	/* failure */
+		}
+	}
+
+dolist: if (skb_shinfo(skb)->frag_list) {
+		struct sk_buff *skbinlist;
+		int c;
+
+		for (skbinlist = skb_shinfo(skb)->frag_list; skbinlist;
+		     skbinlist = skbinlist->next) {
+			c = uisutil_copy_fragsinfo_from_skb("recursive",
+				skbinlist,
+				skbinlist->len - skbinlist->data_len,
+				frags_max - count,
+				&frags[count]);
+			if (c == -1) {
+				return -1;
+			}
+			count += c;
+		}
+	}
+	return count;
+}
+EXPORT_SYMBOL_GPL(uisutil_copy_fragsinfo_from_skb);
 
 static LIST_HEAD(req_handler_info_list); /* list of struct req_handler_info */
 static DEFINE_SPINLOCK(req_handler_info_list_lock);
 
 struct req_handler_info *
+req_handler_add(uuid_le switch_uuid,
+	      const char *switch_type_name,
+	      int (*controlfunc)(struct io_msgs *),
+	      unsigned long min_channel_bytes,
+	      int (*server_channel_ok)(unsigned long channel_bytes),
+	      int (*server_channel_init)
+	       (void *x, unsigned char *clientstr, u32 clientstr_len,
+		u64 bytes))
+{
+	struct req_handler_info *rc = NULL;
+
+	rc = kzalloc(sizeof(*rc), GFP_ATOMIC);
+	if (!rc)
+		return NULL;
+	rc->switch_uuid = switch_uuid;
+	rc->controlfunc = controlfunc;
+	rc->min_channel_bytes = min_channel_bytes;
+	rc->server_channel_ok = server_channel_ok;
+	rc->server_channel_init = server_channel_init;
+	if (switch_type_name)
+		strncpy(rc->switch_type_name, switch_type_name,
+			sizeof(rc->switch_type_name) - 1);
+	spin_lock(&req_handler_info_list_lock);
+	list_add_tail(&rc->list_link, &req_handler_info_list);
+	spin_unlock(&req_handler_info_list_lock);
+
+	return rc;
+}
+
+struct req_handler_info *
 req_handler_find(uuid_le switch_uuid)
 {
 	struct list_head *lelt, *tmp;
@@ -135,3 +287,23 @@ req_handler_find(uuid_le switch_uuid)
 	spin_unlock(&req_handler_info_list_lock);
 	return NULL;
 }
+
+int
+req_handler_del(uuid_le switch_uuid)
+{
+	struct list_head *lelt, *tmp;
+	struct req_handler_info *entry = NULL;
+	int rc = -1;
+
+	spin_lock(&req_handler_info_list_lock);
+	list_for_each_safe(lelt, tmp, &req_handler_info_list) {
+		entry = list_entry(lelt, struct req_handler_info, list_link);
+		if (uuid_le_cmp(entry->switch_uuid, switch_uuid) == 0) {
+			list_del(lelt);
+			kfree(entry);
+			rc++;
+		}
+	}
+	spin_unlock(&req_handler_info_list_lock);
+	return rc;
+}
diff --git a/drivers/staging/unisys/virtnic/virtnic.c b/drivers/staging/unisys/virtnic/virtnic.c
index 0af48f3..3bd5782 100644
--- a/drivers/staging/unisys/virtnic/virtnic.c
+++ b/drivers/staging/unisys/virtnic/virtnic.c
@@ -22,7 +22,6 @@
 #include <config/modversions.h>
 #endif
 
-#include "uniklog.h"
 #include "diagnostics/appos_subsystems.h"
 #include "uisutils.h"
 #include "uisthread.h"
@@ -129,7 +128,6 @@ static struct virtpci_driver virtnic_driver = {
 };
 
 #define SEND_ENBDIS(ndev, state, cmdrsp, queue, insertlock, stats) { \
-	DBGINF("sending rcv enb/dis netdev:%p state:%d\n", ndev, state); \
 	cmdrsp->net.enbdis.enable = state; \
 	cmdrsp->net.enbdis.context = ndev; \
 	cmdrsp->net.type = NET_RCV_ENBDIS; \
@@ -313,15 +311,7 @@ post_skb(struct uiscmdrsp *cmdrsp,
 	cmdrsp->net.rcvpost.frag.pi_len = skb->len;
 	cmdrsp->net.rcvpost.unique_num = vnicinfo->uniquenum;
 
-	DBGINF("RCV_POST skb:%p pfn:%llu off:%x len:%d\n", skb,
-	       cmdrsp->net.rcvpost.frag.pi_pfn,
-	       cmdrsp->net.rcvpost.frag.pi_off,
-	       cmdrsp->net.rcvpost.frag.pi_len);
-	if ((cmdrsp->net.rcvpost.frag.pi_off + skb->len) > PI_PAGE_SIZE) {
-		LOGERRNAME(vnicinfo->netdev,
-			   "**** pi_off:0x%x pi_len:%d SPAN ACROSS A PAGE\n",
-			   cmdrsp->net.rcvpost.frag.pi_off, skb->len);
-	} else {
+	if ((cmdrsp->net.rcvpost.frag.pi_off + skb->len) <= PI_PAGE_SIZE) {
 		cmdrsp->net.type = NET_RCV_POST;
 		cmdrsp->cmdtype = CMD_NET_TYPE;
 		uisqueue_put_cmdrsp_with_lock_client(vnicinfo->datachan.chinfo.
@@ -414,14 +404,10 @@ virtnic_probe(struct virtpci_dev *virtpcidev, const struct pci_device_id *id)
 		return res;						\
 }
 
-	DBGINF("virtpci_dev:%p\n", virtpcidev);
-	DBGINF("virtpcidev busNo<<%d>>devNo<<%d>>",
-	       virtpcidev->busNo, virtpcidev->deviceNo);
 	netdev = alloc_etherdev(sizeof(struct virtnic_info));
-	if (netdev == NULL) {
-		LOGERR("**** FAILED to alloc etherdev\n");
-		return -ENOMEM;
-	}
+	if (netdev == NULL)
+			return -ENOMEM;
+
 	netdev->netdev_ops = &virtnic_dev_ops;
 	netdev->watchdog_timeo = VIRTNIC_XMIT_TIMEOUT;
 
@@ -444,47 +430,32 @@ virtnic_probe(struct virtpci_dev *virtpcidev, const struct pci_device_id *id)
 	atomic_set(&vnicinfo->usage, 1);	/* starting val */
 	vnicinfo->zoneguid = virtpcidev->net.zone_uuid;
 	vnicinfo->num_rcv_bufs = virtpcidev->net.num_rcv_bufs;
-	LOGINFNAME(vnicinfo->netdev, "num_rcv_bufs =  %d\n",
-		   vnicinfo->num_rcv_bufs);
 	vnicinfo->rcvbuf = kmalloc(sizeof(struct sk_buff *) *
 				   vnicinfo->num_rcv_bufs, GFP_ATOMIC);
-	if (vnicinfo->rcvbuf == NULL) {
-		LOGERRNAME(vnicinfo->netdev,
-			   "**** FAILED to allocate memory for %d receive buffers.\n",
-			   vnicinfo->num_rcv_bufs);
-		RETFAIL(-ENOMEM);
-	}
+	if (vnicinfo->rcvbuf == NULL)
+			RETFAIL(-ENOMEM);
+
 	memset(vnicinfo->rcvbuf, 0,
 	       sizeof(struct sk_buff *) * vnicinfo->num_rcv_bufs);
 	/* set the net_xmit outstanding threshold */
 	vnicinfo->max_outstanding_net_xmits =
 	    max(3, ((vnicinfo->num_rcv_bufs / 3) - 2));
 	/* always leave two slots open but you should have 3 at a minimum */
-	LOGINFNAME(vnicinfo->netdev, "max_outstanding_net_xmits =  %d\n",
-		   vnicinfo->max_outstanding_net_xmits);
 	vnicinfo->upper_threshold_net_xmits =
 	    max(2, vnicinfo->max_outstanding_net_xmits - 1);
-	LOGINFNAME(vnicinfo->netdev, "upper_threshold_net_xmits =  %d\n",
-		   vnicinfo->upper_threshold_net_xmits);
 	vnicinfo->lower_threshold_net_xmits =
 	    max(1, vnicinfo->max_outstanding_net_xmits / 2);
-	LOGINFNAME(vnicinfo->netdev, "lower_threshold_net_xmits =  %d\n",
-		   vnicinfo->lower_threshold_net_xmits);
 	skb_queue_head_init(&vnicinfo->xmitbufhead);
 
 	/* create a cmdrsp we can use to post and unpost rcv buffers  */
 	vnicinfo->cmdrsp_rcv = kmalloc(SIZEOF_CMDRSP, GFP_ATOMIC);
-	if (vnicinfo->cmdrsp_rcv == NULL) {
-		LOGERRNAME(vnicinfo->netdev,
-			   "**** FAILED to allocate cmdrsp to use for posting rcv buffers\n");
-		RETFAIL(-ENOMEM);
-	}
+	if (vnicinfo->cmdrsp_rcv == NULL)
+			RETFAIL(-ENOMEM);
+
 	vnicinfo->xmit_cmdrsp = kmalloc(SIZEOF_CMDRSP, GFP_ATOMIC);
-	if (vnicinfo->xmit_cmdrsp == NULL) {
-		LOGERRNAME(vnicinfo->netdev,
-			   "**** FAILED to allocate cmdrsp to use for xmits\n");
-		RETFAIL(-ENOMEM);
-	}
+	if (vnicinfo->xmit_cmdrsp == NULL)
+			RETFAIL(-ENOMEM);
+
 	INIT_WORK(&vnicinfo->serverdown_completion,
 		  virtnic_serverdown_complete);
 	INIT_WORK(&vnicinfo->timeout_reset, virtnic_timeout_reset);
@@ -504,9 +475,6 @@ virtnic_probe(struct virtpci_dev *virtpcidev, const struct pci_device_id *id)
 	writeq(readq(&vnicinfo->datachan.chinfo.queueinfo->chan->features) |
 	       ULTRA_IO_CHANNEL_IS_POLLING,
 	       &vnicinfo->datachan.chinfo.queueinfo->chan->features);
-	DBGINF("starting rsp thread queueinfo:%p threadinfo:%p\n",
-	       vnicinfo->datachan.chinfo.queueinfo,
-	       &vnicinfo->datachan.chinfo.threadinfo);
 	p_channel_header = vnicinfo->datachan.chinfo.queueinfo->chan;
 	pqhdr = (struct signal_queue_header __iomem *)
 		((char __iomem *)p_channel_header +
@@ -514,23 +482,11 @@ virtnic_probe(struct virtpci_dev *virtpcidev, const struct pci_device_id *id)
 	    IOCHAN_FROM_IOPART;
 	vnicinfo->flags_addr = (__force uint64_t __iomem *)&pqhdr->features;
 	vnicinfo->thread_wait_ms = 2;
-	if (!uisthread_start(&vnicinfo->datachan.chinfo.threadinfo,
-			     process_incoming_rsps, &vnicinfo->datachan,
-			     "vnic_incoming")) {
-		LOGERRNAME(vnicinfo->netdev, "**** FAILED to start thread\n");
-		RETFAIL(-ENODEV);
-	}
+	uisthread_start(&vnicinfo->datachan.chinfo.threadinfo,
+			process_incoming_rsps, &vnicinfo->datachan,
+			"vnic_incoming");
 
 	/* register_netdev */
-	LOGINFNAME(vnicinfo->netdev, "sendInterruptHandle=0x%16llX",
-		   (unsigned long long)vnicinfo->intr.send_irq_handle);
-	LOGINFNAME(vnicinfo->netdev, "recvInterruptHandle=0x%16llX",
-		   (unsigned long long)vnicinfo->intr.recv_irq_handle);
-	LOGINFNAME(vnicinfo->netdev, "recvInterruptVector=0x%8X",
-		   vnicinfo->intr.recv_irq_vector);
-	LOGINFNAME(vnicinfo->netdev, "recvInterruptShared=0x%2X",
-		   vnicinfo->intr.recv_irq_shared);
-	LOGINFNAME(vnicinfo->netdev, "netdev->name=%s", netdev->name);
 	vnicinfo->interrupt_vector = vnicinfo->intr.recv_irq_handle &
 	    INTERRUPT_VECTOR_MASK;
 	netdev->irq = vnicinfo->interrupt_vector;
@@ -544,9 +500,6 @@ virtnic_probe(struct virtpci_dev *virtpcidev, const struct pci_device_id *id)
 	vnicinfo->eth_debugfs_dir = debugfs_create_dir(netdev->name,
 						       virtnic_debugfs_dir);
 	if (!vnicinfo->eth_debugfs_dir) {
-		LOGERRNAME(vnicinfo->netdev,
-			   "****FAILED to create proc dir entry:%s\n",
-			   netdev->name);
 		uisthread_stop(&vnicinfo->datachan.chinfo.threadinfo);
 		RETFAIL(-ENODEV);
 	}
@@ -564,16 +517,10 @@ virtnic_probe(struct virtpci_dev *virtpcidev, const struct pci_device_id *id)
 	rsp = request_irq(vnicinfo->interrupt_vector, handler, IRQF_SHARED,
 			  netdev->name, vnicinfo);
 	if (rsp != 0) {
-		LOGERRNAME(vnicinfo->netdev,
-			   "request_irq(%d) uislib_vnic_ISR request failed with rsp=%d\n",
-			   vnicinfo->interrupt_vector, rsp);
 		vnicinfo->interrupt_vector = -1;
 	} else {
 		uint64_t __iomem *features_addr =
 		    &vnicinfo->datachan.chinfo.queueinfo->chan->features;
-		LOGERRNAME(vnicinfo->netdev,
-			   "request_irq(%d) uislib_vnic_ISR request succeeded\n",
-			   vnicinfo->interrupt_vector);
 		mask = ~(ULTRA_IO_CHANNEL_IS_POLLING |
 			 ULTRA_IO_DRIVER_DISABLES_INTS |
 			 ULTRA_IO_DRIVER_SUPPORTS_ENHANCED_RCVBUF_CHECKING);
@@ -585,12 +532,6 @@ virtnic_probe(struct virtpci_dev *virtpcidev, const struct pci_device_id *id)
 		vnicinfo->thread_wait_ms = 2000;
 	}
 
-	LOGINFNAME(vnicinfo->netdev,
-		   "Added VirtNic:%p %s insertlock:%p %02x:%02x:%02x:%02x:%02x:%02x\n",
-		   netdev, netdev->name, &vnicinfo->datachan.chinfo.insertlock,
-		   netdev->dev_addr[0], netdev->dev_addr[1],
-		   netdev->dev_addr[2], netdev->dev_addr[3],
-		   netdev->dev_addr[4], netdev->dev_addr[5]);
 	return 0;
 }
 
@@ -602,14 +543,7 @@ virtnic_remove(struct virtpci_dev *virtpcidev)
 
 	vnicinfo = netdev_priv(netdev);
 
-	LOGINFNAME(vnicinfo->netdev,
-		   "virtpcidev:%p netdev:%p name:%s vnicinfo:%p\n",
-		   virtpcidev, netdev, netdev->name, vnicinfo);
-	LOGINFNAME(vnicinfo->netdev,
-		   "virtpcidev busNo<<%d>>devNo<<%d>>",
-		   virtpcidev->bus_no, virtpcidev->device_no);
 	/* REMOVE netdev */
-	DBGINF("unregistering netdev\n");
 	if (vnicinfo->interrupt_vector != -1)
 		free_irq(vnicinfo->interrupt_vector, vnicinfo);
 	unregister_netdev(netdev);
@@ -627,13 +561,9 @@ virtnic_remove(struct virtpci_dev *virtpcidev)
 	device_remove_file(&netdev->dev, &dev_attr_clientstr);
 
 	debugfs_remove(vnicinfo->eth_debugfs_dir);
-	LOGINFNAME(vnicinfo->netdev, "removed dentry %s\n",
-		   netdev->name);
 
 	kfree(vnicinfo->rcvbuf);
 	free_netdev(netdev);
-
-	LOGINF("virtnic removed\n");
 }
 
 /*****************************************************/
@@ -656,31 +586,6 @@ static struct net_device_stats *
 virtnic_get_stats(struct net_device *netdev)
 {
 	struct virtnic_info *vnicinfo = netdev_priv(netdev);
-
-	/* take this opportunity to print out our internal stats */
-	DBGINF
-	    ("NET_RCV_ENBDIS sent: %ld     NET_RCV_ENBDIS_ACK received: %ld\n",
-	     vnicinfo->datachan.chstat.sent_enbdis,
-	     vnicinfo->datachan.chstat.got_enbdisack);
-
-	DBGINF("NET_RCV received: %ld        NET_RCV_POST sent: %ld\n",
-	       vnicinfo->datachan.chstat.got_rcv,
-	       vnicinfo->datachan.chstat.sent_post);
-
-	DBGINF("extra NET_RCV_POST sent: %ld\n",
-	       vnicinfo->datachan.chstat.extra_rcvbufs_sent);
-
-	DBGINF("NET_XMIT sent: %ld           NET_XMIT_DONE received: %ld\n",
-	       vnicinfo->datachan.chstat.sent_xmit,
-	       vnicinfo->datachan.chstat.got_xmit_done);
-
-	DBGINF("XMIT failures: %ld           NET_RCV_PROMISC sent: %ld\n",
-	       vnicinfo->datachan.chstat.xmit_fail,
-	       vnicinfo->datachan.chstat.sent_promisc);
-
-	DBGINF("XMIT reject/busy: %ld\n",
-	       vnicinfo->datachan.chstat.reject_count);
-
 	return &vnicinfo->net_stats;
 }
 
@@ -702,13 +607,10 @@ alloc_rcv_buf(struct net_device *netdev)
  * For now all rcv buffers will be RCVPOST_BUF_SIZE in length, so the firstfrag
  * is large enough to hold 1514.
  */
-	DBGINF("netdev->name <<%s>>:  allocating skb len:%d\n", netdev->name,
-	       RCVPOST_BUF_SIZE);
 	skb = alloc_skb(RCVPOST_BUF_SIZE, GFP_ATOMIC | __GFP_NOWARN);
-	if (!skb) {
-		LOGVER("**** alloc_skb failed\n");
-		return NULL;
-	}
+	if (!skb)
+			return NULL;
+
 	skb->dev = netdev;
 	skb->len = RCVPOST_BUF_SIZE;
 	/* current value of mtu doesn't come into play here; large
@@ -725,7 +627,6 @@ init_rcv_bufs(struct net_device *netdev, struct virtnic_info *vnicinfo)
 {
 	int i, count;
 
-	DBGINF("netdev->name <<%s>>", netdev->name);
 	/*
 	 * allocate fixed number of receive buffers to post to uisnic
 	 * post receive buffers after we've allocated a required
@@ -737,15 +638,8 @@ init_rcv_bufs(struct net_device *netdev, struct virtnic_info *vnicinfo)
 			break;	/* if we failed to allocate one let us stop */
 	}
 	if (i < vnicinfo->num_rcv_bufs) {
-		LOGWRNNAME(vnicinfo->netdev,
-			   "only allocated %d of %d receive buffers", i,
-			   vnicinfo->num_rcv_bufs);
-		if (i == 0) {
-			/* couldn't even allocate one - bail out */
-			LOGERRNAME(vnicinfo->netdev,
-				   "**** FAILED to allocate any rcv buffers\n");
-			return -ENOMEM;
-		}
+		if (i == 0) /* couldn't even allocate one - bail out */
+				return -ENOMEM;
 	}
 	count = i;
 	/* Ensure we can alloc 2/3rd of the requested number of
@@ -753,9 +647,6 @@ init_rcv_bufs(struct net_device *netdev, struct virtnic_info *vnicinfo)
 	 * init.c.
 	 */
 	if (count < ((2 * vnicinfo->num_rcv_bufs) / 3)) {
-		LOGERRNAME(vnicinfo->netdev,
-			   "**** FAILED to allocate enough rcv bufs; allocated only:%d MAX_NET_RCV_BUFS:%d\n",
-			   count, MAX_NET_RCV_BUFS);
 		/* free receive buffers we did allocate and then bail out */
 		for (i = 0; i < count; i++) {
 			kfree_skb(vnicinfo->rcvbuf[i]);
@@ -772,9 +663,6 @@ init_rcv_bufs(struct net_device *netdev, struct virtnic_info *vnicinfo)
 
 	/* push through with what buffers we've got - unallocated ones will */
 	/* be null */
-	LOGINFNAME(vnicinfo->netdev, "Allocated & posted %d rcv buffers\n",
-		   count);
-
 	return 0;
 }
 
@@ -792,7 +680,6 @@ virtnic_disable_with_timeout(struct net_device *netdev, const int timeout)
 	unsigned long flags;
 	int wait = 0;
 
-	LOGINFNAME(vnicinfo->netdev, "netdev->name <<%s>>", netdev->name);
 	/* stop the transmit queue so nothing more can be transmitted */
 	netif_stop_queue(netdev);
 
@@ -811,8 +698,6 @@ virtnic_disable_with_timeout(struct net_device *netdev, const int timeout)
 		    &vnicinfo->datachan.chinfo.insertlock,
 		    vnicinfo->datachan.chstat);
 
-	LOGINFNAME(vnicinfo->netdev,
-		   "Waiting for ENBDIS ACK before freeing rcv buffers...\n");
 	/* wait for ack to arrive before we try to free rcv buffers
 	 * NOTE: the other end automatically unposts the rcv buffers
 	 * when it gets a disable.
@@ -825,8 +710,6 @@ virtnic_disable_with_timeout(struct net_device *netdev, const int timeout)
 			break;
 		} else if (vnicinfo->server_down ||
 			vnicinfo->server_change_state) {
-			LOGERRNAME(vnicinfo->netdev,
-				   "IOVM is down so disable will not be acknowledged.  Stopping wait.\n");
 			spin_unlock_irqrestore(&vnicinfo->priv_lock, flags);
 			return -1;
 		}
@@ -835,14 +718,9 @@ virtnic_disable_with_timeout(struct net_device *netdev, const int timeout)
 		wait += schedule_timeout(msecs_to_jiffies(10));
 	}
 	if (!vnicinfo->n_rcv_packet_not_accepted) {
-		LOGERRNAME(vnicinfo->netdev,
-			   "IOVM did not respond to Disable in allocated time (%d msecs).\n",
-			   timeout);
 		spin_unlock_irqrestore(&vnicinfo->priv_lock, flags);
 		return -1;
 	}
-	LOGINFNAME(vnicinfo->netdev,
-		   "Got ENBDIS ACK; now waiting for 0 usage count...\n");
 
 	/*
 	 * wait for usage to go to 1 (no other users) before freeing
@@ -863,8 +741,6 @@ virtnic_disable_with_timeout(struct net_device *netdev, const int timeout)
 	}
 	/* we've set enabled to 0, so we can give up the lock. */
 	spin_unlock_irqrestore(&vnicinfo->priv_lock, flags);
-	LOGINFNAME(vnicinfo->netdev,
-		   "Usage count is 0; freeing the rcv buffers now\n");
 
 	/* free rcv buffers - other end has automatically unposted
 	 * them on disable
@@ -876,7 +752,6 @@ virtnic_disable_with_timeout(struct net_device *netdev, const int timeout)
 			count++;
 		}
 	}
-	LOGINFNAME(vnicinfo->netdev, "Freed %d rcv bufs\n", count);
 
 	/* remove references from debug array */
 	for (i = 0; i < VIRTNICSOPENMAX; i++) {
@@ -934,9 +809,6 @@ virtnic_enable_with_timeout(struct net_device *netdev, const int timeout)
 		    &vnicinfo->datachan.chinfo.insertlock,
 		    vnicinfo->datachan.chstat);
 
-	LOGINFNAME(vnicinfo->netdev, "netdev->name <<%s>>", netdev->name);
-	LOGINFNAME(vnicinfo->netdev,
-		   "Waiting for ENBDIS ACK before starting device queue...\n");
 	while ((timeout == VIRTNIC_INFINITE_RESPONSE_WAIT) ||
 	       (wait < timeout)) {
 		spin_lock_irqsave(&vnicinfo->priv_lock, flags);
@@ -946,8 +818,6 @@ virtnic_enable_with_timeout(struct net_device *netdev, const int timeout)
 		} else if (vnicinfo->server_down ||
 			   vnicinfo->server_change_state) {
 			/* IOVM is going down so don't wait for a response */
-			LOGERRNAME(vnicinfo->netdev,
-				   "IOVM is down so enable will not be acknowledged.  Stopping wait.\n");
 			spin_unlock_irqrestore(&vnicinfo->priv_lock, flags);
 			return -1;
 		}
@@ -956,14 +826,10 @@ virtnic_enable_with_timeout(struct net_device *netdev, const int timeout)
 		wait += schedule_timeout(msecs_to_jiffies(10));
 	}
 	if (!vnicinfo->enab_dis_acked) {
-		LOGERRNAME(vnicinfo->netdev,
-			   "IOVM did not respond to Enable in allocated time (%d msecs).\n",
-			   timeout);
 		spin_unlock_irqrestore(&vnicinfo->priv_lock, flags);
 		return -1;
 	}
 	spin_unlock_irqrestore(&vnicinfo->priv_lock, flags);
-	LOGINFNAME(vnicinfo->netdev, "Got ENBDIS ACK\n");
 
 	/* find an open slot in the array to save off VirtNic
 	 * references for debug
@@ -975,10 +841,6 @@ virtnic_enable_with_timeout(struct net_device *netdev, const int timeout)
 			break;
 		}
 	}
-	if (i == VIRTNICSOPENMAX)
-		LOGINFNAME(vnicinfo->netdev,
-			   "No storage for debug ref for netdev = 0x%p vnicinfo = 0x%p\n",
-			   netdev, vnicinfo);
 
 	return 0;
 }
@@ -1017,17 +879,13 @@ send_rcv_posts_if_needed(struct virtnic_info *vnicinfo)
 				continue;
 			vnicinfo->rcvbuf[i] = alloc_rcv_buf(netdev);
 			if (!vnicinfo->rcvbuf[i]) {
-				LOGVER("**** %s FAILED to allocate new rcv buf - no REPOST\n",
-				       netdev->name);
-				vnicinfo->
-				    alloc_failed_in_if_needed_cnt++;
+				vnicinfo->alloc_failed_in_if_needed_cnt++;
 				break;
 			} else {
 				rcv_bufs_allocated++;
 				post_skb(cmdrsp, vnicinfo,
 					 vnicinfo->rcvbuf[i]);
-				vnicinfo->datachan.chstat.
-				    extra_rcvbufs_sent++;
+				vnicinfo->datachan.chstat.extra_rcvbufs_sent++;
 			}
 		}
 	}
@@ -1038,10 +896,6 @@ send_rcv_posts_if_needed(struct virtnic_info *vnicinfo)
 		 * normal path, and you are trying again later, and
 		 * it still fails.
 		 */
-		LOGVER("attempted to recover buffers which could not be allocated and failed");
-		LOGVER("rcv_bufs_allocated=%d, num_rcv_bufs_could_not_alloc=%d",
-		       rcv_bufs_allocated,
-		       vnicinfo->num_rcv_bufs_could_not_alloc);
 	}
 }
 
@@ -1055,6 +909,8 @@ drain_queue(struct datachan *dc, struct uiscmdrsp *cmdrsp,
 
 	/* drain queue */
 	while (1) {
+		if (kthread_should_stop())
+			break;
 		spin_lock_irqsave(&dc->chinfo.insertlock, flags);
 		if (!spar_channel_client_acquire_os(dc->chinfo.queueinfo->chan,
 						    "vnic")) {
@@ -1069,32 +925,22 @@ drain_queue(struct datachan *dc, struct uiscmdrsp *cmdrsp,
 		spin_unlock_irqrestore(&dc->chinfo.insertlock, flags);
 		if (qrslt == 0)
 			break;	/* queue empty */
-		DBGINF("%p cmdrsp->net.type:%d\n",
-		       &dc->chinfo.queueinfo, cmdrsp->net.type);
 		switch (cmdrsp->net.type) {
 		case NET_RCV:
-			DBGINF("Got NET_RCV\n");
 			dc->chstat.got_rcv++;
 			/* process incoming packet */
 			virtnic_rx(cmdrsp);
 			break;
 		case NET_XMIT_DONE:
-			DBGINF("Got NET_XMIT_DONE %p\n", cmdrsp->net.buf);
 			spin_lock_irqsave(&vnicinfo->priv_lock, flags);
 			dc->chstat.got_xmit_done++;
-			if (cmdrsp->net.xmtdone.xmt_done_result) {
-				LOGERRNAME(vnicinfo->netdev,
-					   "XMIT_DONE failure buf:%p\n",
-					   cmdrsp->net.buf);
-				dc->chstat.xmit_fail++;
-			}
+			if (cmdrsp->net.xmtdone.xmt_done_result)
+					dc->chstat.xmit_fail++;
 			/* only call queue wake if we stopped it */
 			netdev = ((struct sk_buff *)cmdrsp->net.buf)->dev;
 			/* ASSERT netdev == vnicinfo->netdev; */
-			if (netdev != vnicinfo->netdev) {
-				LOGERRNAME(vnicinfo->netdev, "NET_XMIT_DONE something wrong; vnicinfo->netdev:%p != cmdrsp->net.buf)->dev:%p\n",
-					   vnicinfo->netdev, netdev);
-			} else if (netif_queue_stopped(netdev)) {
+			if (netdev == vnicinfo->netdev &&
+			    netif_queue_stopped(netdev)) {
 				/*
 				 * check to see if we have crossed
 				 * the lower watermark for
@@ -1124,9 +970,6 @@ drain_queue(struct datachan *dc, struct uiscmdrsp *cmdrsp,
 			kfree_skb(cmdrsp->net.buf);
 			break;
 		case NET_RCV_ENBDIS_ACK:
-			DBGINF("Got NET_RCV_ENBDIS_ACK on:%p\n",
-			       (struct net_device *)
-			       cmdrsp->net.enbdis.context);
 			dc->chstat.got_enbdisack++;
 			netdev = (struct net_device *)
 				cmdrsp->net.enbdis.context;
@@ -1144,8 +987,6 @@ drain_queue(struct datachan *dc, struct uiscmdrsp *cmdrsp,
 			}
 			break;
 		case NET_CONNECT_STATUS:
-			DBGINF("NET_CONNECT_STATUS, enable=:%d\n",
-			       cmdrsp->net.enbdis.enable);
 			netdev = vnicinfo->netdev;
 			if (cmdrsp->net.enbdis.enable == 1) {
 				spin_lock_irqsave(&vnicinfo->priv_lock, flags);
@@ -1164,15 +1005,9 @@ drain_queue(struct datachan *dc, struct uiscmdrsp *cmdrsp,
 			}
 			break;
 		default:
-			LOGERRNAME(vnicinfo->netdev,
-				   "Invalid net type:%d in cmdrsp\n",
-				   cmdrsp->net.type);
 			break;
 		}
 		/* cmdrsp is now available for reuse  */
-
-		if (dc->chinfo.threadinfo.should_stop)
-			break;
 	}
 }
 
@@ -1189,16 +1024,13 @@ process_incoming_rsps(void *v)
 	unsigned long long rc1;
 
 	UIS_DAEMONIZE("vnic_incoming");
-	DBGINF("In process_incoming_rsps pid:%d queueinfo:%p threadinfo:%p\n",
-	       current->pid, dc->chinfo.queueinfo, &dc->chinfo.threadinfo);
 	/* alloc once and reuse */
 	vnicinfo = container_of(dc, struct virtnic_info, datachan);
 	cmdrsp = kmalloc(SZ, GFP_ATOMIC);
-	if (cmdrsp == NULL) {
-		LOGERRNAME(vnicinfo->netdev,
-			   "**** FAILED to malloc - thread exiting\n");
-		complete_and_exit(&dc->chinfo.threadinfo.has_stopped, 0);
-	}
+	if (cmdrsp == NULL)
+			complete_and_exit(&dc->chinfo.threadinfo.has_stopped,
+					  0);
+
 	p_channel_header = vnicinfo->datachan.chinfo.queueinfo->chan;
 	pqhdr =
 	       (struct signal_queue_header __iomem *)
@@ -1207,6 +1039,8 @@ process_incoming_rsps(void *v)
 	       IOCHAN_FROM_IOPART;
 	mask = ULTRA_CHANNEL_ENABLE_INTS;
 	while (1) {
+		if (kthread_should_stop())
+			break;
 		wait_event_interruptible_timeout(
 			vnicinfo->rsp_queue, (atomic_read
 					      (&vnicinfo->interrupt_rcvd) == 1),
@@ -1221,12 +1055,9 @@ process_incoming_rsps(void *v)
 		drain_queue(dc, cmdrsp, vnicinfo);
 		rc1 = uisqueue_interlocked_or((uint64_t __iomem *)
 					     vnicinfo->flags_addr, mask);
-		if (dc->chinfo.threadinfo.should_stop)
-			break;
 	}
 
 	kfree(cmdrsp);
-	DBGINF("In process_incoming_nic_rsp exiting\n");
 	complete_and_exit(&dc->chinfo.threadinfo.has_stopped, 0);
 }
 
@@ -1237,11 +1068,6 @@ process_incoming_rsps(void *v)
 static int
 virtnic_change_mtu(struct net_device *netdev, int new_mtu)
 {
-	LOGERRNAME(netdev, "netdev->name <<%s>>", netdev->name);
-	LOGERRNAME(netdev, "**** FAILED: MTU cannot be changed at this end.\n");
-	LOGERRNAME(netdev, "The same MTU is used for all the PNICs and VNICs in a switch.\n");
-	LOGERRNAME(netdev, "Please change MTU from the Resource Partition\n");
-	LOGERRNAME(netdev, "Current MTU is: %d\n", netdev->mtu);
 	return -EINVAL;
 	/*
 	 * we cannot willy-nilly change the MTU; it has to come from
@@ -1260,13 +1086,8 @@ virtnic_close(struct net_device *netdev)
 	/* this is called on ifconfig down but also if the device is
 	 * being removed
 	 */
-	LOGINFNAME(netdev, "Closing %p name:%s\n", netdev, netdev->name);
-
 	netif_stop_queue(netdev);
 	virtnic_disable(netdev);
-
-	LOGINFNAME(netdev, "Closed:%p\n", netdev);
-
 	return 0;
 }
 
@@ -1283,36 +1104,11 @@ virtnic_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
 static int
 virtnic_open(struct net_device *netdev)
 {
-	struct virtnic_info *vnicinfo = netdev_priv(netdev);
-	void *p = (__force void *)netdev->ip_ptr;
-
-	LOGINFNAME(vnicinfo->netdev,
-		   "Opening %p name:%s allocating:%d rcvbufs mtu:%d\n", netdev,
-		   netdev->name, vnicinfo->num_rcv_bufs, netdev->mtu);
-
 	virtnic_enable(netdev);
 	/* start the interface's transmit queue, allowing it accept
 	 * packets for transmission
 	 */
 	netif_start_queue(netdev);
-
-	LOGINFNAME(vnicinfo->netdev,
-		   "Opened %p netdev->ip_ptr:%p name:%s %02x:%02x:%02x:%02x:%02x:%02x\n",
-		   netdev, netdev->ip_ptr, netdev->name, netdev->dev_addr[0],
-		   netdev->dev_addr[1], netdev->dev_addr[2],
-		   netdev->dev_addr[3], netdev->dev_addr[4],
-		   netdev->dev_addr[5]);
-
-	/*
-	 * temporary code to see trap to catch if vnic inet addresses
-	 * are getting trashed
-	 */
-	if (p != (__force void *)netdev->ip_ptr) {
-		LOGERRNAME(vnicinfo->netdev, "***********FAILURE HAPPENED\n");
-		LOGERRNAME(vnicinfo->netdev, "           Test to catch if vnic inet addresses are getting trashed.\n");
-		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(msecs_to_jiffies(1000));
-	}
 	return 0;
 }
 
@@ -1329,8 +1125,6 @@ repost_return(
 	int status = 0;
 
 	copy = cmdrsp->net.rcv;
-	LOGVER("REPOST_RETURN: realloc rcv skbs to replace:%d rcvbufs\n",
-	       copy.numrcvbufs);
 	switch (copy.numrcvbufs) {
 	case 0:
 		vnicinfo->n_rcv0++;
@@ -1350,8 +1144,6 @@ repost_return(
 			if (vnicinfo->rcvbuf[i] != copy.rcvbuf[cc])
 				continue;
 
-			LOGVER("REPOST_RETURN: orphaning old rcvbuf[%d]:%p cc=%d",
-			       i, vnicinfo->rcvbuf[i], cc);
 			vnicinfo->found_repost_rcvbuf_cnt++;
 			if ((skb) && vnicinfo->rcvbuf[i] == skb) {
 				found_skb = 1;
@@ -1359,34 +1151,24 @@ repost_return(
 			}
 			vnicinfo->rcvbuf[i] = alloc_rcv_buf(netdev);
 			if (!vnicinfo->rcvbuf[i]) {
-				LOGVER("**** %s FAILED to reallocate new rcv buf - no REPOST, found_skb=%d, cc=%d, i=%d\n",
-				       netdev->name, found_skb, cc, i);
 				vnicinfo->num_rcv_bufs_could_not_alloc++;
 				vnicinfo->alloc_failed_in_repost_return_cnt++;
 				status = -1;
 				break;
 			}
-			LOGVER("REPOST_RETURN: reposting new rcvbuf[%d]:%p\n",
-			       i, vnicinfo->rcvbuf[i]);
 			post_skb(cmdrsp, vnicinfo, vnicinfo->rcvbuf[i]);
 			numreposted++;
 			break;
 		}
 	}
-	LOGVER("REPOST_RETURN: num rcvbufs posted:%d\n", numreposted);
 	if (numreposted != copy.numrcvbufs) {
-		LOGVER("**** %s FAILED to repost all the rcv bufs; numreposted:%d rcv.numrcvbufs:%d\n",
-		       netdev->name, numreposted, copy.numrcvbufs);
 		vnicinfo->n_repost_deficit++;
 		status = -1;
 	}
 	if (skb) {
 		if (found_skb) {
-			LOGVER("REPOST_RETURN: skb is %p - freeing it", skb);
 			kfree_skb(skb);
 		} else {
-			LOGERRNAME(vnicinfo->netdev, "%s REPOST_RETURN: skb %p NOT found in rcvbuf list!!",
-				   netdev->name, skb);
 			status = -3;
 			vnicinfo->bad_rcv_buf++;
 		}
@@ -1417,10 +1199,7 @@ virtnic_rx(struct uiscmdrsp *cmdrsp)
 	skb = cmdrsp->net.buf;
 	netdev = skb->dev;
 
-	if (netdev)
-		DBGINF("in virtnic_rx %p %s len:%d\n", netdev, netdev->name,
-		       cmdrsp->net.rcv.rcv_done_len);
-	else {
+	if (!netdev) {
 		/* We must have previously downed this network device and
 		 * this skb and device is no longer valid. This also means
 		 * the skb reference was removed from virtnic->rcvbuf so no
@@ -1455,11 +1234,8 @@ virtnic_rx(struct uiscmdrsp *cmdrsp)
 		 * don't process it unless we're in enable mode and until
 		 * we've gotten an ACK saying the other end got our RCV enable
 		 */
-		LOGERRNAME(vnicinfo->netdev,
-			   "%s dropping packet - perhaps old\n", netdev->name);
 		spin_unlock_irqrestore(&vnicinfo->priv_lock, flags);
-		if (repost_return(cmdrsp, vnicinfo, skb, netdev) < 0)
-			LOGERRNAME(vnicinfo->netdev, "repost_return failed");
+		repost_return(cmdrsp, vnicinfo, skb, netdev);
 		return;
 	}
 
@@ -1477,12 +1253,7 @@ virtnic_rx(struct uiscmdrsp *cmdrsp)
 	 */
 	if (skb->len > RCVPOST_BUF_SIZE) {	/* do PRECAUTIONARY check */
 		if (cmdrsp->net.rcv.numrcvbufs < 2) {
-			LOGERRNAME(vnicinfo->netdev, "**** %s Something is wrong; rcv_done_len:%d > RCVPOST_BUF_SIZE:%d but numrcvbufs:%d < 2\n",
-				   netdev->name, skb->len, RCVPOST_BUF_SIZE,
-				   cmdrsp->net.rcv.numrcvbufs);
-			if (repost_return(cmdrsp, vnicinfo, skb, netdev) < 0)
-				LOGERRNAME(vnicinfo->netdev,
-					   "repost_return failed");
+			repost_return(cmdrsp, vnicinfo, skb, netdev);
 			return;
 		}
 		/* length rcvd is greater than firstfrag in this skb rcv buf  */
@@ -1490,18 +1261,12 @@ virtnic_rx(struct uiscmdrsp *cmdrsp)
 		skb->data_len = skb->len - RCVPOST_BUF_SIZE;	/* amount that
 								   will be in
 								   frag_list */
-		DBGINF("len:%d data:%d\n", skb->len, skb->data_len);
 	} else {
 		/*
 		 * data fits in this skb - no chaining - do PRECAUTIONARY check
 		 */
 		if (cmdrsp->net.rcv.numrcvbufs != 1) {	/* should be 1 */
-			LOGERRNAME(vnicinfo->netdev, "**** %s Something is wrong; rcv_done_len:%d <= RCVPOST_BUF_SIZE:%d but numrcvbufs:%d != 1\n",
-				   netdev->name, skb->len, RCVPOST_BUF_SIZE,
-				   cmdrsp->net.rcv.numrcvbufs);
-			if (repost_return(cmdrsp, vnicinfo, skb, netdev) < 0)
-				LOGERRNAME(vnicinfo->netdev,
-					   "repost_return failed");
+			repost_return(cmdrsp, vnicinfo, skb, netdev);
 			return;
 		}
 		skb->tail += skb->len;
@@ -1519,10 +1284,7 @@ virtnic_rx(struct uiscmdrsp *cmdrsp)
 	 * - do PRECAUTIONARY check
 	 */
 	if (cmdrsp->net.rcv.rcvbuf[0] != skb) {
-		LOGERRNAME(vnicinfo->netdev, "**** %s Something is wrong; rcvbuf[0]:%p != skb:%p\n",
-			   netdev->name, cmdrsp->net.rcv.rcvbuf[0], skb);
-		if (repost_return(cmdrsp, vnicinfo, skb, netdev) < 0)
-			LOGERRNAME(vnicinfo->netdev, "repost_return failed");
+		repost_return(cmdrsp, vnicinfo, skb, netdev);
 		return;
 	}
 
@@ -1533,8 +1295,6 @@ virtnic_rx(struct uiscmdrsp *cmdrsp)
 		     cc < cmdrsp->net.rcv.numrcvbufs; cc++) {
 			curr = (struct sk_buff *)cmdrsp->net.rcv.rcvbuf[cc];
 			curr->next = NULL;
-			DBGINF("chaining skb:%p data:%p to skb:%p data:%p\n",
-			       curr, curr->data, skb, skb->data);
 			if (prev == NULL)	/* start of list- set head */
 				skb_shinfo(skb)->frag_list = curr;
 			else
@@ -1552,28 +1312,6 @@ virtnic_rx(struct uiscmdrsp *cmdrsp)
 			curr->data_len = 0;
 			off += currsize;
 		}
-#ifdef DEBUG
-		/* assert skb->len == off */
-		if (skb->len != off) {
-			LOGERRNAME(vnicinfo->netdev, "%s something wrong; skb->len:%d != off:%d\n",
-				   netdev->name, skb->len, off);
-		}
-		/* test code */
-		cc = util_copy_fragsinfo_from_skb("rcvchaintest", skb,
-						  RCVPOST_BUF_SIZE,
-						  MAX_PHYS_INFO, testfrags);
-		LOGINFNAME(vnicinfo->netdev, "rcvchaintest returned:%d\n", cc);
-		if (cc != cmdrsp->net.rcv.numrcvbufs) {
-			LOGERRNAME(vnicinfo->netdev, "**** %s Something wrong; rcvd chain length %d different from one we calculated %d\n",
-				   netdev->name, cmdrsp->net.rcv.numrcvbufs,
-				   cc);
-		}
-		for (i = 0; i < cc; i++) {
-			LOGINFNAME(vnicinfo->netdev, "test:RCVPOST_BUF_SIZE:%d[%d] pfn:%llu off:0x%x len:%d\n",
-				   RCVPOST_BUF_SIZE, i, testfrags[i].pi_pfn,
-				   testfrags[i].pi_off, testfrags[i].pi_len);
-		}
-#endif
 	}
 
 	/* set up packet's protocl type using ethernet header - this
@@ -1583,38 +1321,23 @@ virtnic_rx(struct uiscmdrsp *cmdrsp)
 
 	eth = eth_hdr(skb);
 
-	DBGINF("%d Src:%02x:%02x:%02x:%02x:%02x:%02x Dest:%02x:%02x:%02x:%02x:%02x:%02x proto:%x\n",
-	       skb->pkt_type, eth->h_source[0], eth->h_source[1],
-	       eth->h_source[2], eth->h_source[3], eth->h_source[4],
-	       eth->h_source[5], eth->h_dest[0], eth->h_dest[1], eth->h_dest[2],
-	       eth->h_dest[3], eth->h_dest[4], eth->h_dest[5], eth->h_proto);
-
 	skb->csum = 0;
 	skb->ip_summed = CHECKSUM_NONE;	/* trust me, the checksum has
 					   been verified */
 
 	do {
-		if (netdev->flags & IFF_PROMISC) {
-			DBGINF("IFF_PROMISC is set.\n");
-			break;	/* accept all packets */
-		}
+		if (netdev->flags & IFF_PROMISC)
+				break;	/* accept all packets */
 		if (skb->pkt_type == PACKET_BROADCAST) {
-			DBGINF("packet is broadcast.\n");
 			if (netdev->flags & IFF_BROADCAST) {
-				DBGINF("IFF_BROADCAST is set.\n");
 				break;	/* accept all broadcast packets */
 			}
 		} else if (skb->pkt_type == PACKET_MULTICAST) {
-			DBGINF("packet is multicast.\n");
-			if (netdev->flags & IFF_ALLMULTI)
-				DBGINF("IFF_ALLMULTI is set.\n");
 			if ((netdev->flags & IFF_MULTICAST) &&
 			    (netdev_mc_count(netdev))) {
 				struct netdev_hw_addr *ha;
 				int found_mc = 0;
 
-				DBGINF("IFF_MULTICAST is set %d.\n",
-				       netdev_mc_count(netdev));
 				/*
 				 * only accept multicast packets that we can
 				 * find in our multicast address list
@@ -1623,7 +1346,6 @@ virtnic_rx(struct uiscmdrsp *cmdrsp)
 					if (memcmp
 					    (eth->h_dest, ha->addr,
 					     MAX_MACADDR_LEN) == 0) {
-						DBGINF("multicast address is in our list at index:%i.\n", i);
 						found_mc = 1;
 						break;
 					}
@@ -1635,35 +1357,16 @@ virtnic_rx(struct uiscmdrsp *cmdrsp)
 				}
 			}
 		} else if (skb->pkt_type == PACKET_HOST) {
-			DBGINF("packet is directed.\n");
 			break;	/* accept packet, h_dest must match vnic
 				   mac address */
-		} else if (skb->pkt_type == PACKET_OTHERHOST) {
-			/* something is not right */
-			LOGERRNAME(vnicinfo->netdev, "**** FAILED to deliver rcv packet to OS; name:%s Dest:%02x:%02x:%02x:%02x:%02x:%02x VNIC:%02x:%02x:%02x:%02x:%02x:%02x\n",
-				   netdev->name, eth->h_dest[0], eth->h_dest[1],
-				   eth->h_dest[2], eth->h_dest[3],
-				   eth->h_dest[4], eth->h_dest[5],
-				   netdev->dev_addr[0], netdev->dev_addr[1],
-				   netdev->dev_addr[2], netdev->dev_addr[3],
-				   netdev->dev_addr[4], netdev->dev_addr[5]);
 		}
 		/* drop packet - don't forward it up to OS */
-		DBGINF("we cannot indicate this recv pkt! (netdev->flags:0x%04x, skb->pkt_type:0x%02x).\n",
-		       netdev->flags, skb->pkt_type);
 		vnicinfo->n_rcv_packet_not_accepted++;
-		if (repost_return(cmdrsp, vnicinfo, skb, netdev) < 0)
-			LOGERRNAME(vnicinfo->netdev, "repost_return failed");
+		repost_return(cmdrsp, vnicinfo, skb, netdev);
 		return;
 	} while (0);
 
-	DBGINF("Calling netif_rx skb:%p head:%p end:%p data:%p tail:%p len:%d data_len:%d skb->nr_frags:%d\n",
-	       skb, skb->head, skb->end, skb->data, skb->tail, skb->len,
-	       skb->data_len, skb_shinfo(skb)->nr_frags);
-
 	status = netif_rx(skb);
-	if (status != NET_RX_SUCCESS)
-		LOGWRNNAME(vnicinfo->netdev, "status=%d\n", status);
 	/*
 	 * netif_rx returns various values, but "in practice most drivers
 	 * ignore the return value
@@ -1675,8 +1378,7 @@ virtnic_rx(struct uiscmdrsp *cmdrsp)
 	 * kernel code, so we shouldn't free it. but we should repost a
 	 * new rcv buffer.
 	 */
-	if (repost_return(cmdrsp, vnicinfo, skb, netdev) < 0)
-		LOGVER("repost_return failed");
+	repost_return(cmdrsp, vnicinfo, skb, netdev);
 	return;
 }
 
@@ -1703,22 +1405,15 @@ virtnic_xmit(struct sk_buff *skb, struct net_device *netdev)
 }
 
 /* return value NETDEV_TX_OK == 0 */
-	DBGINF("got xmit for netdev:%p %s len:%d ip_summed:%d skb->data:%p data_len:%d skb->h.raw:%p maxdatalen:%d\n",
-	       netdev, netdev->name, skb->len, skb->ip_summed, skb->data,
-	       skb->data_len, skb->h.raw, skb->end - skb->data);
-
 	vnicinfo = netdev_priv(netdev);
 	spin_lock_irqsave(&vnicinfo->priv_lock, flags);
 	/*Modified for Trac #2395 FIX TEL_CKS */
-	if (netif_queue_stopped(netdev)) {
-		LOGINFNAME(vnicinfo->netdev,
-			   "Returning Busy because queue is stopped\n");
-		BUSY;
-	}
-	if (vnicinfo->server_down || vnicinfo->server_change_state) {
-		LOGINFNAME(vnicinfo->netdev, "Returning BUSY because server is down/changing state\n");
-		BUSY;
-	}
+	if (netif_queue_stopped(netdev))
+			BUSY;
+
+	if (vnicinfo->server_down || vnicinfo->server_change_state)
+			BUSY;
+
 	/*
 	 * sk_buff struct is used to host network data throughout all the
 	 * Linux network subsystems
@@ -1732,17 +1427,13 @@ virtnic_xmit(struct sk_buff *skb, struct net_device *netdev)
 	 * pointing to
 	 */
 	firstfraglen = skb->len - skb->data_len;
-	if (firstfraglen < ETH_HEADER_SIZE) {
-		LOGERRNAME(vnicinfo->netdev, "first fragment in skb->data too small for ethernet header len:%d data_len:%d\n",
-			   skb->len, skb->data_len);
-		BUSY;		/* NOT LIKELY TO HAPPEN */
-	}
+	if (firstfraglen < ETH_HEADER_SIZE)
+			BUSY;		/* NOT LIKELY TO HAPPEN */
 
 	if ((len < ETH_MIN_PACKET_SIZE) &&
 	    ((skb_end_pointer(skb) - skb->data) >= ETH_MIN_PACKET_SIZE)) {
 		/* pad the packet out to minimum size */
 		padlen = ETH_MIN_PACKET_SIZE - len;
-		DBGINF("padding %d\n", padlen);
 		memset(&skb->data[len], 0, padlen);
 		skb->tail += padlen;
 		skb->len += padlen;
@@ -1785,32 +1476,15 @@ virtnic_xmit(struct sk_buff *skb, struct net_device *netdev)
 			vnicinfo->datachan.chstat.reject_jiffies_start =
 			    jiffies;
 #endif
-			LOGINFNAME(vnicinfo->netdev, "**** REJECTING NET_XMIT - rejected count=%ld chstat.sent_xmit=%lu chstat.got_xmit_done=%lu\n",
-				   vnicinfo->datachan.chstat.reject_count,
-				   vnicinfo->datachan.chstat.sent_xmit,
-				   vnicinfo->datachan.chstat.got_xmit_done);
 		}
 		netif_stop_queue(netdev);	/* calling stop queue */
 		BUSY;		/* return status that packet not accepted */
 	} else if (vnicinfo->queuefullmsg_logged) {
-#if VIRTNIC_STATS
-		LOGINFNAME(vnicinfo->netdev, "**** NET_XMITs now working again - rejected count = %ld msec = %ld\n",
-			   vnicinfo->datachan.chstat.reject_count,
-			   ((long)jiffies -
-			   (long)(vnicinfo->datachan.chstat.
-				    reject_jiffies_start)) * 1000 / HZ);
-#else
-		LOGINFNAME(vnicinfo->netdev, "**** NET_XMITs now working again - rejected count = %ld\n",
-			   vnicinfo->datachan.chstat.reject_count);
-#endif
 		/* queue is not blocked so reset the logging flag */
 		vnicinfo->queuefullmsg_logged = 0;
 	}
 
 	if (skb->ip_summed == CHECKSUM_UNNECESSARY) {
-		DBGINF("CHECKSUM_HW protocol:%x csum:%x tso_size:%x data:%p h.raw:%p nh.raw:%p\n",
-		       skb->protocol, skb->csum, skb_shinfo(skb)->tso_size,
-		       skb->data, skb->h.raw, skb->nh.raw);
 		cmdrsp->net.xmt.lincsum.valid = 1;
 		cmdrsp->net.xmt.lincsum.protocol = skb->protocol;
 		if (skb_transport_header(skb) > skb->data) {
@@ -1843,13 +1517,10 @@ virtnic_xmit(struct sk_buff *skb, struct net_device *netdev)
 					    MAX_PHYS_INFO,
 					    cmdrsp->net.xmt.frags);
 	if (cmdrsp->net.xmt.num_frags == -1) {
-		LOGERRNAME(vnicinfo->netdev, "**** FAILED to copy fragsinfo\n");
 		BUSY;		/* WILL HAPPEN ONLY IF FRAG ARRAY WITH
 				   MAX_PHYS_INFO ENTRIES IS NOT ENOUGH */
 	}
 
-	DBGINF("Forwarding packet cmdrsp:%p\n", cmdrsp);
-
 	/*
 	 * don't hold lock when forwarding xmit - if queue is full insert
 	 * might sleep
@@ -1863,8 +1534,6 @@ virtnic_xmit(struct sk_buff *skb, struct net_device *netdev)
 			"vnic");
 	if (!qrslt) {
 		/* failed to queue xmit - return busy */
-		LOGERRNAME(vnicinfo->netdev,
-			   "**** FAILED to insert NET_XMIT\n");
 		netif_stop_queue(netdev);	/* calling stop queue  */
 		BUSY;		/* return status that packet not accepted */
 	}
@@ -1925,9 +1594,6 @@ virtnic_serverdown_complete(struct work_struct *work)
 	netdev = vnicinfo->netdev;
 	virtpcidev = vnicinfo->virtpcidev;
 
-	DBGINF("virtpcidev busNo<<%d>>devNo<<%d>>", virtpcidev->busNo,
-	       virtpcidev->deviceNo);
-	DBGINF("net_device name<<%s>>", netdev->name);
 	/* Stop Using Datachan */
 	uisthread_stop(&vnicinfo->datachan.chinfo.threadinfo);
 
@@ -1954,9 +1620,6 @@ virtnic_serverdown_complete(struct work_struct *work)
 	atomic_set(&vnicinfo->num_rcv_bufs_in_iovm, 0);
 	spin_unlock_irqrestore(&vnicinfo->priv_lock, flags);
 
-	LOGINFNAME(vnicinfo->netdev, "Closed:%p Freed %d rcv bufs\n", netdev,
-		   count);
-
 	vnicinfo->server_down = true;
 	vnicinfo->server_change_state = false;
 	visorchipset_device_pause_response(virtpcidev->bus_no,
@@ -1970,22 +1633,13 @@ virtnic_serverdown(struct virtpci_dev *virtpcidev, u32 state)
 	struct net_device *netdev = virtpcidev->net.netdev;
 	struct virtnic_info *vnicinfo = netdev_priv(netdev);
 
-	DBGINF("virtpcidev busNo<<%d>>devNo<<%d>>", virtpcidev->busNo,
-	       virtpcidev->deviceNo);
-	DBGINF("entering virtnic_serverdown");
-
 	if (!vnicinfo->server_down && !vnicinfo->server_change_state) {
 		vnicinfo->server_change_state = true;
 		queue_work(virtnic_serverdown_workqueue,
 			   &vnicinfo->serverdown_completion);
 	} else if (vnicinfo->server_change_state) {
-		LOGERRNAME(vnicinfo->netdev,
-			   "Server already processing change state message.");
 		return 0;
-	} else
-		LOGERRNAME(vnicinfo->netdev,
-			   "Server already down, but another server down message received.");
-	DBGINF("exiting virtnic_serverdown");
+	}
 	return 1;
 }
 
@@ -1997,10 +1651,6 @@ virtnic_serverup(struct virtpci_dev *virtpcidev)
 	struct virtnic_info *vnicinfo = netdev_priv(netdev);
 	unsigned long flags;
 
-	DBGINF("entering virtnic_serverup");
-	DBGINF("virtpcidev busNo<<%d>>devNo<<%d>>", virtpcidev->busNo,
-	       virtpcidev->deviceNo);
-	DBGINF("net_device name<<%s>>", netdev->name);
 	if (vnicinfo->server_down && !vnicinfo->server_change_state) {
 		vnicinfo->server_change_state = true;
 		/*
@@ -2016,8 +1666,6 @@ virtnic_serverup(struct virtpci_dev *virtpcidev)
 		if (!uisthread_start(&vnicinfo->datachan.chinfo.threadinfo,
 				     process_incoming_rsps,
 				     &vnicinfo->datachan, "vnic_incoming")) {
-			LOGERRNAME(vnicinfo->netdev,
-				   "**** FAILED to start thread\n");
 			return 0;
 		}
 
@@ -2043,13 +1691,8 @@ virtnic_serverup(struct virtpci_dev *virtpcidev)
 			    &vnicinfo->datachan.chinfo.insertlock,
 			    vnicinfo->datachan.chstat);
 	} else if (vnicinfo->server_change_state) {
-		LOGERRNAME(vnicinfo->netdev,
-			   "Server already processing change state message.");
 		return 0;
-	} else {
-		DBGINF("Server up message received for server that was already up.");
 	}
-	DBGINF("exiting virtnic_serverup");
 	return 1;
 }
 
@@ -2064,30 +1707,23 @@ virtnic_timeout_reset(struct work_struct *work)
 	vnicinfo = container_of(work, struct virtnic_info, timeout_reset);
 	netdev = vnicinfo->netdev;
 
-	DBGINF("net_device name<<%s>>", netdev->name);
 	/* Transmit Timeouts are typically handled by resetting the
 	 * device for our virtual NIC we will send a Disable and
 	 * Enable to the IOVM.  If it doesn't respond we will trigger
 	 * a serverdown
 	 */
-	DBGINF("Disabling connection to server.\n");
 	netif_stop_queue(netdev);
 	response = virtnic_disable_with_timeout(netdev, 100);
 	if (response != 0)
 		goto call_serverdown;
 
-	DBGINF("Disable returned so reenable connection to server.\n");
 	response = virtnic_enable_with_timeout(netdev, 100);
 	if (response != 0)
 		goto call_serverdown;
 	netif_wake_queue(netdev);
-
-	LOGWRNNAME(vnicinfo->netdev, "Virtual connection reset.\n");
 	return;
 
 call_serverdown:
-	LOGERRNAME(vnicinfo->netdev,
-		   "Disable/enabled Pair failed to return so start serverdown.\n");
 	virtpcidev = vnicinfo->virtpcidev;
 	virtnic_serverdown(virtpcidev, 0);
 	return;
@@ -2099,10 +1735,6 @@ virtnic_xmit_timeout(struct net_device *netdev)
 	struct virtnic_info *vnicinfo = netdev_priv(netdev);
 	unsigned long flags;
 
-	LOGWRNNAME(vnicinfo->netdev,
-		   "Transmit Timeout.  Resetting virtual connection.\n");
-	LOGWRNNAME(vnicinfo->netdev, "net_device name<<%s>>", netdev->name);
-
 	spin_lock_irqsave(&vnicinfo->priv_lock, flags);
 	/* Ensure that a ServerDown message hasn't been received */
 	if (!vnicinfo->enabled ||
@@ -2121,27 +1753,14 @@ virtnic_set_multi(struct net_device *netdev)
 	struct uiscmdrsp *cmdrsp;
 	struct virtnic_info *vnicinfo = netdev_priv(netdev);
 
-	DBGINF("net_device name<<%s>>", netdev->name);
-	DBGINF("entering virtnic_set_multi\n");
-
 	/* any filtering changes? */
 	if (vnicinfo->old_flags != netdev->flags) {
-		LOGINFNAME(vnicinfo->netdev,
-			   "old filter = 0x%04x, new filter = 0x%04x.\n",
-			   vnicinfo->old_flags, netdev->flags);
 		if ((netdev->flags & IFF_PROMISC) !=
 		    (vnicinfo->old_flags & IFF_PROMISC)) {
-			LOGINFNAME(vnicinfo->netdev,
-				   "we are %s promiscuous mode.\n",
-				   (netdev->
-				    flags & IFF_PROMISC) ? "entering" :
-				   "exiting");
 			cmdrsp = kmalloc(SIZEOF_CMDRSP, GFP_ATOMIC);
-			if (cmdrsp == NULL) {
-				LOGERRNAME(vnicinfo->netdev,
-					   "**** FAILED to kmalloc cmdrsp.\n");
-				return;
-			}
+			if (cmdrsp == NULL)
+					return;
+
 			memset(cmdrsp, 0, SIZEOF_CMDRSP);
 			cmdrsp->cmdtype = CMD_NET_TYPE;
 			cmdrsp->net.type = NET_RCV_PROMISC;
@@ -2155,15 +1774,12 @@ virtnic_set_multi(struct net_device *netdev)
 			     DONT_ISSUE_INTERRUPT, (uint64_t)NULL,
 			     0 /* don't wait */ , "vnic")) {
 				vnicinfo->datachan.chstat.sent_promisc++;
-			} else
-				LOGERRNAME(vnicinfo->netdev,
-					   "**** FAILED to insert NET_RCV_PROMISC.\n");
+			}
 			kfree(cmdrsp);
 		}
 
 		vnicinfo->old_flags = netdev->flags;
 	}
-	DBGINF("exiting virtnic_set_multi\n");
 }
 
 /*****************************************************/
@@ -2342,18 +1958,14 @@ static ssize_t enable_ints_write(struct file *file,
 		return -EINVAL;
 
 	buf[count] = '\0';
-	if (copy_from_user(buf, buffer, count)) {
-		LOGERR("copy_from_user failed.\n");
-		return -EFAULT;
-	}
+	if (copy_from_user(buf, buffer, count))
+			return -EFAULT;
+
 
 	i = kstrtoint(buf, 10 , &new_value);
 
-	if (i != 0) {
-		LOGERR("Failed to scan value for enable_ints, buf<<%.*s>>",
-		       (int)count, buf);
-		return -EFAULT;
-	}
+	if (i != 0)
+			return -EFAULT;
 
 	 /* set all counts to new_value usually 0 */
 	for (i = 0; i < VIRTNICSOPENMAX; i++) {
@@ -2394,19 +2006,13 @@ virtnic_mod_init(void)
 {
 	int error, i;
 
-	LOGINF("entering virtnic_mod_init");
 	/* ASSERT RCVPOST_BUF_SIZE < 4K */
-	if (RCVPOST_BUF_SIZE > PI_PAGE_SIZE) {
-		LOGERR("**** FAILED RCVPOST_BUF_SIZE:%d larger than a page\n",
-		       RCVPOST_BUF_SIZE);
-		return -1;
-	}
+	if (RCVPOST_BUF_SIZE > PI_PAGE_SIZE)
+			return -1;
+
 	/* ASSERT RCVPOST_BUF_SIZE is big enough to hold eth header */
-	if (RCVPOST_BUF_SIZE < ETH_HEADER_SIZE) {
-		LOGERR("**** FAILED RCVPOST_BUF_SIZE:%d is < ETH_HEADER_SIZE:%d\n",
-		       RCVPOST_BUF_SIZE, ETH_HEADER_SIZE);
-		return -1;
-	}
+	if (RCVPOST_BUF_SIZE < ETH_HEADER_SIZE)
+			return -1;
 
 	/* clear out array */
 	for (i = 0; i < VIRTNICSOPENMAX; i++) {
@@ -2416,18 +2022,15 @@ virtnic_mod_init(void)
 	/* create workqueue for serverdown completion */
 	virtnic_serverdown_workqueue =
 	    create_singlethread_workqueue("virtnic_serverdown");
-	if (virtnic_serverdown_workqueue == NULL) {
-		LOGERR("**** FAILED virtnic_serverdown_workqueue creation\n");
-		return -1;
-	}
+	if (virtnic_serverdown_workqueue == NULL)
+			return -1;
+
 	/* create workqueue for tx timeout reset  */
 	virtnic_timeout_reset_workqueue =
 	    create_singlethread_workqueue("virtnic_timeout_reset");
-	if (virtnic_timeout_reset_workqueue == NULL) {
-		LOGERR
-		    ("**** FAILED virtnic_timeout_reset_workqueue creation\n");
+	if (virtnic_timeout_reset_workqueue == NULL)
 		return -1;
-	}
+
 	virtnic_debugfs_dir = debugfs_create_dir("virtnic", NULL);
 	debugfs_create_file("info", S_IRUSR, virtnic_debugfs_dir,
 			    NULL, &debugfs_info_fops);
@@ -2437,18 +2040,15 @@ virtnic_mod_init(void)
 
 	error = virtpci_register_driver(&virtnic_driver);
 	if (error < 0) {
-		LOGERR("**** FAILED to register driver %x\n", error);
 		debugfs_remove_recursive(virtnic_debugfs_dir);
 		return -1;
 	}
-	LOGINF("exiting virtnic_mod_init");
 	return error;
 }
 
 static void __exit
 virtnic_mod_exit(void)
 {
-	LOGINF("entering virtnic_mod_exit...\n");
 	virtpci_unregister_driver(&virtnic_driver);
 	/* unregister is going to call virtnic_remove for all devices */
 	/* destroy serverdown completion workqueue */
@@ -2464,7 +2064,6 @@ virtnic_mod_exit(void)
 	}
 
 	debugfs_remove_recursive(virtnic_debugfs_dir);
-	LOGINF("exiting virtnic_mod_exit...\n");
 }
 
 module_init(virtnic_mod_init);
diff --git a/drivers/staging/unisys/visorbus/channel_attr.c b/drivers/staging/unisys/visorbus/channel_attr.c
index e924251..ee43852 100644
--- a/drivers/staging/unisys/visorbus/channel_attr.c
+++ b/drivers/staging/unisys/visorbus/channel_attr.c
@@ -40,7 +40,7 @@ struct channel_attribute {
 */
 static ssize_t DEVICECHANNEL_ATTR_physaddr(struct visor_device *dev, char *buf)
 {
-	if (dev->visorchannel == NULL)
+	if (!dev->visorchannel)
 		return 0;
 	return snprintf(buf, PAGE_SIZE, "0x%Lx\n",
 			visorchannel_get_physaddr(dev->visorchannel));
@@ -48,7 +48,7 @@ static ssize_t DEVICECHANNEL_ATTR_physaddr(struct visor_device *dev, char *buf)
 
 static ssize_t DEVICECHANNEL_ATTR_nbytes(struct visor_device *dev, char *buf)
 {
-	if (dev->visorchannel == NULL)
+	if (!dev->visorchannel)
 		return 0;
 	return snprintf(buf, PAGE_SIZE, "0x%lx\n",
 			visorchannel_get_nbytes(dev->visorchannel));
@@ -56,7 +56,7 @@ static ssize_t DEVICECHANNEL_ATTR_nbytes(struct visor_device *dev, char *buf)
 
 static ssize_t DEVICECHANNEL_ATTR_clientpartition(struct visor_device *dev,
 						  char *buf) {
-	if (dev->visorchannel == NULL)
+	if (!dev->visorchannel)
 		return 0;
 	return snprintf(buf, PAGE_SIZE, "0x%Lx\n",
 			visorchannel_get_clientpartition(dev->visorchannel));
@@ -66,7 +66,7 @@ static ssize_t DEVICECHANNEL_ATTR_typeguid(struct visor_device *dev, char *buf)
 {
 	char s[99];
 
-	if (dev->visorchannel == NULL)
+	if (!dev->visorchannel)
 		return 0;
 	return snprintf(buf, PAGE_SIZE, "%s\n",
 			visorchannel_id(dev->visorchannel, s));
@@ -76,7 +76,7 @@ static ssize_t DEVICECHANNEL_ATTR_zoneguid(struct visor_device *dev, char *buf)
 {
 	char s[99];
 
-	if (dev->visorchannel == NULL)
+	if (!dev->visorchannel)
 		return 0;
 	return snprintf(buf, PAGE_SIZE, "%s\n",
 			visorchannel_zoneid(dev->visorchannel, s));
@@ -89,7 +89,7 @@ static ssize_t DEVICECHANNEL_ATTR_typename(struct visor_device *dev, char *buf)
 	struct device_driver *xdrv = dev->device.driver;
 	struct visor_driver *drv = NULL;
 
-	if (dev->visorchannel == NULL || xbus == NULL || xdrv == NULL)
+	if (!dev->visorchannel || !xbus || !xdrv)
 		return 0;
 	i = xbus->match(&dev->device, xdrv);
 	if (!i)
@@ -186,7 +186,7 @@ int register_channel_attributes(struct visor_device *dev)
 
 	if (CHANNELATTR_DONTDOANYTHING)
 		goto away;
-	if (dev->kobjchannel.parent != NULL)
+	if (dev->kobjchannel.parent)
 		goto away;	/* already registered */
 	x = kobject_init_and_add(&dev->kobjchannel, &channel_kobj_type,
 				 &dev->device.kobj, "channel");
@@ -219,7 +219,7 @@ void unregister_channel_attributes(struct visor_device *dev)
 
 	if (CHANNELATTR_DONTDOANYTHING)
 		return;
-	if (dev->kobjchannel.parent == NULL)
+	if (!dev->kobjchannel.parent)
 		return;		/* already unregistered */
 	for (i = 0;
 	     i < sizeof(all_channel_attrs) / sizeof(struct channel_attribute);
diff --git a/drivers/staging/unisys/visorbus/devmajorminor_attr.c b/drivers/staging/unisys/visorbus/devmajorminor_attr.c
index cc503c3..bb8d2a2 100644
--- a/drivers/staging/unisys/visorbus/devmajorminor_attr.c
+++ b/drivers/staging/unisys/visorbus/devmajorminor_attr.c
@@ -90,14 +90,14 @@ devmajorminor_create_file(struct visor_device *dev, const char *name,
 		goto away;
 	register_devmajorminor_attributes(dev);
 	for (slot = 0; slot < maxdevnodes; slot++)
-		if (dev->devnodes[slot].attr == NULL)
+		if (!dev->devnodes[slot].attr)
 			break;
 	if (slot == maxdevnodes) {
 		rc = -ENOMEM;
 		goto away;
 	}
-	myattr = kmalloc(sizeof(*myattr), GFP_KERNEL|__GFP_NORETRY);
-	if (myattr == NULL) {
+	myattr = kmalloc(sizeof(*myattr), GFP_KERNEL | __GFP_NORETRY);
+	if (!myattr) {
 		rc = -ENOMEM;
 		goto away;
 	}
@@ -118,11 +118,9 @@ devmajorminor_create_file(struct visor_device *dev, const char *name,
 	kobject_uevent(&dev->device.kobj, KOBJ_ONLINE);
 away:
 	if (rc < 0) {
-		if (myattr != NULL) {
-			kfree(myattr);
-			myattr = NULL;
-			dev->devnodes[slot].attr = NULL;
-		}
+		kfree(myattr);
+		myattr = NULL;
+		dev->devnodes[slot].attr = NULL;
 	}
 	return rc;
 }
@@ -138,7 +136,7 @@ devmajorminor_remove_file(struct visor_device *dev, int slot)
 	if (slot < 0 || slot >= maxdevnodes)
 		return;
 	myattr = (struct devmajorminor_attribute *)(dev->devnodes[slot].attr);
-	if (myattr == NULL)
+	if (myattr)
 		return;
 	sysfs_remove_file(&dev->kobjdevmajorminor, &myattr->attr);
 	kobject_uevent(&dev->device.kobj, KOBJ_OFFLINE);
@@ -174,7 +172,7 @@ register_devmajorminor_attributes(struct visor_device *dev)
 
 	if (DEVMAJORMINOR_DONTDOANYTHING)
 		goto away;
-	if (dev->kobjdevmajorminor.parent != NULL)
+	if (dev->kobjdevmajorminor.parent)
 		goto away;	/* already registered */
 	x = kobject_init_and_add(&dev->kobjdevmajorminor,
 				 &devmajorminor_kobj_type, &dev->device.kobj,
@@ -195,7 +193,7 @@ unregister_devmajorminor_attributes(struct visor_device *dev)
 {
 	if (DEVMAJORMINOR_DONTDOANYTHING)
 		return;
-	if (dev->kobjdevmajorminor.parent == NULL)
+	if (!dev->kobjdevmajorminor.parent)
 		return;		/* already unregistered */
 	devmajorminor_remove_all_files(dev);
 
diff --git a/drivers/staging/unisys/visorbus/visorbus.h b/drivers/staging/unisys/visorbus/visorbus.h
index e370c77..a58a47f 100644
--- a/drivers/staging/unisys/visorbus/visorbus.h
+++ b/drivers/staging/unisys/visorbus/visorbus.h
@@ -174,38 +174,18 @@ void visorbus_disable_channel_interrupts(struct visor_device *dev);
 #endif
 
 /* Reference counting interfaces */
-#define VISORBUS_DEBUG_REFCOUNT_CHANGE(old, new, p, why)                \
-	INFODRV("refcount:%d-->%d %p <<%s>>", old, new, p, why)
-
-#define VISORBUS_DEBUG_REFCOUNT(count, p, why)                         \
-	INFODRV("refcount:%d %p <<%s>>", count, p, why)
-
 #define get_visordev(/*struct visor_device **/dev, /* char * */why, DBG) \
-do {							     \
+{							     \
 	int refcount;						     \
 	get_device(&dev->device);				     \
 	refcount = atomic_read(&dev->device.kobj.kref.refcount);     \
-	if (DBG)				     \
-		VISORBUS_DEBUG_REFCOUNT_CHANGE			     \
-			(refcount-1, refcount, &dev->device, why);   \
-} while (0)
+}
 
 #define put_visordev(/*struct visor_device **/dev, /* char * */why, DBG) \
-do {							     \
+{							     \
 	int refcount;						     \
 	put_device(&dev->device);				     \
 	refcount = atomic_read(&dev->device.kobj.kref.refcount);     \
-	if (DBG)				     \
-		VISORBUS_DEBUG_REFCOUNT_CHANGE			     \
-			(refcount+1, refcount, &dev->device, why);   \
-} while (0)
-
-#define refcount_debug(/*struct visor_device **/dev, /* char * */why) \
-do {							       \
-	if (visorbus_debugref)				       \
-		VISORBUS_DEBUG_REFCOUNT				       \
-			(atomic_read(&dev->device.kobj.kref.refcount), \
-			 &dev->device, why);                           \
-} while (0)
+}
 
 #endif
diff --git a/drivers/staging/unisys/visorbus/visorbus_main.c b/drivers/staging/unisys/visorbus/visorbus_main.c
index 0821a60..50ec178 100644
--- a/drivers/staging/unisys/visorbus/visorbus_main.c
+++ b/drivers/staging/unisys/visorbus/visorbus_main.c
@@ -157,11 +157,11 @@ visorbus_match(struct device *xdev, struct device_driver *xdrv)
 	if (visorbus_forcenomatch)
 		goto away;
 
-	if (drv->channel_types == NULL)
+	if (!drv->channel_types)
 		goto away;
 	for (i = 0;
 	     (uuid_le_cmp(drv->channel_types[i].guid, NULL_UUID_LE) != 0) ||
-	     (drv->channel_types[i].name == NULL);
+	     (drv->channel_types[i].name);
 	     i++)
 		if (uuid_le_cmp(drv->channel_types[i].guid,
 				channel_type) == 0) {
@@ -183,7 +183,6 @@ visorbus_release_busdevice(struct device *xdev)
 
 	dev_set_drvdata(xdev, NULL);
 	kfree(devdata);
-	INFODEV(dev_name(xdev), "bus device destroyed - freeing up memory now");
 	kfree(xdev);
 }
 
@@ -193,18 +192,13 @@ visorbus_release_busdevice(struct device *xdev)
 static void
 visorbus_release_device(struct device *xdev)
 {
-	char s[99];
 	struct visor_device *dev = to_visor_device(xdev);
 
-	INFODEV(dev_name(xdev),
-		"child device destroyed - freeing up memory now");
-	if (dev->periodic_work != NULL) {
+	if (dev->periodic_work) {
 		visor_periodic_work_destroy(dev->periodic_work);
 		dev->periodic_work = NULL;
 	}
-	if (dev->visorchannel != NULL) {
-		INFODRV("Channel %s disconnected",
-			visorchannel_id(dev->visorchannel, s));
+	if (dev->visorchannel) {
 		visorchannel_destroy(dev->visorchannel);
 		dev->visorchannel = NULL;
 	}
@@ -246,11 +240,9 @@ register_bustype_attributes(void)
 	int rc = 0;
 
 	rc = bus_create_file(&visorbus_type, &bustype_attr_version);
-	if (rc < 0) {
-		ERRDRV("bus_create_file(&Visorbus_type, &bustype_attr_version) failed: (status=%d)\n",
-		       rc);
-		goto away;
-	}
+	if (rc < 0)
+			goto away;
+
 	/* Here we make up for the fact that bus_type does not yet have a
 	 * member to keep track of multiple bus instances for a given bus
 	 * type.  This is useful for stashing properties for each bus
@@ -260,11 +252,9 @@ register_bustype_attributes(void)
 	businstances.kobj.ktype = &businst_kobj_type;
 	businstances.kobj.parent = &visorbus_type.p->subsys.kobj;
 	rc = kset_register(&businstances);
-	if (rc < 0) {
-		ERRDRV("kset_register(&businstances) failed: (status=%d)\n",
-		       rc);
-		goto away;
-	}
+	if (rc < 0)
+			goto away;
+
 	rc = 0;
 away:
 	return rc;
@@ -440,53 +430,36 @@ register_businst_attributes(struct visorbus_devdata *businst)
 	businst->kobj.kset = &businstances;	/* identify parent sysfs dir */
 	rc = kobject_init_and_add(&businst->kobj, &businst_kobj_type,
 				  NULL, "visorbus%d", businst->devno);
-	if (rc < 0) {
-		ERRDRV("kobject_init_and_add() failed: (status=%d)\n", rc);
-		goto away;
-	}
+	if (rc < 0)
+			goto away;
 
 	rc = businst_create_file(businst, &ba_partition_handle);
-	if (rc < 0) {
-		ERRDRV("businst_create_file(ba_partition_handle) failed: (status=%d)\n",
-		       rc);
-		goto away;
-	}
+	if (rc < 0)
+			goto away;
+
 	rc = businst_create_file(businst, &ba_partition_guid);
-	if (rc < 0) {
-		ERRDRV("businst_create_file(ba_partition_guid) failed: (status=%d)\n",
-		       rc);
-		goto away;
-	}
+	if (rc < 0)
+			goto away;
+
 	rc = businst_create_file(businst, &ba_partition_name);
-	if (rc < 0) {
-		ERRDRV("businst_create_file(ba_partition_name) failed: (status=%d)\n",
-		       rc);
-		goto away;
-	}
+	if (rc < 0)
+			goto away;
+
 	rc = businst_create_file(businst, &ba_channel_addr);
-	if (rc < 0) {
-		ERRDRV("businst_create_file(ba_channel_addr) failed: (status=%d)\n",
-		       rc);
-		goto away;
-	}
+	if (rc < 0)
+			goto away;
+
 	rc = businst_create_file(businst, &ba_nchannel_bytes);
-	if (rc < 0) {
-		ERRDRV("businst_create_file(ba_nchannel_bytes) failed: (status=%d)\n",
-		       rc);
-		goto away;
-	}
+	if (rc < 0)
+			goto away;
+
 	rc = businst_create_file(businst, &ba_channel_id);
-	if (rc < 0) {
-		ERRDRV("businst_create_file(ba_channel_id) failed: (status=%d)\n",
-		       rc);
-		goto away;
-	}
+	if (rc < 0)
+			goto away;
+
 	rc = businst_create_file(businst, &ba_client_bus_info);
-	if (rc < 0) {
-		ERRDRV("businst_create_file(ba_client_bus_info) failed: (status=%d)\n",
-		       rc);
-		goto away;
-	}
+	if (rc < 0)
+			goto away;
 
 	kobject_uevent(&businst->kobj, KOBJ_ADD);
 
@@ -531,13 +504,6 @@ register_driver_attributes(struct visor_driver *drv)
 	    __ATTR(version, S_IRUGO, DRIVER_ATTR_version, NULL);
 	drv->version_attr = version;
 	rc = driver_create_file(&drv->driver, &drv->version_attr);
-	if (rc < 0) {
-		ERRDRV("driver_create_file(&drv->driver, &drv->version_attr) failed: (status=%d)\n",
-		       rc);
-		goto away;
-	}
-	rc = 0;
-away:
 	return rc;
 }
 
@@ -622,27 +588,19 @@ visordriver_probe_device(struct device *xdev)
 	get_visordev(dev, "probe", visorbus_debugref);
 	if (!drv->probe) {
 		up(&dev->visordriver_callback_lock);
-		ERRDEV(dev_name(&dev->device),
-		       "driver did not specify probe func");
 		rc = -1;
 		goto away;
 	}
 	rc = drv->probe(dev);
-	if (rc < 0) {
-		ERRDRV("drv->probe(dev) failed: (status=%d)\n", rc);
+	if (rc < 0)
 		goto away;
-	}
+
 	fix_vbus_dev_info(dev);
 	up(&dev->visordriver_callback_lock);
 	rc = 0;
 away:
-	if (rc == 0) {
-		INFODEV(dev_name(&dev->device), "child device probed");
-		/* device ref count is now up by one (get_device) */
-	} else {
+	if (rc != 0)
 		put_visordev(dev, "probe", visorbus_debugref);
-		ERRDEV(dev_name(&dev->device), "child device probed failed");
-	}
 	/*  We could get here more than once if the child driver module is
 	 *  unloaded and re-loaded while devices are present.  That's why we
 	 *  need a flag to be sure that we only respond to the device_create
@@ -681,13 +639,9 @@ visordriver_remove_device(struct device *xdev)
 	 */
 	wmb();
 	if (drv) {
-		INFODEV(dev_name(&dev->device),
-			"detaching driver from child device");
 		if (drv->remove)
 			drv->remove(dev);
-	} else
-		INFODEV(dev_name(&dev->device),
-			"no need to detach driver from child device");
+	}
 	up(&dev->visordriver_callback_lock);
 	dev_stop_periodic_work(dev);
 	devmajorminor_remove_all_files(dev);
@@ -743,7 +697,6 @@ int visorbus_register_visor_driver(struct visor_driver *drv)
 {
 	int rc = 0;
 
-	INFODRV("child device driver %s loaded", drv->name);
 	drv->driver.name = drv->name;
 	drv->driver.bus = &visorbus_type;
 	drv->driver.probe = visordriver_probe_device;
@@ -763,22 +716,9 @@ int visorbus_register_visor_driver(struct visor_driver *drv)
 	 */
 
 	rc = driver_register(&drv->driver);
-	if (rc < 0) {
-		ERRDRV("driver_register(&drv->driver) failed: (status=%d)\n",
-		       rc);
-		goto away;
-	}
+	if (rc < 0)
+			return rc;
 	rc = register_driver_attributes(drv);
-	if (rc < 0) {
-		ERRDRV("register_driver_attributes(drv) failed: (status=%d)\n",
-		       rc);
-		goto away;
-	}
-
-away:
-
-	if (rc)
-		ERRDRV("visorbus_register_visor_driver failed");
 	return rc;
 }
 EXPORT_SYMBOL_GPL(visorbus_register_visor_driver);
@@ -789,7 +729,6 @@ EXPORT_SYMBOL_GPL(visorbus_register_visor_driver);
 void
 visorbus_unregister_visor_driver(struct visor_driver *drv)
 {
-	INFODRV("child device driver %s unloaded", drv->name);
 	unregister_driver_attributes(drv);
 	driver_unregister(&drv->driver);
 }
@@ -868,35 +807,20 @@ create_visor_device(struct visorbus_devdata *devdata,
 	struct visorchannel *visorchannel = NULL;
 	struct visor_device *dev = NULL;
 	BOOL gotten = FALSE, registered1 = FALSE, registered2 = FALSE;
-	char s[99];
 
 	POSTCODE_LINUX_4(DEVICE_CREATE_ENTRY_PC, chipset_dev_no, chipset_bus_no,
 			 POSTCODE_SEVERITY_INFO);
 	/* prepare chan_hdr (abstraction to read/write channel memory) */
-	INFODRV("Channel discovered (addr=0x%-16.16llx, size=%llu)",
-		(unsigned long long)chan_info.channel_addr,
-		(unsigned long long)chan_info.n_channel_bytes);
 	visorchannel = visorchannel_create(chan_info.channel_addr,
 					   (ulong)chan_info.n_channel_bytes,
 					   chan_info.channel_type_uuid);
-	if (visorchannel == NULL) {
-		ERRDRV("channel addr = 0x%-16.16llx, size = %llu",
-		       (unsigned long long)chan_info.channel_addr,
-		       (unsigned long long)chan_info.n_channel_bytes);
-
-		ERRDRV("visorchannel_create failed: (status = -1)\n");
+	if (!visorchannel) {
 		POSTCODE_LINUX_3(DEVICE_CREATE_FAILURE_PC, chipset_dev_no,
 				 DIAG_SEVERITY_ERR);
 		goto away;
 	}
-	INFODRV("Channel %s connected (addr=0x%-16.16llx, size=%llu)",
-		visorchannel_id(visorchannel, s),
-		(unsigned long long)chan_info.channel_addr,
-		(unsigned long long)chan_info.n_channel_bytes);
-
-	dev = kmalloc(sizeof(*dev), GFP_KERNEL|__GFP_NORETRY);
-	if (dev == NULL) {
-		ERRDRV("failed to allocate visor_device: (status = -1)\n");
+	dev = kmalloc(sizeof(*dev), GFP_KERNEL | __GFP_NORETRY);
+	if (!dev) {
 		POSTCODE_LINUX_3(DEVICE_CREATE_FAILURE_PC, chipset_dev_no,
 				 DIAG_SEVERITY_ERR);
 		goto away;
@@ -921,8 +845,7 @@ create_visor_device(struct visorbus_devdata *devdata,
 					   periodic_dev_workqueue,
 					   dev_periodic_work,
 					   dev, dev_name(&dev->device));
-	if (dev->periodic_work == NULL) {
-		ERRDRV("failed to create periodic_work: (status = -1)\n");
+	if (!dev->periodic_work) {
 		POSTCODE_LINUX_3(DEVICE_CREATE_FAILURE_PC, chipset_dev_no,
 				 DIAG_SEVERITY_ERR);
 		goto away;
@@ -953,43 +876,29 @@ create_visor_device(struct visorbus_devdata *devdata,
 	 */
 	rc = device_add(&dev->device);
 	if (rc < 0) {
-		ERRDRV("device_add(&dev->device) failed: (status = %d)\n", rc);
 		POSTCODE_LINUX_3(DEVICE_ADD_PC, chipset_bus_no,
 				 DIAG_SEVERITY_ERR);
 		goto away;
 	}
 
 	/* note: device_register is simply device_initialize + device_add */
-	refcount_debug(dev, "after device_add");
-
 	rc = register_channel_attributes(dev);
 	if (rc < 0) {
-		ERRDRV("register_channel_attributes(dev) failed: (status = %d)\n",
-		       rc);
 		POSTCODE_LINUX_3(DEVICE_REGISTER_FAILURE_PC, chipset_dev_no,
 				 DIAG_SEVERITY_ERR);
 		goto away;
 	}
 
-	refcount_debug(dev, "after register_channel_attributes");
 	registered1 = TRUE;
 
 	rc = register_devmajorminor_attributes(dev);
 	if (rc < 0) {
-		ERRDRV("register_devmajorminor_attributes(dev) failed: (status = %d)\n",
-		       rc);
 		POSTCODE_LINUX_3(DEVICE_REGISTER_FAILURE_PC, chipset_dev_no,
 				 DIAG_SEVERITY_ERR);
 		goto away;
 	}
 
-	refcount_debug(dev, "after register_devmajorminor_attributes");
 	registered2 = TRUE;
-
-	INFODEV(dev_name(&dev->device),
-		"child device 0x%p created", &dev->device);
-
-	refcount_debug(dev, "device creation complete");
 	rc = 0;
 
 away:
@@ -1000,11 +909,8 @@ away:
 			unregister_channel_attributes(dev);
 		if (gotten)
 			put_visordev(dev, "create", visorbus_debugref);
-		if (visorchannel != NULL) {
-			INFODRV("Channel %s disconnected",
-				visorchannel_id(visorchannel, s));
+		if (visorchannel)
 			visorchannel_destroy(visorchannel);
-		}
 		kfree(dev);
 	} else {
 		total_devices_created++;
@@ -1016,13 +922,10 @@ away:
 static void
 remove_visor_device(struct visor_device *dev)
 {
-	INFODRV("removing child device %s (0x%p)",
-		dev_name(&dev->device), &dev->device);
 	list_del(&dev->list_all);
 	unregister_devmajorminor_attributes(dev);
 	unregister_channel_attributes(dev);
 	put_visordev(dev, "create", visorbus_debugref);
-	refcount_debug(dev, "about to call device_unregister");
 	device_unregister(&dev->device);
 }
 
@@ -1031,9 +934,6 @@ find_visor_device_by_channel(HOSTADDRESS channel_physaddr)
 {
 	struct list_head *listentry, *listtmp;
 
-	INFODRV("looking for dev with channel addr=0x%Lx",
-		(unsigned long long)(channel_physaddr));
-
 	list_for_each_safe(listentry, listtmp, &list_all_device_instances) {
 		struct visor_device *dev = list_entry(listentry,
 						      struct visor_device,
@@ -1042,8 +942,6 @@ find_visor_device_by_channel(HOSTADDRESS channel_physaddr)
 		    channel_physaddr)
 			return dev;
 	}
-	ERRDRV("dev with channel addr=0x%Lx not found",
-	       (unsigned long long)(channel_physaddr));
 	return NULL;
 }
 
@@ -1054,30 +952,26 @@ init_vbus_channel(struct visorchannel *chan)
 	ulong allocated_bytes = visorchannel_get_nbytes(chan);
 	struct spar_vbus_channel_protocol *x =
 		kmalloc(sizeof(struct spar_vbus_channel_protocol),
-			GFP_KERNEL|__GFP_NORETRY);
+			GFP_KERNEL | __GFP_NORETRY);
 
 	POSTCODE_LINUX_3(VBUS_CHANNEL_ENTRY_PC, rc, POSTCODE_SEVERITY_INFO);
 
-	if (x == NULL) {
-		ERRDRV("%s failed malloc", __func__);
+	if (x) {
 		POSTCODE_LINUX_2(MALLOC_FAILURE_PC, POSTCODE_SEVERITY_ERR);
 		goto away;
 	}
 	if (visorchannel_clear(chan, 0, 0, allocated_bytes) < 0) {
-		ERRDRV("%s clear failed", __func__);
 		POSTCODE_LINUX_2(VBUS_CHANNEL_FAILURE_PC,
 				 POSTCODE_SEVERITY_ERR);
 		goto away;
 	}
 	if (visorchannel_read
 	    (chan, 0, x, sizeof(struct spar_vbus_channel_protocol)) < 0) {
-		ERRDRV("%s chan read failed", __func__);
 		POSTCODE_LINUX_2(VBUS_CHANNEL_FAILURE_PC,
 				 POSTCODE_SEVERITY_ERR);
 		goto away;
 	}
 	if (!SPAR_VBUS_CHANNEL_OK_SERVER(allocated_bytes)) {
-		ERRDRV("%s channel cannot be used", __func__);
 		POSTCODE_LINUX_2(VBUS_CHANNEL_FAILURE_PC,
 				 POSTCODE_SEVERITY_ERR);
 		goto away;
@@ -1085,7 +979,6 @@ init_vbus_channel(struct visorchannel *chan)
 
 	if (visorchannel_write
 	    (chan, 0, x, sizeof(struct spar_vbus_channel_protocol)) < 0) {
-		ERRDRV("%s chan write failed", __func__);
 		POSTCODE_LINUX_3(VBUS_CHANNEL_FAILURE_PC, chan,
 				 POSTCODE_SEVERITY_ERR);
 		goto away;
@@ -1095,10 +988,8 @@ init_vbus_channel(struct visorchannel *chan)
 	rc = 0;
 
 away:
-	if (x != NULL) {
-		kfree(x);
-		x = NULL;
-	}
+	kfree(x);
+	x = NULL;
 	return rc;
 }
 
@@ -1108,27 +999,16 @@ get_vbus_header_info(struct visorchannel *chan,
 {
 	int rc = -1;
 
-	if (!SPAR_VBUS_CHANNEL_OK_CLIENT(visorchannel_get_header(chan))) {
-		ERRDRV("vbus channel cannot be used - visorchannel_get_header failed");
+	if (!SPAR_VBUS_CHANNEL_OK_CLIENT(visorchannel_get_header(chan)))
 		goto away;
-	}
-	if (visorchannel_read
-	    (chan, sizeof(struct channel_header), hdr_info,
-	     sizeof(*hdr_info)) < 0) {
-		ERRDRV("%s chan read failed", __func__);
+	if (visorchannel_read(chan, sizeof(struct channel_header), hdr_info,
+			      sizeof(*hdr_info)) < 0) {
 		goto away;
 	}
-	if (hdr_info->struct_bytes < sizeof(struct spar_vbus_headerinfo)) {
-		ERRDRV("vbus channel not used, because header too small (%d < %lu)",
-		       hdr_info->struct_bytes,
-		       sizeof(struct spar_vbus_headerinfo));
+	if (hdr_info->struct_bytes < sizeof(struct spar_vbus_headerinfo))
 		goto away;
-	}
 	if (hdr_info->device_info_struct_bytes <
 	    sizeof(struct ultra_vbus_deviceinfo)) {
-		ERRDRV("vbus channel not used, because devinfo too small (%d < %lu)",
-		       hdr_info->device_info_struct_bytes,
-		       sizeof(struct ultra_vbus_deviceinfo));
 		goto away;
 	}
 	rc = 0;
@@ -1145,20 +1025,13 @@ write_vbus_chp_info(struct visorchannel *chan,
 		    struct ultra_vbus_deviceinfo *info)
 {
 	int off = sizeof(struct channel_header) + hdr_info->chp_info_offset;
-	int rc = -1;
 
-	if (hdr_info->chp_info_offset == 0) {
-		ERRDRV("vbus channel not used, because chp_info_offset == 0");
-		goto away;
-	}
-	if (visorchannel_write(chan, off, info, sizeof(*info)) < 0) {
-		ERRDRV("%s chan write of chpInfo to offset=%d", __func__,
-		       off);
-		goto away;
-	}
-	rc = 0;
-away:
-	return rc;
+	if (hdr_info->chp_info_offset == 0)
+			return -1;
+
+	if (visorchannel_write(chan, off, info, sizeof(*info)) < 0)
+			return -1;
+	return 0;
 }
 
 /* Write the contents of <info> to the struct
@@ -1170,20 +1043,13 @@ write_vbus_bus_info(struct visorchannel *chan,
 		    struct ultra_vbus_deviceinfo *info)
 {
 	int off = sizeof(struct channel_header) + hdr_info->bus_info_offset;
-	int rc = -1;
 
-	if (hdr_info->bus_info_offset == 0) {
-		ERRDRV("vbus channel not used, because bus_info_offset == 0");
-		goto away;
-	}
-	if (visorchannel_write(chan, off, info, sizeof(*info)) < 0) {
-		ERRDRV("%s chan write of busInfo to offset=%d", __func__,
-		       off);
-		goto away;
-	}
-	rc = 0;
-away:
-	return rc;
+	if (hdr_info->bus_info_offset == 0)
+			return -1;
+
+	if (visorchannel_write(chan, off, info, sizeof(*info)) < 0)
+			return -1;
+	return 0;
 }
 
 /* Write the contents of <info> to the
@@ -1197,20 +1063,13 @@ write_vbus_dev_info(struct visorchannel *chan,
 	int off =
 	    (sizeof(struct channel_header) + hdr_info->dev_info_offset) +
 	    (hdr_info->device_info_struct_bytes * devix);
-	int rc = -1;
 
-	if (hdr_info->dev_info_offset == 0) {
-		ERRDRV("vbus channel not used, because dev_info_offset == 0");
-		goto away;
-	}
-	if (visorchannel_write(chan, off, info, sizeof(*info)) < 0) {
-		ERRDRV("%s chan write of dev_info to offset=%d", __func__,
-		       off);
-		goto away;
-	}
-	rc = 0;
-away:
-	return rc;
+	if (hdr_info->dev_info_offset == 0)
+			return -1;
+
+	if (visorchannel_write(chan, off, info, sizeof(*info)) < 0)
+			return -1;
+	return 0;
 }
 
 /* For a child device just created on a client bus, fill in
@@ -1230,34 +1089,26 @@ fix_vbus_dev_info(struct visor_device *visordev)
 	struct ultra_vbus_deviceinfo dev_info;
 	const char *chan_type_name = NULL;
 
-	if (visordev->device.driver == NULL) {
-		ERRDRV("%s no device driver for bus_no=%d dev_no=%d",
-		       __func__, bus_no, dev_no);
-		goto away;
-	}
+	if (!visordev->device.driver)
+			return;
+
 	visordrv = to_visor_driver(visordev->device.driver);
-	if (!visorchipset_get_bus_info(bus_no, &bus_info)) {
-		ERRDRV("%s visorchipset_get_bus_info for bus_no=%d failed",
-		       __func__, bus_no);
-		goto away;
-	}
+	if (!visorchipset_get_bus_info(bus_no, &bus_info))
+			return;
+
 	devdata = (struct visorbus_devdata *)(bus_info.bus_driver_context);
-	if (!devdata) {
-		ERRDRV("%s bus_info.bus_driver_context is NULL for bus_no=%d",
-		       __func__, bus_no);
-		goto away;
-	}
-	if (!devdata->vbus_valid) {
-		/* this error would have been blabbered earlier */
-		goto away;
-	}
+	if (!devdata)
+			return;
+
+	if (!devdata->vbus_valid)
+			return;
 
 	/* Within the list of device types (by GUID) that the driver
 	 * says it supports, find out which one of those types matches
 	 * the type of this device, so that we can include the device
 	 * type name
 	 */
-	for (i = 0; visordrv->channel_types[i].name != NULL; i++) {
+	for (i = 0; visordrv->channel_types[i].name; i++) {
 		if (STRUCTSEQUAL(visordrv->channel_types[i].guid,
 				 visordev->channel_type_guid)) {
 			chan_type_name = visordrv->channel_types[i].name;
@@ -1278,9 +1129,6 @@ fix_vbus_dev_info(struct visor_device *visordev)
 			    &chipset_driverinfo);
 	write_vbus_bus_info(devdata->chan, &devdata->vbus_hdr_info,
 			    &clientbus_driverinfo);
-
-away:
-	return;
 }
 
 /** Create a device instance for the visor bus itself.
@@ -1292,12 +1140,10 @@ create_bus_instance(int id)
 	struct visorbus_devdata *devdata = NULL;
 	struct device *dev;
 	struct visorchipset_bus_info bus_info;
-	char s[99];
 
 	POSTCODE_LINUX_2(BUS_CREATE_ENTRY_PC, POSTCODE_SEVERITY_INFO);
-	dev = kmalloc(sizeof(*dev), GFP_KERNEL|__GFP_NORETRY);
-	if (dev == NULL) {
-		ERRDRV("allocation of device for bus #%d failed", id);
+	dev = kmalloc(sizeof(*dev), GFP_KERNEL | __GFP_NORETRY);
+	if (!dev) {
 		POSTCODE_LINUX_2(MALLOC_FAILURE_PC, POSTCODE_SEVERITY_ERR);
 		rc = NULL;
 		goto away;
@@ -1306,17 +1152,13 @@ create_bus_instance(int id)
 	dev_set_name(dev, "visorbus%d", id);
 	dev->release = visorbus_release_busdevice;
 	if (device_register(dev) < 0) {
-		ERRDRV("device_register for bus #%d failed", id);
 		POSTCODE_LINUX_3(DEVICE_CREATE_FAILURE_PC, id,
 				 POSTCODE_SEVERITY_ERR);
 		rc = NULL;
 		goto away;
 	}
-	INFODEV(dev_name(dev), "bus device created");
-
-	devdata = kmalloc(sizeof(*devdata), GFP_KERNEL|__GFP_NORETRY);
-	if (devdata == NULL) {
-		ERRDEV(dev_name(dev), "allocation of visorbus_devdata failed");
+	devdata = kmalloc(sizeof(*devdata), GFP_KERNEL | __GFP_NORETRY);
+	if (!devdata) {
 		POSTCODE_LINUX_2(MALLOC_FAILURE_PC, POSTCODE_SEVERITY_ERR);
 		rc = NULL;
 		goto away;
@@ -1336,25 +1178,13 @@ create_bus_instance(int id)
 		devdata->chan = visorchannel_create(channel_addr,
 						    n_channel_bytes,
 						    channel_type_guid);
-		if (devdata->chan == NULL) {
-			ERRDRV("bus channel addr = 0x%-16.16llx, size = %llu",
-			       (unsigned long long)channel_addr,
-			       (unsigned long long)n_channel_bytes);
-			ERRDRV("visorchannel_create failed");
+		if (!devdata->chan) {
 			POSTCODE_LINUX_3(DEVICE_CREATE_FAILURE_PC, channel_addr,
 					 POSTCODE_SEVERITY_ERR);
 		} else {
 			if (bus_info.flags.server) {
-				INFODRV("Bus channel %s connected (server, addr=0x%-16.16llx, size=%llu)",
-					visorchannel_id(devdata->chan, s),
-					(unsigned long long)channel_addr,
-					(unsigned long long)n_channel_bytes);
 				init_vbus_channel(devdata->chan);
 			} else {
-				INFODRV("Bus channel %s connected (client, addr=0x%-16.16llx, size=%llu)",
-					visorchannel_id(devdata->chan, s),
-					(unsigned long long)channel_addr,
-					(unsigned long long)n_channel_bytes);
 				if (get_vbus_header_info(devdata->chan,
 							 &devdata->
 							 vbus_hdr_info) >= 0) {
@@ -1365,7 +1195,7 @@ create_bus_instance(int id)
 							    &chipset_driverinfo
 							    );
 					write_vbus_bus_info(devdata->chan,
-							&devdata->
+							    &devdata->
 								vbus_hdr_info,
 							&clientbus_driverinfo);
 				}
@@ -1395,7 +1225,6 @@ remove_bus_instance(struct visorbus_devdata *devdata)
 	 * successfully been able to trace thru the code to see where/how
 	 * release() gets called.  But I know it does.
 	 */
-	INFODRV("removing bus instance");
 	unregister_businst_attributes(devdata);
 	bus_count--;
 	if (devdata->chan) {
@@ -1416,20 +1245,10 @@ create_bus_type(void)
 
 	visorbus_type.dev_attrs = visor_device_attrs;
 	rc = bus_register(&visorbus_type);
-	if (rc < 0) {
-		ERRDRV("bus_register(&visorbus_type) failed: (status=%d)\n",
-		       rc);
-		goto away;
-	}
+	if (rc < 0)
+			return rc;
+
 	rc = register_bustype_attributes();
-	if (rc < 0) {
-		ERRDRV("register_bustype_attributes() failed: (status=%d)\n",
-		       rc);
-		goto away;
-	}
-	INFODRV("bus type registered %s", VERSION);
-	rc = 0;
-away:
 	return rc;
 }
 
@@ -1440,7 +1259,6 @@ remove_bus_type(void)
 {
 	unregister_bustype_attributes();
 	bus_unregister(&visorbus_type);
-	INFODRV("bus type unregistered %s", VERSION);
 }
 
 /** Remove all child visor bus device instances.
@@ -1450,8 +1268,6 @@ remove_all_visor_devices(void)
 {
 	struct list_head *listentry, *listtmp;
 
-	INFODRV("removing all child devices:");
-
 	list_for_each_safe(listentry, listtmp, &list_all_device_instances) {
 		struct visor_device *dev = list_entry(listentry,
 						      struct visor_device,
@@ -1484,12 +1300,10 @@ chipset_bus_create(ulong bus_no)
 	rc = 0;
 away:
 	if (rc < 0) {
-		ERRDRV("%s(%lu) failed", __func__, bus_no);
 		POSTCODE_LINUX_3(BUS_CREATE_FAILURE_PC, bus_no,
 				 POSTCODE_SEVERITY_ERR);
 		return;
 	}
-	INFODRV("%s(%lu) successful", __func__, bus_no);
 	POSTCODE_LINUX_3(CHIPSET_INIT_SUCCESS_PC, bus_no,
 			 POSTCODE_SEVERITY_INFO);
 	if (chipset_responders.bus_create)
@@ -1513,13 +1327,10 @@ chipset_bus_destroy(ulong bus_no)
 		goto away;
 	rc = 0;
 away:
-	if (rc < 0) {
-		ERRDRV("%s(%lu) failed", __func__, bus_no);
+	if (rc < 0)
 		return;
-	}
-	INFODRV("%s(%lu) successful", __func__, bus_no);
 	if (chipset_responders.bus_destroy)
-		(*chipset_responders.bus_destroy) (bus_no, rc);
+		(*chipset_responders.bus_destroy)(bus_no, rc);
 }
 
 static void
@@ -1551,12 +1362,10 @@ chipset_device_create(ulong bus_no, ulong dev_no)
 	rc = 0;
 away:
 	if (rc < 0) {
-		ERRDRV("%s(%lu,%lu) failed", __func__, bus_no, dev_no);
 		POSTCODE_LINUX_4(DEVICE_CREATE_FAILURE_PC, dev_no, bus_no,
 				 POSTCODE_SEVERITY_ERR);
 		return;
 	}
-	INFODRV("%s(%lu,%lu) successful", __func__, bus_no, dev_no);
 	devdata = (struct visorbus_devdata *)(bus_info.bus_driver_context);
 	rc = create_visor_device(devdata, bus_no, dev_no,
 				 dev_info.chan_info, bus_info.partition_handle);
@@ -1583,11 +1392,9 @@ chipset_device_destroy(ulong bus_no, ulong dev_no)
 		goto away;
 	rc = 0;
 away:
-	if (rc < 0) {
-		ERRDRV("%s(%lu,%lu) failed", __func__, bus_no, dev_no);
-		return;
-	}
-	INFODRV("%s(%lu,%lu) successful", __func__, bus_no, dev_no);
+	if (rc < 0)
+			return;
+
 	if (chipset_responders.device_destroy)
 		(*chipset_responders.device_destroy) (bus_no, dev_no, rc);
 	remove_visor_device(dev);
@@ -1600,19 +1407,13 @@ away:
 static void
 pause_state_change_complete(struct visor_device *dev, int status)
 {
-	if (!dev->pausing) {
-		ERRDEV(dev_name(&dev->device),
-		       "%s, but not pausing! (rc=%d)", __func__, status);
-		return;
-	}
-	INFODEV(dev_name(&dev->device),
-		"transition running-->paused rc=%d", status);
+	if (!dev->pausing)
+			return;
+
 	dev->pausing = FALSE;
-	if (!chipset_responders.device_pause) {
-		/* this can never happen! */
-		HUHDEV(dev_name(&dev->device), "no pause complete function");
-		return;
-	}
+	if (!chipset_responders.device_pause) /* this can never happen! */
+			return;
+
 	/* Notify the chipset driver that the pause is complete, which
 	* will presumably want to send some sort of response to the
 	* initiator. */
@@ -1627,19 +1428,13 @@ pause_state_change_complete(struct visor_device *dev, int status)
 static void
 resume_state_change_complete(struct visor_device *dev, int status)
 {
-	if (!dev->resuming) {
-		ERRDEV(dev_name(&dev->device),
-		       "%s, but not resuming! (rc=%d)", __func__, status);
-		return;
-	}
-	INFODEV(dev_name(&dev->device),
-		"transition paused-->running rc=%d", status);
+	if (!dev->resuming)
+			return;
+
 	dev->resuming = FALSE;
-	if (!chipset_responders.device_resume) {
-		/* this can never happen! */
-		HUHDEV(dev_name(&dev->device), "no resume complete function");
-		return;
-	}
+	if (!chipset_responders.device_resume) /* this can never happen! */
+			return;
+
 	/* Notify the chipset driver that the resume is complete,
 	 * which will presumably want to send some sort of response to
 	 * the initiator. */
@@ -1664,28 +1459,23 @@ initiate_chipset_device_pause_resume(ulong bus_no, ulong dev_no, BOOL is_pause)
 		notify_func = chipset_responders.device_pause;
 	else
 		notify_func = chipset_responders.device_resume;
-	if (!notify_func) {
-		HUHDRV("no chipset_responders notify function (this is WAY serious)");
-		goto away;
-	}
-	if (!visorchipset_get_device_info(bus_no, dev_no, &dev_info)) {
-		ERRDRV("visorchipset_get_device_info_failed");
-		goto away;
-	}
+	if (!notify_func)
+			goto away;
+
+	if (!visorchipset_get_device_info(bus_no, dev_no, &dev_info))
+			goto away;
+
 	dev = find_visor_device_by_channel(dev_info.chan_info.channel_addr);
-	if (!dev) {
-		ERRDRV("device not found");
-		goto away;
-	}
+	if (!dev)
+			goto away;
+
 	drv = to_visor_driver(dev->device.driver);
-	if (!drv) {
-		ERRDEV(dev_name(&dev->device), "driver not found");
-		goto away;
-	}
-	if (dev->pausing || dev->resuming) {
-		ERRDEV(dev_name(&dev->device), "already pausing or resuming");
-		goto away;
-	}
+	if (!drv)
+			goto away;
+
+	if (dev->pausing || dev->resuming)
+			goto away;
+
 	/* Note that even though both drv->pause() and drv->resume
 	 * specify a callback function, it is NOT necessary for us to
 	 * increment our local module usage count.  Reason is, there
@@ -1694,11 +1484,9 @@ initiate_chipset_device_pause_resume(ulong bus_no, ulong dev_no, BOOL is_pause)
 	 * visorbus while child function drivers are still running.
 	 */
 	if (is_pause) {
-		if (!drv->pause) {
-			ERRDEV(dev_name(&dev->device),
-			       "visorbus cannot pause device, because function driver does not support pause");
-			goto away;
-		}
+		if (!drv->pause)
+				goto away;
+
 		dev->pausing = TRUE;
 		x = drv->pause(dev, pause_state_change_complete);
 	} else {
@@ -1708,11 +1496,9 @@ initiate_chipset_device_pause_resume(ulong bus_no, ulong dev_no, BOOL is_pause)
 		 * ever have a bus that contains NO devices, since we
 		 * would never even get here in that case. */
 		fix_vbus_dev_info(dev);
-		if (!drv->resume) {
-			ERRDEV(dev_name(&dev->device),
-			       "visorbus cannot resume device, because function driver does not support resume");
-			goto away;
-		}
+		if (!drv->resume)
+				goto away;
+
 		dev->resuming = TRUE;
 		x = drv->resume(dev, resume_state_change_complete);
 	}
@@ -1721,22 +1507,13 @@ initiate_chipset_device_pause_resume(ulong bus_no, ulong dev_no, BOOL is_pause)
 			dev->pausing = FALSE;
 		else
 			dev->resuming = FALSE;
-		ERRDEV(dev_name(&dev->device),
-		       "function driver pause/resume failed with rc=%d", x);
 		goto away;
 	}
 	rc = 0;
 away:
 	if (rc < 0) {
-		if (dev)
-			ERRDEV(dev_name(&dev->device), "%s state change failed",
-			       (is_pause) ? "pause" : "resume");
-		else
-			ERRDRV("%s(%s,%lu,%lu) failed",
-			       __func__, (is_pause) ? "pause" : "resume",
-			       bus_no, dev_no);
 		if (notify_func)
-			(*notify_func) (bus_no, dev_no, rc);
+				(*notify_func)(bus_no, dev_no, rc);
 	}
 }
 
@@ -1765,11 +1542,11 @@ find_channel_size(struct device_driver *xdrv, void *xinfo)
 	int i = 0;
 	struct visor_driver *drv = to_visor_driver(xdrv);
 
-	if (drv->channel_types == NULL)
+	if (!drv->channel_types)
 		return 0;
 	for (i = 0;
 	     (uuid_le_cmp(drv->channel_types[i].guid, NULL_UUID_LE) != 0) ||
-	     (drv->channel_types[i].name == NULL); i++)
+	     (!drv->channel_types[i].name); i++)
 		if (uuid_le_cmp(drv->channel_types[i].guid, info->guid) == 0) {
 			info->min_size = drv->channel_types[i].min_size;
 			info->max_size = drv->channel_types[i].max_size;
@@ -1804,20 +1581,16 @@ periodic_test_work(struct work_struct *work)
 	static BOOL create_phase = FALSE;
 	static u64 last_interval;
 
-	/* INFODRV("periodic work"); */
 	current_interval = get_jiffies_64() / 8192;
 	/* 32.5 seconds at HZ=250 */
 	if (visorbus_devicetest && (current_interval > last_interval)) {
 		last_interval = current_interval;
-		INFODRV("devicetest interval #%llu",
-			(unsigned long long)current_interval);
 		if ((visorbus_devicetest > 0) &&
 		    (total_devices_created >= visorbus_devicetest)) {
 			int i;
 
 			entered_testing_mode = TRUE;
 			if (create_phase) {
-				INFODRV("Adding devices for devicetest...");
 				for (i = 0; i < visorbus_devicetest; i++) {
 					create_visor_device
 					    (devdata,
@@ -1827,11 +1600,10 @@ periodic_test_work(struct work_struct *work)
 				}
 				create_phase = FALSE;
 			} else {
-				INFODRV("Removing devices for devicetest...");
 				for (i = 0; i < visorbus_devicetest; i++) {
 					dev = find_visor_device_by_channel
 					   (test_channel_infos[i].channel_addr);
-					if (dev != NULL)
+					if (dev)
 						remove_visor_device(dev);
 				}
 				create_phase = TRUE;
@@ -1847,9 +1619,8 @@ periodic_test_work(struct work_struct *work)
 		create_visor_device(devdata, 0, 0, chan_info, 0);
 	}
 
-	if (queue_delayed_work(periodic_test_workqueue,
-			       &periodic_work, POLLJIFFIES_TESTWORK) < 0)
-		ERRDRV("queue_delayed_work failed!");
+	queue_delayed_work(periodic_test_workqueue,
+			   &periodic_work, POLLJIFFIES_TESTWORK);
 }
 
 static int __init
@@ -1858,30 +1629,17 @@ visorbus_init(void)
 	int rc = 0;
 
 	POSTCODE_LINUX_3(DRIVER_ENTRY_PC, rc, POSTCODE_SEVERITY_INFO);
-	INFODRV("bus driver version %s loaded", VERSION);
-
 	bus_device_info_init(&clientbus_driverinfo,
 			     "clientbus", MYDRVNAME,
 			     VERSION, NULL);
 
 	/* process module options */
 
-	INFODRV("option - debug=%d", visorbus_debug);
-	INFODRV("option - forcematch=%d", visorbus_forcematch);
-	INFODRV("option - forcenomatch=%d", visorbus_forcenomatch);
-	INFODRV("option - devicetest=%d", visorbus_devicetest);
-	if (visorbus_devicetest > MAXDEVICETEST) {
-		visorbus_devicetest = MAXDEVICETEST;
-		INFODRV("option - devicetest=%d (reduced to maximum)",
-			visorbus_devicetest);
-	}
-	INFODRV("option - debugref=%d", visorbus_debugref);
-	INFODRV("option - serialloopbacktest=%d",
-		visorbus_serialloopbacktest);
+	if (visorbus_devicetest > MAXDEVICETEST)
+			visorbus_devicetest = MAXDEVICETEST;
 
 	rc = create_bus_type();
 	if (rc < 0) {
-		ERRDRV("create_bus_type(): error (status=%d)\n", rc);
 		POSTCODE_LINUX_2(BUS_CREATE_ENTRY_PC, DIAG_SEVERITY_ERR);
 		goto away;
 	}
@@ -1890,9 +1648,7 @@ visorbus_init(void)
 		INIT_DELAYED_WORK(&periodic_work, periodic_test_work);
 		periodic_test_workqueue =
 		    create_singlethread_workqueue("visorbus_test");
-		if (periodic_test_workqueue == NULL) {
-			ERRDRV("cannot create test workqueue: error (status=%d)\n",
-			       -ENOMEM);
+		if (!periodic_test_workqueue) {
 			POSTCODE_LINUX_2(BUS_CREATE_ENTRY_PC,
 					 DIAG_SEVERITY_ERR);
 			rc = -ENOMEM;
@@ -1903,8 +1659,6 @@ visorbus_init(void)
 					&periodic_work,
 					POLLJIFFIES_TESTWORK);
 		if (rc < 0) {
-			ERRDRV("queue_delayed_work(periodic_test_workqueue, &periodic_work, POLLJIFFIES_TESTWORK): error (status=%d)\n",
-			       rc);
 			POSTCODE_LINUX_2(QUEUE_DELAYED_WORK_PC,
 					 DIAG_SEVERITY_ERR);
 			goto away;
@@ -1912,9 +1666,7 @@ visorbus_init(void)
 	}
 
 	periodic_dev_workqueue = create_singlethread_workqueue("visorbus_dev");
-	if (periodic_dev_workqueue == NULL) {
-		ERRDRV("cannot create dev workqueue: error (status=%d)\n",
-		       -ENOMEM);
+	if (!periodic_dev_workqueue) {
 		POSTCODE_LINUX_2(CREATE_WORKQUEUE_PC, DIAG_SEVERITY_ERR);
 		rc = -ENOMEM;
 		goto away;
@@ -1930,11 +1682,9 @@ visorbus_init(void)
 	rc = 0;
 
 away:
-	if (rc) {
-		ERRDRV("visorbus_init failed");
-		POSTCODE_LINUX_3(CHIPSET_INIT_FAILURE_PC, rc,
-				 POSTCODE_SEVERITY_ERR);
-	}
+	if (rc)
+			POSTCODE_LINUX_3(CHIPSET_INIT_FAILURE_PC, rc,
+					 POSTCODE_SEVERITY_ERR);
 	return rc;
 }
 
@@ -1965,7 +1715,6 @@ visorbus_exit(void)
 		remove_bus_instance(devdata);
 	}
 	remove_bus_type();
-	INFODRV("bus driver unloaded");
 }
 
 module_param_named(debug, visorbus_debug, int, S_IRUGO);
diff --git a/drivers/staging/unisys/visorbus/visorbus_private.h b/drivers/staging/unisys/visorbus/visorbus_private.h
index 2415b8a..f606022 100644
--- a/drivers/staging/unisys/visorbus/visorbus_private.h
+++ b/drivers/staging/unisys/visorbus/visorbus_private.h
@@ -18,7 +18,6 @@
 #ifndef __VISORBUS_PRIVATE_H__
 #define __VISORBUS_PRIVATE_H__
 
-#include "uniklog.h"
 #include "timskmod.h"
 #include "visorbus.h"
 #include "visorchipset.h"
@@ -36,7 +35,7 @@ extern int visorbus_forcenomatch;
 extern int visorbus_devicetest;
 extern int visorbus_debugref;
 extern int visorbus_serialloopbacktest;
-#define SERIALLOOPBACKCHANADDR (100*1024*1024)
+#define SERIALLOOPBACKCHANADDR (100 * 1024 * 1024)
 
 /** This is the private data that we store for each bus device instance.
  */
diff --git a/drivers/staging/unisys/visorchannel/visorchannel_funcs.c b/drivers/staging/unisys/visorchannel/visorchannel_funcs.c
index de0a646..34b6010 100644
--- a/drivers/staging/unisys/visorchannel/visorchannel_funcs.c
+++ b/drivers/staging/unisys/visorchannel/visorchannel_funcs.c
@@ -405,19 +405,22 @@ signalremove_inner(struct visorchannel *channel, u32 queue, void *msg)
 		return FALSE;	/* no signals to remove */
 
 	sig_hdr.tail = (sig_hdr.tail + 1) % sig_hdr.max_slots;
-	if (!sig_read_data(channel, queue, &sig_hdr, sig_hdr.tail, msg)) {
+	if (!sig_read_data(channel, queue, &sig_hdr, sig_hdr.tail, msg))
 		return FALSE;
-	}
+
 	sig_hdr.num_received++;
 
 	/* For each data field in SIGNAL_QUEUE_HEADER that was modified,
 	 * update host memory.
 	 */
 	mb(); /* required for channel synch */
+
 	if (!SIG_WRITE_FIELD(channel, queue, &sig_hdr, tail))
 		return FALSE;
+
 	if (!SIG_WRITE_FIELD(channel, queue, &sig_hdr, num_received))
 		return FALSE;
+
 	return TRUE;
 }
 
@@ -449,18 +452,12 @@ signalinsert_inner(struct visorchannel *channel, u32 queue, void *msg)
 	sig_hdr.head = ((sig_hdr.head + 1) % sig_hdr.max_slots);
 	if (sig_hdr.head == sig_hdr.tail) {
 		sig_hdr.num_overflows++;
-		visor_memregion_write(channel->memregion,
-				      SIG_QUEUE_OFFSET(&channel->chan_hdr,
-						       queue) +
-				      offsetof(struct signal_queue_header,
-					       num_overflows),
-				      &(sig_hdr.num_overflows),
-				      sizeof(sig_hdr.num_overflows));
-		return FALSE;
+		if (!SIG_WRITE_FIELD(channel, queue, &sig_hdr, num_overflows))
+			return FALSE;
 	}
 
 	if (!sig_write_data(channel, queue, &sig_hdr, sig_hdr.head, msg))
-		return FALSE;
+			return FALSE;
 
 	sig_hdr.num_sent++;
 
@@ -469,10 +466,10 @@ signalinsert_inner(struct visorchannel *channel, u32 queue, void *msg)
 	 */
 	mb(); /* required for channel synch */
 	if (!SIG_WRITE_FIELD(channel, queue, &sig_hdr, head))
-		return FALSE;
-	if (!SIG_WRITE_FIELD(channel, queue, &sig_hdr, num_sent)) {
-		return FALSE;
-	}
+			return FALSE;
+
+	if (!SIG_WRITE_FIELD(channel, queue, &sig_hdr, num_sent))
+			return FALSE;
 
 	return TRUE;
 }
diff --git a/drivers/staging/unisys/visorclientbus/visorclientbus_main.c b/drivers/staging/unisys/visorclientbus/visorclientbus_main.c
index 6ef3889..90aef0a 100644
--- a/drivers/staging/unisys/visorclientbus/visorclientbus_main.c
+++ b/drivers/staging/unisys/visorclientbus/visorclientbus_main.c
@@ -67,12 +67,8 @@ static void __iomem *
 get_virt(u64 phys_addr, u32 bytes, enum visorchipset_addresstype addr_type)
 {
 	if (addr_type == ADDRTYPE_LOCALTEST) {
-		if (phys_addr > virt_to_phys(high_memory - 1)) {
-			ERRDRV("%s - bad localTest address for channel (0x%-16.16Lx for %lu bytes)",
-			       __func__,
-			       (unsigned long long)phys_addr, (ulong)bytes);
-			return NULL;
-		}
+		if (phys_addr > virt_to_phys(high_memory - 1))
+				return NULL;
 		return (void __iomem *)__va(phys_addr);
 	}
 
@@ -101,10 +97,6 @@ otherwise return NULL.
 
 			if (phys_addr <= virt_to_phys(high_memory - 1)) {
 				/*Memory is reserved and within HIGH_MEMORY */
-				ERRDRV("%s - localPhysical address overlaps memory our OS is currently using! (0x%-16.16Lx for %lu bytes)",
-				       __func__,
-				       (unsigned long long)phys_addr,
-				       (ulong)bytes);
 				return NULL;
 			}
 			break;	/* greater then HIGH_MEMORY */
@@ -113,15 +105,10 @@ otherwise return NULL.
 		 * HIGM_MEMORY
 		 */
 		if (phys_addr > (u64)ULONG_MAX) {
-			ERRDRV("%s - localPhysical address is too large to be be mapped (0x%-16.16Lx for %lu bytes)",
-			       __func__,
-			       (unsigned long long)phys_addr, (ulong)bytes);
 			return NULL;
 		}
 		pcpy = ioremap_cache((ulong)phys_addr, (ulong)bytes);
 		if (pcpy == NULL) {
-			ERRDRV("%s - ioremap_cache(0x%lx,%lu) failed",
-			       __func__, (ulong)phys_addr, (ulong)bytes);
 			return NULL;
 		}
 		return pcpy;
@@ -132,17 +119,13 @@ otherwise return NULL.
 static void __iomem *
 chipset_preamble(ulong bus_no, ulong dev_no, struct visorchipset_device_info *devinfo)
 {
-	if (!visorchipset_get_device_info(bus_no, dev_no, devinfo)) {
-		ERRDRV("%s - visorchipset_get_device_info returned false",
-		       __func__);
-		return NULL;
-	}
+	if (!visorchipset_get_device_info(bus_no, dev_no, devinfo))
+			return NULL;
+
 	if ((uuid_le_cmp(devinfo->chan_info.channel_type_uuid,
 			 spar_vnic_channel_protocol_uuid) != 0) &&
 	    (uuid_le_cmp(devinfo->chan_info.channel_type_uuid,
 			 spar_vhba_channel_protocol_uuid) != 0)) {
-		ERRDRV("%s - I only know how to handle VNIC or VHBA client channels",
-		       __func__);
 		return NULL;
 	}
 	return get_virt(devinfo->chan_info.channel_addr,
@@ -187,11 +170,9 @@ chipset_bus_create(ulong bus_no)
 	}
 
 	if (rc >= 0) {
-		INFODRV("%s(%lu) successful", __func__, bus_no);
 		POSTCODE_LINUX_3(BUS_CREATE_EXIT_PC, bus_no,
 				 POSTCODE_SEVERITY_INFO);
 	} else {
-		ERRDRV("%s(%lu) failed", __func__, bus_no);
 		POSTCODE_LINUX_3(BUS_CREATE_FAILURE_PC, bus_no,
 				 POSTCODE_SEVERITY_ERR);
 	}
@@ -207,10 +188,6 @@ chipset_bus_destroy(ulong bus_no)
 	if (!uislib_client_inject_del_bus(bus_no))
 		rc = -1;
 
-	if (rc >= 0)
-		INFODRV("%s(%lu) successful", __func__, bus_no);
-	else
-		ERRDRV("%s(%lu) failed", __func__, bus_no);
 	if (chipset_responders.bus_destroy)
 		(*chipset_responders.bus_destroy) (bus_no, rc);
 }
@@ -279,11 +256,9 @@ chipset_device_create(ulong bus_no, ulong dev_no)
 	rc = -4;		/* unsupported GUID */
 cleanup:
 	if (rc >= 0) {
-		INFODRV("%s(%lu,%lu) successful", __func__, bus_no, dev_no);
 		POSTCODE_LINUX_4(DEVICE_CREATE_SUCCESS_PC, dev_no, bus_no,
 				 POSTCODE_SEVERITY_INFO);
 	} else {
-		ERRDRV("%s(%lu,%lu)=%d failed", __func__, bus_no, dev_no, rc);
 		POSTCODE_LINUX_4(DEVICE_CREATE_FAILURE_PC, dev_no, bus_no,
 				 POSTCODE_SEVERITY_ERR);
 	}
@@ -314,10 +289,6 @@ chipset_device_destroy(ulong bus_no, ulong dev_no)
 	}
 	rc = -1;		/* no match on GUID */
 cleanup:
-	if (rc >= 0)
-		INFODRV("%s(%lu,%lu) successful", __func__, bus_no, dev_no);
-	else
-		ERRDRV("%s(%lu,%lu) failed", __func__, bus_no, dev_no);
 	if (chipset_responders.device_destroy)
 		(*chipset_responders.device_destroy) (bus_no, dev_no, rc);
 }
@@ -326,32 +297,18 @@ static void
 chipset_device_pause(ulong bus_no, ulong dev_no)
 {
 	void __iomem *paddr = NULL;
-	int rc = 0;
 	struct visorchipset_device_info devInfo;
 
 	paddr = chipset_preamble(bus_no, dev_no, &devInfo);
-	if (!paddr) {
-		rc = -1;
-		goto cleanup;
-	}
+	if (!paddr)
+			return;
+
 	if (!uuid_le_cmp(devInfo.chan_info.channel_type_uuid,
 			 spar_vnic_channel_protocol_uuid)) {
-		rc = uislib_client_inject_pause_vnic(bus_no, dev_no);
-		goto cleanup;
+		uislib_client_inject_pause_vnic(bus_no, dev_no);
 	} else if (!uuid_le_cmp(devInfo.chan_info.channel_type_uuid,
 				spar_vhba_channel_protocol_uuid)) {
-		rc = uislib_client_inject_pause_vhba(bus_no, dev_no);
-		goto cleanup;
-	}
-	rc = -1;		/* no match on GUID */
-cleanup:
-	if (rc == CONTROLVM_RESP_SUCCESS)
-		INFODRV("%s(%lu,%lu) successful", __func__, bus_no, dev_no);
-	/* Response sent when the pause is completed */
-	else {
-		ERRDRV("%s(%lu,%lu) failed", __func__, bus_no, dev_no);
-		if (chipset_responders.device_pause)
-			(*chipset_responders.device_pause) (bus_no, dev_no, rc);
+		uislib_client_inject_pause_vhba(bus_no, dev_no);
 	}
 }
 
@@ -359,37 +316,28 @@ static void
 chipset_device_resume(ulong bus_no, ulong dev_no)
 {
 	void __iomem *paddr = NULL;
-	int rc = 0;
 	struct visorchipset_device_info devInfo;
 
 	paddr = chipset_preamble(bus_no, dev_no, &devInfo);
-	if (!paddr) {
-		rc = -1;
-		goto cleanup;
-	}
+	if (!paddr)
+			goto cleanup;
 	if (!uuid_le_cmp(devInfo.chan_info.channel_type_uuid,
 			 spar_vnic_channel_protocol_uuid)) {
-		rc = uislib_client_inject_resume_vnic(bus_no, dev_no);
+		uislib_client_inject_resume_vnic(bus_no, dev_no);
 		goto cleanup;
 	} else if (!uuid_le_cmp(devInfo.chan_info.channel_type_uuid,
 				spar_vhba_channel_protocol_uuid)) {
-		rc = uislib_client_inject_resume_vhba(bus_no, dev_no);
+		uislib_client_inject_resume_vhba(bus_no, dev_no);
 		goto cleanup;
 	}
-	rc = -1;		/* no match on GUID */
 cleanup:
-	if (rc == CONTROLVM_RESP_SUCCESS)
-		INFODRV("%s(%lu,%lu) successful", __func__, bus_no, dev_no);
-	else
-		ERRDRV("%s(%lu,%lu) failed", __func__, bus_no, dev_no);
 	if (chipset_responders.device_resume)
-		(*chipset_responders.device_resume) (bus_no, dev_no, rc);
+		(*chipset_responders.device_resume)(bus_no, dev_no, 0);
 }
 
 static int __init
 visorclientbus_init(void)
 {
-	INFODRV("client bus driver version %s loaded", VERSION);
 	POSTCODE_LINUX_2(CHIPSET_INIT_ENTRY_PC, POSTCODE_SEVERITY_INFO);
 	/* This enables us to receive notifications when devices appear for
 	 * which this service partition is to be a client for.
@@ -407,7 +355,6 @@ static void
 visorclientbus_exit(void)
 {
 	visorchipset_register_busdev_client(NULL, NULL, NULL);
-	INFODRV("client bus driver unloaded");
 }
 
 module_init(visorclientbus_init);
diff --git a/drivers/staging/unisys/visorconinclient/Kconfig b/drivers/staging/unisys/visorconinclient/Kconfig
deleted file mode 100644
index 40894e1..0000000
--- a/drivers/staging/unisys/visorconinclient/Kconfig
+++ /dev/null
@@ -1,10 +0,0 @@
-#
-# Unisys visorconinclient configuration
-#
-
-config UNISYS_VISORCONINCLIENT
-	tristate "Unisys visorconinclient driver"
-	depends on UNISYSSPAR && UNISYS_VISORUTIL && UNISYS_VISORCHANNEL && UNISYS_VISORBUS && FB
-	---help---
-	If you say Y here, you will enable the Unisys visorconinclient driver.
-
diff --git a/drivers/staging/unisys/visorconinclient/Makefile b/drivers/staging/unisys/visorconinclient/Makefile
deleted file mode 100644
index 43670c7..0000000
--- a/drivers/staging/unisys/visorconinclient/Makefile
+++ /dev/null
@@ -1,17 +0,0 @@
-#
-# Makefile for Unisys visorconinclient
-#
-
-obj-$(CONFIG_UNISYS_VISORCONINCLIENT)	+= visorconinclient.o
-
-visorconinclient-y := visorconinclient_main.o
-
-ccflags-y += -Idrivers/staging/unisys/include
-ccflags-y += -Idrivers/staging/unisys/visorutil
-ccflags-y += -Idrivers/staging/unisys/visorbus
-ccflags-y += -Idrivers/staging/unisys/visorchannel
-ccflags-y += -Idrivers/staging/unisys/common-spar/include
-ccflags-y += -Idrivers/staging/unisys/common-spar/include/channels
-
-ccflags-y += -DCONFIG_SPAR_GUEST -DGUESTDRIVERBUILD -DNOAUTOVERSION
-
diff --git a/drivers/staging/unisys/visorconinclient/globals.h b/drivers/staging/unisys/visorconinclient/globals.h
deleted file mode 100644
index b5046ea..0000000
--- a/drivers/staging/unisys/visorconinclient/globals.h
+++ /dev/null
@@ -1,24 +0,0 @@
-/* globals.h
- *
- * Copyright (c) 2011 - 2014 UNISYS CORPORATION
- * All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or (at
- * your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
- * NON INFRINGEMENT.  See the GNU General Public License for more
- * details.
- */
-
-#include "version.h"
-
-#define MYDRVNAME "visorconinclient"
-#define MAXDEVICES     16384
-
-extern int visorconinclient_debug;
-extern int visorconinclient_debugref;
diff --git a/drivers/staging/unisys/visorconinclient/visorconinclient_main.c b/drivers/staging/unisys/visorconinclient/visorconinclient_main.c
deleted file mode 100644
index f5d26dd..0000000
--- a/drivers/staging/unisys/visorconinclient/visorconinclient_main.c
+++ /dev/null
@@ -1,968 +0,0 @@
-/* visorconinclient_main.c
- *
- * Copyright (c) 2011 - 2014 UNISYS CORPORATION
- * All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or (at
- * your option) any later version.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
- * NON INFRINGEMENT.  See the GNU General Public License for more
- * details.
- */
-
-/* This driver lives in a generic guest Linux partition, and registers to
- * receive keyboard and mouse channels from the visorbus driver.  It reads
- * inputs from such channels, and delivers it to the Linux OS in the
- * standard way the Linux expects for input drivers.
- */
-
-#include "uniklog.h"
-#include "diagnostics/appos_subsystems.h"
-#include "timskmod.h"
-#include "globals.h"
-#include "visorbus.h"
-#include "visorchannel.h"
-#include "keyboardchannel.h"
-#include "mousechannel.h"
-#define KBDUUID spar_keyboard_channel_protocol_uuid
-#define MOUGUID spar_mouse_channel_protocol_uuid
-#include <linux/input.h>
-#include <linux/serio.h>
-#include <linux/fs.h>
-#include <linux/fb.h>
-#include <asm/segment.h>
-#include <linux/uaccess.h>
-#include <linux/buffer_head.h>
-
-#define PIXELS_ACROSS_DEFAULT 800
-#define PIXELS_DOWN_DEFAULT   600
-#define SYSFS_VIRTUALSIZE "/sys/class/graphics/fb0/virtual_size"
-
-static spinlock_t devnopool_lock;
-static void *dev_no_pool; /**< pool to grab device numbers from */
-
-static int visorconinclient_probe(struct visor_device *dev);
-static void visorconinclient_remove(struct visor_device *dev);
-static void visorconinclient_channel_interrupt(struct visor_device *dev);
-static int visorconinclient_pause(struct visor_device *dev,
-				  VISORBUS_STATE_COMPLETE_FUNC complete_func);
-static int visorconinclient_resume(struct visor_device *dev,
-				   VISORBUS_STATE_COMPLETE_FUNC complete_func);
-static struct input_dev *register_client_keyboard(void);
-static struct input_dev *register_client_mouse(void);
-static struct input_dev *register_client_wheel(void);
-static void unregister_client_input(struct input_dev *visorinput_dev);
-
-/**  GUIDS for all channel types supported by this driver.
- */
-static struct visor_channeltype_descriptor visorconinclient_channel_types[] = {
-	{SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID, "keyboard",
-	 KEYBOARD_CH_SIZE, KEYBOARD_CH_SIZE},
-	{SPAR_MOUSE_CHANNEL_PROTOCOL_UUID, "mouse",
-	 MOUSE_CH_SIZE, MOUSE_CH_SIZE},
-	{ NULL_UUID_LE, NULL, 0, 0}
-};
-
-/** This is used to tell the visor bus driver which types of visor devices
- *  we support, and what functions to call when a visor device that we support
- *  is attached or removed.
- */
-static struct visor_driver visorconinclient_driver = {
-	.name = MYDRVNAME,
-	.version = VERSION,
-	.vertag = NULL,
-	.owner = THIS_MODULE,
-	.channel_types = visorconinclient_channel_types,
-	.probe = visorconinclient_probe,
-	.remove = visorconinclient_remove,
-	.channel_interrupt = visorconinclient_channel_interrupt,
-	.pause = visorconinclient_pause,
-	.resume = visorconinclient_resume,
-};
-
-/** This is the private data that we store for each device.
- *  A pointer to this struct is kept in each "struct device", and can be
- *  obtained using visor_get_drvdata(dev).
- */
-struct visorconinclient_devdata {
-	int devno;
-	struct visor_device *dev;
-	/** lock for dev */
-	struct rw_semaphore lock_visor_dev;
-	char name[99];
-	struct list_head list_all;   /**< link within list_all_devices list */
-	struct kref kref;
-	struct input_dev *visorinput_dev;
-	struct input_dev *visorinput_dev2;
-	BOOL supported_client_device;
-	BOOL paused;
-};
-
-/** List of all visorconinclient_devdata structs,
-  * linked via the list_all member */
-static LIST_HEAD(list_all_devices);
-static DEFINE_SPINLOCK(lock_all_devices);
-
-#define devdata_put(devdata, why)					\
-	do {								\
-		int refcount;						\
-		kref_put(&devdata->kref, devdata_release);		\
-		refcount = atomic_read(&devdata->kref.refcount);	\
-		if (visorconinclient_debugref)				\
-			VISORBUS_DEBUG_REFCOUNT_CHANGE			\
-				(refcount+1, refcount, devdata, why);	\
-	} while (0)
-
-#define devdata_get(deevdata, why)					\
-	do {								\
-		int refcount;						\
-		kref_get(&devdata->kref);				\
-		refcount = atomic_read(&devdata->kref.refcount);	\
-		if (visorconinclient_debugref)				\
-			VISORBUS_DEBUG_REFCOUNT_CHANGE			\
-				(refcount-1, refcount, devdata, why);	\
-	} while (0)
-
-/* Borrowed from drivers/input/keyboard/atakbd.c */
-/* This maps 1-byte scancodes to keycodes. */
-static unsigned char visorkbd_keycode[256] = {	/* American layout */
-	[0] = KEY_GRAVE,
-	[1] = KEY_ESC,
-	[2] = KEY_1,
-	[3] = KEY_2,
-	[4] = KEY_3,
-	[5] = KEY_4,
-	[6] = KEY_5,
-	[7] = KEY_6,
-	[8] = KEY_7,
-	[9] = KEY_8,
-	[10] = KEY_9,
-	[11] = KEY_0,
-	[12] = KEY_MINUS,
-	[13] = KEY_EQUAL,
-	[14] = KEY_BACKSPACE,
-	[15] = KEY_TAB,
-	[16] = KEY_Q,
-	[17] = KEY_W,
-	[18] = KEY_E,
-	[19] = KEY_R,
-	[20] = KEY_T,
-	[21] = KEY_Y,
-	[22] = KEY_U,
-	[23] = KEY_I,
-	[24] = KEY_O,
-	[25] = KEY_P,
-	[26] = KEY_LEFTBRACE,
-	[27] = KEY_RIGHTBRACE,
-	[28] = KEY_ENTER,
-	[29] = KEY_LEFTCTRL,
-	[30] = KEY_A,
-	[31] = KEY_S,
-	[32] = KEY_D,
-	[33] = KEY_F,
-	[34] = KEY_G,
-	[35] = KEY_H,
-	[36] = KEY_J,
-	[37] = KEY_K,
-	[38] = KEY_L,
-	[39] = KEY_SEMICOLON,
-	[40] = KEY_APOSTROPHE,
-	[41] = KEY_GRAVE,	/* FIXME, '#' */
-	[42] = KEY_LEFTSHIFT,
-	[43] = KEY_BACKSLASH,	/* FIXME, '~' */
-	[44] = KEY_Z,
-	[45] = KEY_X,
-	[46] = KEY_C,
-	[47] = KEY_V,
-	[48] = KEY_B,
-	[49] = KEY_N,
-	[50] = KEY_M,
-	[51] = KEY_COMMA,
-	[52] = KEY_DOT,
-	[53] = KEY_SLASH,
-	[54] = KEY_RIGHTSHIFT,
-	[55] = KEY_KPASTERISK,
-	[56] = KEY_LEFTALT,
-	[57] = KEY_SPACE,
-	[58] = KEY_CAPSLOCK,
-	[59] = KEY_F1,
-	[60] = KEY_F2,
-	[61] = KEY_F3,
-	[62] = KEY_F4,
-	[63] = KEY_F5,
-	[64] = KEY_F6,
-	[65] = KEY_F7,
-	[66] = KEY_F8,
-	[67] = KEY_F9,
-	[68] = KEY_F10,
-	[69] = KEY_NUMLOCK,
-	[70] = KEY_SCROLLLOCK,
-	[71] = KEY_KP7,
-	[72] = KEY_KP8,
-	[73] = KEY_KP9,
-	[74] = KEY_KPMINUS,
-	[75] = KEY_KP4,
-	[76] = KEY_KP5,
-	[77] = KEY_KP6,
-	[78] = KEY_KPPLUS,
-	[79] = KEY_KP1,
-	[80] = KEY_KP2,
-	[81] = KEY_KP3,
-	[82] = KEY_KP0,
-	[83] = KEY_KPDOT,
-	[87] = KEY_F11,
-	[88] = KEY_F12,
-	[90] = KEY_KPLEFTPAREN,
-	[91] = KEY_KPRIGHTPAREN,
-	[92] = KEY_KPASTERISK,	/* FIXME */
-	[93] = KEY_KPASTERISK,
-	[94] = KEY_KPPLUS,
-	[95] = KEY_HELP,
-	[96] = KEY_KPENTER,
-	[97] = KEY_RIGHTCTRL,
-	[98] = KEY_KPSLASH,
-	[99] = KEY_KPLEFTPAREN,
-	[100] = KEY_KPRIGHTPAREN,
-	[101] = KEY_KPSLASH,
-	[102] = KEY_HOME,
-	[103] = KEY_UP,
-	[104] = KEY_PAGEUP,
-	[105] = KEY_LEFT,
-	[106] = KEY_RIGHT,
-	[107] = KEY_END,
-	[108] = KEY_DOWN,
-	[109] = KEY_PAGEDOWN,
-	[110] = KEY_INSERT,
-	[111] = KEY_DELETE,
-	[112] = KEY_MACRO,
-	[113] = KEY_MUTE
-};
-
-/* This maps the <xx> in extended scancodes of the form "0xE0 <xx>" into */
-/* keycodes. */
-static unsigned char ext_keycode[256] = {
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x00 */
-	0, 0, 0, 0, 0, 0, 0, 0,	/* 0x10 */
-	0, 0, 0, 0, KEY_KPENTER, KEY_RIGHTCTRL, 0, 0,	/* 0x18 */
-	0, 0, 0, 0, 0, 0, 0, 0,	/* 0x20 */
-	KEY_RIGHTALT, 0, 0, 0, 0, 0, 0, 0,	/* 0x28 */
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x30 */
-	0, 0, 0, 0, 0, 0, 0, KEY_HOME,	/* 0x40 */
-	KEY_UP, KEY_PAGEUP, 0, KEY_LEFT, 0, KEY_RIGHT, 0, KEY_END, /* 0x48 */
-	KEY_DOWN, KEY_PAGEDOWN, KEY_INSERT, KEY_DELETE, 0, 0, 0, 0, /* 0x50 */
-	0, 0, 0, 0, 0, 0, 0, 0,	/* 0x58 */
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x60 */
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x70 */
-};
-
-static struct visorconinclient_devdata *
-devdata_create(struct visor_device *dev)
-{
-	void *rc = NULL;
-	struct visorconinclient_devdata *devdata = NULL;
-	int devno = -1;
-	uuid_le guid;
-
-	guid = visorchannel_get_uuid(dev->visorchannel);
-	devdata = kmalloc(sizeof(*devdata),
-			  GFP_KERNEL|__GFP_NORETRY);
-	if (devdata == NULL) {
-		ERRDRV("allocation of visorconinclient_devdata failed: (status=0)\n");
-		goto cleanups;
-	}
-	memset(devdata, '\0', sizeof(struct visorconinclient_devdata));
-	spin_lock(&devnopool_lock);
-	devno = find_first_zero_bit(dev_no_pool, MAXDEVICES);
-	set_bit(devno, dev_no_pool);
-	spin_unlock(&devnopool_lock);
-	if (devno == MAXDEVICES)
-		devno = -1;
-	if (devno < 0) {
-		ERRDRV("attempt to create more than MAXDEVICES devices: (status=0)\n");
-		goto cleanups;
-	}
-
-	devdata->devno = devno;
-	devdata->dev = dev;
-	strncpy(devdata->name, dev_name(&dev->device), sizeof(devdata->name));
-
-	/* This is an input device in a client guest partition,
-	 * so we need to create whatever gizmos are necessary to
-	 * deliver our inputs to the guest OS. */
-	if (memcmp(&guid, &KBDUUID, sizeof(guid)) == 0) {
-		devdata->visorinput_dev = register_client_keyboard();
-		if (devdata->visorinput_dev == NULL) {
-			ERRDRV("failed to create client keyboard device: (status=0)\n");
-			goto cleanups;
-		}
-		devdata->supported_client_device = TRUE;
-	} else if (memcmp(&guid, &MOUGUID, sizeof(guid)) == 0) {
-		devdata->visorinput_dev = register_client_mouse();
-		if (devdata->visorinput_dev == NULL) {
-			ERRDRV("failed to create client mouse device: (status=0)\n");
-			goto cleanups;
-		}
-		devdata->visorinput_dev2 = register_client_wheel();
-		if (devdata->visorinput_dev2 == NULL) {
-			ERRDRV("failed to create client wheel device: (status=0)\n");
-			goto cleanups;
-		}
-		devdata->supported_client_device = TRUE;
-	}
-
-	init_rwsem(&devdata->lock_visor_dev);
-	kref_init(&devdata->kref);
-
-	spin_lock(&lock_all_devices);
-	list_add_tail(&devdata->list_all, &list_all_devices);
-	spin_unlock(&lock_all_devices);
-
-	rc = devdata;
-cleanups:
-	if (rc == NULL) {
-		if (devno >= 0) {
-			spin_lock(&devnopool_lock);
-			clear_bit(devno, dev_no_pool);
-			spin_unlock(&devnopool_lock);
-		}
-		if (devdata != NULL) {
-			if (devdata->visorinput_dev != NULL) {
-				unregister_client_input
-				    (devdata->visorinput_dev);
-				devdata->visorinput_dev = NULL;
-			}
-			if (devdata->visorinput_dev2 != NULL) {
-				unregister_client_input
-				    (devdata->visorinput_dev2);
-				devdata->visorinput_dev2 = NULL;
-			}
-			kfree(devdata);
-		}
-	}
-	return rc;
-}
-
-static void
-devdata_release(struct kref *mykref)
-{
-	struct visorconinclient_devdata *devdata =
-	    container_of(mykref, struct visorconinclient_devdata, kref);
-	INFODRV("%s", __func__);
-	spin_lock(&devnopool_lock);
-	clear_bit(devdata->devno, dev_no_pool);
-	spin_unlock(&devnopool_lock);
-	spin_lock(&lock_all_devices);
-	list_del(&devdata->list_all);
-	spin_unlock(&lock_all_devices);
-	INFODRV("%s finished", __func__);
-}
-
-static int
-visorconinclient_probe(struct visor_device *dev)
-{
-	int rc = 0;
-	struct visorconinclient_devdata *devdata = NULL;
-	uuid_le guid;
-
-	INFODRV("%s", __func__);
-
-	devdata = devdata_create(dev);
-	if (devdata == NULL) {
-		rc = -1;
-		goto cleanups;
-	}
-	visor_set_drvdata(dev, devdata);
-	guid = visorchannel_get_uuid(dev->visorchannel);
-	if (memcmp(&guid, &MOUGUID, sizeof(guid)) != 0 &&
-	    memcmp(&guid, &KBDUUID, sizeof(guid)) != 0) {
-		ERRDRV("unrecognized GUID: (status=-1)\n");
-		rc = -1;
-		goto cleanups;
-	}
-
-	if (devdata->supported_client_device)
-		visorbus_enable_channel_interrupts(dev);
-
-cleanups:
-	INFODRV("%s finished", __func__);
-	if (rc < 0) {
-		if (devdata != NULL)
-			devdata_put(devdata, "existence");
-	}
-	return rc;
-}
-
-static void
-host_side_disappeared(struct visorconinclient_devdata *devdata)
-{
-	down_write(&devdata->lock_visor_dev);
-	sprintf(devdata->name, "<dev#%d-history>", devdata->devno);
-	devdata->dev = NULL;	/* indicate device destroyed */
-	up_write(&devdata->lock_visor_dev);
-}
-
-static void
-visorconinclient_remove(struct visor_device *dev)
-{
-	struct visorconinclient_devdata *devdata = visor_get_drvdata(dev);
-
-	INFODRV("%s", __func__);
-	if (devdata == NULL) {
-		ERRDRV("no devdata in %s", __func__);
-		goto cleanups;
-	}
-	visor_set_drvdata(dev, NULL);
-	host_side_disappeared(devdata);
-	unregister_client_input(devdata->visorinput_dev);
-	devdata->visorinput_dev = NULL;
-	unregister_client_input(devdata->visorinput_dev2);
-	devdata->visorinput_dev2 = NULL;
-	devdata_put(devdata, "existence");
-cleanups:
-	INFODRV("%s finished", __func__);
-}
-
-static void
-visorconinclient_cleanup_guts(void)
-{
-	visorbus_unregister_visor_driver(&visorconinclient_driver);
-	if (dev_no_pool != NULL) {
-		kfree(dev_no_pool);
-		dev_no_pool = NULL;
-	}
-}
-
-static void
-unregister_client_input(struct input_dev *visorinput_dev)
-{
-	if (visorinput_dev != NULL) {
-		input_unregister_device(visorinput_dev);
-		INFODRV("unregistered client input device");
-	}
-}
-
-/* register_client_keyboard() initializes and returns a Linux gizmo that we
- * can use to deliver keyboard inputs to Linux.  We of course do this when
- * we see keyboard inputs coming in on a keyboard channel.
- */
-static struct input_dev *
-register_client_keyboard(void)
-{
-	int i, error;
-	struct input_dev *visorinput_dev = NULL;
-
-	visorinput_dev = input_allocate_device();
-	if (!visorinput_dev) {
-		ERRDRV("input_allocate_device() failed");
-		return NULL;
-	}
-
-	visorinput_dev->name = "visor Keyboard";
-	visorinput_dev->phys = "visorkbd/input0";
-	visorinput_dev->id.bustype = BUS_HOST;
-	visorinput_dev->id.vendor = 0x0001;
-	visorinput_dev->id.product = 0x0001;
-	visorinput_dev->id.version = 0x0100;
-
-	visorinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP)
-	    | BIT_MASK(EV_LED);
-	visorinput_dev->ledbit[0] = BIT_MASK(LED_CAPSL)
-	    | BIT_MASK(LED_SCROLLL) | BIT_MASK(LED_NUML);
-	visorinput_dev->keycode = visorkbd_keycode;
-	visorinput_dev->keycodesize = sizeof(unsigned char);
-	visorinput_dev->keycodemax = ARRAY_SIZE(visorkbd_keycode);
-
-	for (i = 1; i < ARRAY_SIZE(visorkbd_keycode); i++)
-		set_bit(visorkbd_keycode[i], visorinput_dev->keybit);
-
-	error = input_register_device(visorinput_dev);
-	if (error) {
-		input_free_device(visorinput_dev);
-		ERRDRV("input_register_device() failed");
-		return NULL;
-	}
-	INFODRV("registered client input device");
-
-	return visorinput_dev;
-}
-
-/* register_client_mouse() initializes and returns a Linux gizmo that we
- * can use to deliver mouse inputs to Linux.  We of course do this when
- * we see mouse inputs coming in on a mouse channel.
- *
- * Note that in order to use the mouse in X, it needs to be declared like
- * this in xorg.conf:
- *
- *    Section "InputDevice"
- *      Driver       "evdev"
- *      Identifier   "sPAR virtual mouse"
- *      Option       "Device" "/dev/input/event1"
- *      Option       "AccelerationProfile" "-1"
- *      Option       "AccelerationScheme" "none"
- *      Option       "CorePointer"
- *    EndSection
- *
- * Then reference that from your ServerLayout section, like this:
- *
- *    InputDevice  "sPAR virtual mouse" "CoreMouse"
- *
- * This command can be used to determine which /dev/input/event* device
- * is the sPAR mouse:
- *
- *    udevadm info --attribute-walk --name=/dev/input/event*
- */
-static struct input_dev *
-register_client_mouse(void)
-{
-	int error;
-	struct input_dev *visorinput_dev = NULL;
-	int xres, yres;
-	struct fb_info *fb0;
-
-	visorinput_dev = input_allocate_device();
-	if (!visorinput_dev) {
-		ERRDRV("input_allocate_device() failed");
-		return NULL;
-	}
-
-	visorinput_dev->name = "visor Mouse";
-	visorinput_dev->phys = "visormou/input0";
-	visorinput_dev->id.bustype = BUS_HOST;
-	visorinput_dev->id.vendor = 0x0001;
-	visorinput_dev->id.product = 0x0001;
-	visorinput_dev->id.version = 0x0100;
-
-	visorinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
-	set_bit(BTN_LEFT, visorinput_dev->keybit);
-	set_bit(BTN_RIGHT, visorinput_dev->keybit);
-	set_bit(BTN_MIDDLE, visorinput_dev->keybit);
-
-	if (registered_fb[0]) {
-		fb0 = registered_fb[0];
-		xres = fb0->var.xres_virtual;
-		yres = fb0->var.yres_virtual;
-	} else {
-		xres = PIXELS_ACROSS_DEFAULT;
-		yres = PIXELS_DOWN_DEFAULT;
-	}
-	input_set_abs_params(visorinput_dev, ABS_X, 0, xres, 0, 0);
-	input_set_abs_params(visorinput_dev, ABS_Y, 0, yres, 0, 0);
-
-	error = input_register_device(visorinput_dev);
-	if (error) {
-		input_free_device(visorinput_dev);
-		ERRDRV("input_register_device() failed");
-		return NULL;
-	}
-	INFODRV("registered client input device");
-
-	/* Sending top-left and bottom-right positions is ABSOLUTELY
-	* REQUIRED if we want X to move the mouse to the exact points
-	* we tell it.  I have NO IDEA why.
-	*/
-	input_report_abs(visorinput_dev, ABS_X, 0);
-	input_report_abs(visorinput_dev, ABS_Y, 0);
-	input_sync(visorinput_dev);
-	input_report_abs(visorinput_dev, ABS_X, xres - 1);
-	input_report_abs(visorinput_dev, ABS_Y, yres - 1);
-	input_sync(visorinput_dev);
-
-	return visorinput_dev;
-}
-
-/* register_client_wheel() initializes and returns a Linux gizmo that we
- * can use to deliver mouse wheel inputs to Linux.  We of course do this when
- * we see wheel inputs coming in on a mouse channel.  It would be NICE to be
- * able to report wheel events on the mouse device, but X can't deal with a
- * single device that has both absolute (X and Y) and relative (wheel) axes.
- * That's why we create 2 devices for Linux: 1 mouse device and 1 wheel device.
- *
- * Note that in order to use the wheel in X, it needs to be declared like
- * this in xorg.conf:
- *
- *    Section "InputDevice"
- *      Driver       "evdev"
- *      Identifier   "sPAR virtual wheel"
- *      Option       "Device" "/dev/input/event4"
- *    EndSection
- *
- * Then reference that from your ServerLayout section, like this:
- *
- *    InputDevice  "sPAR virtual wheel"
- *
- * This command can be used to determine which /dev/input/event* device
- * is the sPAR wheel:
- *
- *    udevadm info --attribute-walk --name=/dev/input/event*
- */
-static struct input_dev *
-register_client_wheel(void)
-{
-	int error;
-	struct input_dev *visorinput_dev = NULL;
-
-	visorinput_dev = input_allocate_device();
-	if (!visorinput_dev) {
-		ERRDRV("input_allocate_device() failed");
-		return NULL;
-	}
-
-	visorinput_dev->name = "visor Wheel";
-	visorinput_dev->phys = "visorwhl/input0";
-	visorinput_dev->id.bustype = BUS_HOST;
-	visorinput_dev->id.vendor = 0x0001;
-	visorinput_dev->id.product = 0x0001;
-	visorinput_dev->id.version = 0x0100;
-
-	/* We need to lie a little to prevent the evdev driver "Don't
-	* know how to use device" error.  (evdev erroneously thinks
-	* that a device without an X and Y axis is useless.)
-	*/
-	visorinput_dev->evbit[0] = BIT_MASK(EV_REL)
-	    | /*lie */ BIT_MASK(EV_KEY)	/*lie */
-	    ;
-	visorinput_dev->relbit[0] = BIT_MASK(REL_WHEEL)
-	    | /*lie */ BIT_MASK(REL_X)	/*lie */
-	    | /*lie */ BIT_MASK(REL_Y)	/*lie */
-	    ;
-	set_bit(BTN_LEFT, visorinput_dev->keybit);	/*lie */
-	set_bit(BTN_RIGHT, visorinput_dev->keybit);	/*lie */
-	set_bit(BTN_MIDDLE, visorinput_dev->keybit);	/*lie */
-
-	error = input_register_device(visorinput_dev);
-	if (error) {
-		input_free_device(visorinput_dev);
-		ERRDRV("input_register_device() failed");
-		return NULL;
-	}
-	INFODRV("registered client input device");
-	return visorinput_dev;
-}
-
-static void
-do_key(struct input_dev *inpt, int keycode, int down)
-{
-	input_report_key(inpt, keycode, down);
-}
-
-/* Make it so the current locking state of the locking key indicated by
- * <keycode> is as indicated by <desired_state> (1=locked, 0=unlocked).
- */
-static void
-handle_locking_key(struct input_dev *visorinput_dev,
-		   int keycode, int desired_state)
-{
-	int led;
-	char *sled;
-
-	switch (keycode) {
-	case KEY_CAPSLOCK:
-		led = LED_CAPSL;
-		sled = "CAP";
-		break;
-	case KEY_SCROLLLOCK:
-		led = LED_SCROLLL;
-		sled = "SCR";
-		break;
-	case KEY_NUMLOCK:
-		led = LED_NUML;
-		sled = "NUM";
-		break;
-	default:
-		WARNDRV("invalid locking key %d", keycode);
-		led = -1;
-		break;
-	}
-	if (led >= 0) {
-		int old_state = (test_bit(led, visorinput_dev->led) != 0);
-
-		if (old_state != desired_state) {
-			DEBUGDRV("LED %s change: %d-->%d",
-				 sled, old_state, desired_state);
-			do_key(visorinput_dev, keycode, 1);
-			do_key(visorinput_dev, keycode, 0);
-			input_sync(visorinput_dev);
-			__change_bit(led, visorinput_dev->led);
-		} else {
-			DEBUGDRV("LED %s UNCHANGED(%d)", sled, old_state);
-		}
-	}
-}
-
-/* <scancode> is either a 1-byte scancode, or an extended 16-bit scancode
- * with 0xE0 in the low byte and the extended scancode value in the next
- * higher byte.
- */
-static int
-scancode_to_keycode(int scancode)
-{
-	int keycode;
-
-	if (scancode > 0xff)
-		keycode = ext_keycode[(scancode >> 8) & 0xff];
-	else
-		keycode = visorkbd_keycode[scancode];
-	return keycode;
-}
-
-static int
-calc_button(int x)
-{
-	switch (x) {
-	case 1:
-		return BTN_LEFT;
-	case 2:
-		return BTN_MIDDLE;
-	case 3:
-		return BTN_RIGHT;
-	default:
-		return -1;
-	}
-}
-
-/* This is used only when this driver is active as an input driver in the
- * client guest partition.  It is called periodically so we can obtain inputs
- * from the channel, and deliver them to the guest OS.
- */
-static void
-visorconinclient_channel_interrupt(struct visor_device *dev)
-{
-	ULTRA_INPUTREPORT r;
-	int scancode, keycode;
-	struct input_dev *visorinput_dev;
-	struct input_dev *visorinput_dev2;
-	int xmotion, ymotion, zmotion, button;
-	int i;
-	BOOL locked = FALSE;
-
-	struct visorconinclient_devdata *devdata = visor_get_drvdata(dev);
-
-	if (devdata == NULL) {
-		ERRDEV(dev_name(&dev->device), "no devdata in %s",
-		       __func__);
-		goto cleanups;
-	}
-	down_write(&devdata->lock_visor_dev);
-	locked = TRUE;
-	if (devdata->paused)
-		goto cleanups;	/* don't touch device/channel when paused */
-	visorinput_dev = devdata->visorinput_dev;
-	if (visorinput_dev == NULL) {
-		ERRDEV(dev_name(&dev->device), "no visorinput_dev in %s",
-		       __func__);
-		goto cleanups;
-	}
-	visorinput_dev2 = devdata->visorinput_dev2;
-	while (visorchannel_signalremove(dev->visorchannel, 0, &r)) {
-		scancode = r.activity.arg1;
-		keycode = scancode_to_keycode(scancode);
-		switch (r.activity.action) {
-		case inputAction_keyDown:
-			do_key(visorinput_dev, keycode, 1);
-			input_sync(visorinput_dev);
-			break;
-		case inputAction_keyUp:
-			do_key(visorinput_dev, keycode, 0);
-			input_sync(visorinput_dev);
-			break;
-		case inputAction_keyDownUp:
-			do_key(visorinput_dev, keycode, 1);
-			do_key(visorinput_dev, keycode, 0);
-			input_sync(visorinput_dev);
-			break;
-		case inputAction_setLockingKeyState:
-			handle_locking_key(visorinput_dev, keycode,
-					   r.activity.arg2);
-			break;
-		case inputAction_xyMotion:
-			xmotion = r.activity.arg1;
-			ymotion = r.activity.arg2;
-			input_report_abs(visorinput_dev, ABS_X, xmotion);
-			input_report_abs(visorinput_dev, ABS_Y, ymotion);
-			input_sync(visorinput_dev);
-			break;
-		case inputAction_mouseButtonDown:
-			button = calc_button(r.activity.arg1);
-			if (button < 0)
-				break;
-			input_report_key(visorinput_dev, button, 1);
-			input_sync(visorinput_dev);
-			break;
-		case inputAction_mouseButtonUp:
-			button = calc_button(r.activity.arg1);
-			if (button < 0)
-				break;
-			input_report_key(visorinput_dev, button, 0);
-			input_sync(visorinput_dev);
-			break;
-		case inputAction_mouseButtonClick:
-			button = calc_button(r.activity.arg1);
-			if (button < 0)
-				break;
-			input_report_key(visorinput_dev, button, 1);
-
-			input_sync(visorinput_dev);
-			input_report_key(visorinput_dev, button, 0);
-			input_sync(visorinput_dev);
-			break;
-		case inputAction_mouseButtonDclick:
-			button = calc_button(r.activity.arg1);
-			if (button < 0)
-				break;
-			for (i = 0; i < 2; i++) {
-				input_report_key(visorinput_dev, button, 1);
-				input_sync(visorinput_dev);
-				input_report_key(visorinput_dev, button, 0);
-				input_sync(visorinput_dev);
-			}
-			break;
-		case inputAction_wheelRotateAway:
-			if (visorinput_dev2 == NULL) {
-				ERRDEV(dev_name(&dev->device),
-				       "no visorinput_dev2 in %s",
-				       __func__);
-				goto cleanups;
-			}
-			zmotion = r.activity.arg1;
-			input_report_rel(visorinput_dev2, REL_WHEEL, 1);
-			input_sync(visorinput_dev2);
-			break;
-		case inputAction_wheelRotateToward:
-			if (visorinput_dev2 == NULL) {
-				ERRDEV(dev_name(&dev->device),
-				       "no visorinput_dev2 in %s",
-				       __func__);
-				goto cleanups;
-			}
-			zmotion = r.activity.arg1;
-			input_report_rel(visorinput_dev2, REL_WHEEL, -1);
-			input_sync(visorinput_dev2);
-			break;
-		}
-	}
-
-cleanups:
-	if (locked) {
-		up_write(&devdata->lock_visor_dev);
-		locked = FALSE;
-	}
-}
-
-static int
-visorconinclient_pause(struct visor_device *dev,
-		       VISORBUS_STATE_COMPLETE_FUNC complete_func)
-{
-	BOOL locked = FALSE;
-	int rc = -1;
-	struct visorconinclient_devdata *devdata = visor_get_drvdata(dev);
-
-	if (devdata == NULL) {
-		ERRDEV(dev_name(&dev->device), "no devdata in %s",
-		       __func__);
-		goto cleanups;
-	}
-	down_write(&devdata->lock_visor_dev);
-	locked = TRUE;
-	if (devdata->paused) {
-		ERRDEV(dev_name(&dev->device),
-		       "already paused, so pause not necessary");
-		goto cleanups;
-	}
-	/* SLEEP(5);  // test */
-	devdata->paused = TRUE;
-	INFODEV(dev_name(&dev->device), "paused");
-	complete_func(dev, 0);
-	rc = 0;
-cleanups:
-	if (locked) {
-		up_write(&devdata->lock_visor_dev);
-		locked = FALSE;
-	}
-	return rc;
-}
-
-static int
-visorconinclient_resume(struct visor_device *dev,
-			VISORBUS_STATE_COMPLETE_FUNC complete_func)
-{
-	BOOL locked = FALSE;
-	int rc = -1;
-	struct visorconinclient_devdata *devdata = visor_get_drvdata(dev);
-
-	if (devdata == NULL) {
-		ERRDEV(dev_name(&dev->device), "no devdata in %s",
-		       __func__);
-		goto cleanups;
-	}
-	down_write(&devdata->lock_visor_dev);
-	locked = TRUE;
-	if (!devdata->paused) {
-		ERRDEV(dev_name(&dev->device),
-		       "NOT paused, so resume not necessary");
-		goto cleanups;
-	}
-	devdata->paused = FALSE;
-	INFODEV(dev_name(&dev->device), "resumed");
-	complete_func(dev, 0);
-	rc = 0;
-cleanups:
-	if (locked) {
-		up_write(&devdata->lock_visor_dev);
-		locked = FALSE;
-	}
-	return rc;
-}
-
-static int
-visorconinclient_init(void)
-{
-	int rc = 0;
-
-	INFODRV("driver version %s loaded", VERSION);
-
-	/* show module options */
-	INFODRV("option - debug=%d", visorconinclient_debug);
-	INFODRV("         debugref=%d", visorconinclient_debugref);
-
-	spin_lock_init(&devnopool_lock);
-	dev_no_pool = kzalloc(BITS_TO_LONGS(MAXDEVICES), GFP_KERNEL);
-	if (dev_no_pool == NULL) {
-		ERRDRV("Unable to create dev_no_pool");
-		rc = -1;
-		goto cleanups;
-	}
-	visorbus_register_visor_driver(&visorconinclient_driver);
-
-cleanups:
-	if (rc < 0)
-		visorconinclient_cleanup_guts();
-	return rc;
-}
-
-static void
-visorconinclient_cleanup(void)
-{
-	visorconinclient_cleanup_guts();
-	INFODRV("driver unloaded");
-}
-
-module_param_named(debug, visorconinclient_debug, int, S_IRUGO);
-MODULE_PARM_DESC(visorconinclient_debug, "1 to debug");
-int visorconinclient_debug = 0;
-
-module_param_named(debugref, visorconinclient_debugref, int, S_IRUGO);
-MODULE_PARM_DESC(visorconinclient_debugref, "1 to debug reference counts");
-int visorconinclient_debugref = 0;
-
-module_init(visorconinclient_init);
-module_exit(visorconinclient_cleanup);
-
-MODULE_AUTHOR("Unisys");
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("sPAR human input driver for guest Linux: ver " VERSION);
-MODULE_VERSION(VERSION);
diff --git a/drivers/staging/unisys/visordiag/visordiag_main.c b/drivers/staging/unisys/visordiag/visordiag_main.c
index 6480531..1a110d2 100644
--- a/drivers/staging/unisys/visordiag/visordiag_main.c
+++ b/drivers/staging/unisys/visordiag/visordiag_main.c
@@ -17,7 +17,6 @@
 
 #include "visordiag_private.h"
 #include "easyproc.h"
-#include "uniklog.h"
 #include "diagnostics/appos_subsystems.h"
 #include "uisutils.h"
 #include <linux/time.h>
@@ -35,7 +34,6 @@
 #define MAX_THROTTLE_TRIES 1200	/* (1200 * .25 sec = 5 min) */
 static ulong visordiag_channeladdress;
 static int visordiag_major;
-static int visordiag_debugref;
 
 static spinlock_t devnopool_lock;
 static void *dev_no_pool;	/**< pool to grab device numbers from */
@@ -282,32 +280,16 @@ register_devdata_attributes(struct visor_device *dev)
 		pattr[i].show = devdata_property_show;
 		pattr[i].store = NULL;
 		rc = device_create_file(&dev->device, &pattr[i]);
-		if (rc < 0) {
-			ERRDRV("device_create_file(&dev->device, &pattr[i]) failed: (status=%d)\n",
-			       rc);
-			goto away;
-		}
+		if (rc < 0)
+				return rc;
 	}
-
-	rc = 0;
-away:
 	return rc;
 }
 
 static int
 register_device_attributes(struct visor_device *dev)
 {
-	int rc;
-
-	rc = register_devdata_attributes(dev);
-	if (rc < 0) {
-		ERRDRV("register_devdata_attributes(dev) failed: (status=%d)\n",
-		       rc);
-		goto away;
-	}
-	rc = 0;
-away:
-	return rc;
+	return register_devdata_attributes(dev);
 }
 
 static int
@@ -339,20 +321,17 @@ devdata_create(struct visor_device *dev)
 
 	devdata = kmalloc(sizeof(*devdata),
 			  GFP_KERNEL|__GFP_NORETRY);
-	if (devdata == NULL) {
-		ERRDRV("allocation of visordiag_devdata failed: (status=0)\n");
-		goto away;
-	}
+	if (devdata == NULL)
+			goto away;
+
 	memset(devdata, '\0', sizeof(struct visordiag_devdata));
 	cdev_init(&devdata->cdev_diag, NULL);
 	spin_lock(&devnopool_lock);
 	devno = find_first_zero_bit(dev_no_pool, MAXDEVICES);
 	set_bit(devno, dev_no_pool);
 	spin_unlock(&devnopool_lock);
-	if (devno < 0) {
-		ERRDRV("attempt to create more than MAXDEVICES devices: (status=0)\n");
-		goto away;
-	}
+	if (devno < 0)
+			goto away;
 
 	devdata->devno = devno;
 	devdata->dev = dev;
@@ -370,37 +349,21 @@ devdata_create(struct visor_device *dev)
 					      devdata->devno, /* start minor */
 					      NCHARDEVICES,   /* count */
 					      MYDRVNAME);
-		if (errcode < 0) {
-			ERRDRV("alloc_chrdev_region(start_minor=%d) failed with err=%d\n",
-			       devdata->devno, errcode);
-			ERRDRV("Unable to alloc+register dynamic char device: (status=0)\n");
-			goto away;
-		}
+		if (errcode < 0)
+				goto away;
 		devdata->char_device_registered = TRUE;
-		INFODRV("New major number %d registered\n",
-			MAJOR(devdata->devt));
 	} else {
 		/* static major device number registration required */
 		devdata->devt = MKDEV(visordiag_major, devdata->devno);
 		errcode = register_chrdev_region(devdata->devt,
 						 NCHARDEVICES, MYDRVNAME);
-		if (errcode < 0) {
-			ERRDRV("register_chrdev_region(devt=%d,%d) failed with err=%d\n",
-			       visordiag_major, devdata->devno, errcode);
-			ERRDRV("Unable to register static char device: (status=0)\n");
-			goto away;
-		}
+		if (errcode < 0)
+				goto away;
 		devdata->char_device_registered = TRUE;
-		INFODRV("Static major number %d registered\n",
-			MAJOR(devdata->devt));
 	}
 	errcode = cdev_add(&devdata->cdev_diag, devdata->devt, NCHARDEVICES);
-	if (errcode < 0) {
-		ERRDRV("cdev_add(maj=%d, min=%d) failed with err=%d\n",
-		       MAJOR(devdata->devt), MINOR(devdata->devt), errcode);
-		ERRDRV("failed to create char devices: (status=0)\n");
-		goto away;
-	}
+	if (errcode < 0)
+			goto away;
 	for (i = CHRDEV_FIRST; i < CHRDEV_LASTPLUS1; i++) {
 		devdata->char_devices[i].platform_device =
 		    visordiag_platform_device_template;
@@ -410,13 +373,8 @@ devdata_create(struct visor_device *dev)
 		    MKDEV(MAJOR(devdata->devt), devdata->devno + i);
 		errcode = platform_device_register(&devdata->char_devices[i]
 						   .platform_device);
-		if (errcode < 0) {
-			ERRDRV("platform_device_register(dev#=%d, id=%d, maj=%d, min=%d) failed with err=%d\n",
-			       i, devdata->devno + i, MAJOR(devdata->devt),
-			       devdata->devno + i, errcode);
-			ERRDRV("visordiag failed to register platform devices: (status=0)\n");
-			goto away;
-		}
+		if (errcode < 0)
+				goto away;
 		devdata->char_devices[i].platform_device_registered = TRUE;
 	}
 
@@ -473,7 +431,6 @@ devdata_release(struct kref *mykref)
 {
 	struct visordiag_devdata *devdata =
 		container_of(mykref, struct visordiag_devdata, kref);
-	INFODRV("%s", __func__);
 	spin_lock(&devnopool_lock);
 	clear_bit(devdata->devno, dev_no_pool);
 	spin_unlock(&devnopool_lock);
@@ -482,7 +439,6 @@ devdata_release(struct kref *mykref)
 	spin_unlock(&lock_all_devices);
 	free_char_devices(devdata);
 	kfree(devdata);
-	INFODRV("%s finished", __func__);
 }
 
 static void
@@ -506,8 +462,6 @@ visordiag_probe(struct visor_device *dev)
 
 	struct spar_diag_channel_protocol __iomem *p = NULL;
 
-	INFODRV("%s", __func__);
-
 	devdata = devdata_create(dev);
 	if (devdata == NULL) {
 		rc = -1;
@@ -515,7 +469,6 @@ visordiag_probe(struct visor_device *dev)
 	}
 	if (!SPAR_DIAG_CHANNEL_OK_CLIENT(
 			visorchannel_get_header(dev->visorchannel))) {
-		ERRDRV("diag channel cannot be used: (status=-1)\n");
 		rc = -1;
 		goto away;
 	}
@@ -537,14 +490,12 @@ visordiag_probe(struct visor_device *dev)
 
 	visor_set_drvdata(dev, devdata);
 	if (register_device_attributes(dev) < 0) {
-		ERRDRV("register_device_attributes failed: (status=-1)\n");
 		rc = -1;
 		goto away;
 	}
 	visordiag_online(devdata);
 
 away:
-	INFODRV("%s finished", __func__);
 	if (rc < 0) {
 		if (devdata != NULL)
 			devdata_put(devdata);
@@ -557,31 +508,22 @@ visordiag_remove(struct visor_device *dev)
 {
 	struct visordiag_devdata *devdata = visor_get_drvdata(dev);
 
-	INFODRV("%s", __func__);
-	if (devdata == NULL) {
-		ERRDRV("no devdata in %s", __func__);
-		goto away;
-	}
+	if (devdata == NULL)
+			return;
+
 	visordiag_offline(devdata);
 	unregister_device_attributes(dev);
 	visor_set_drvdata(dev, NULL);
 	host_side_disappeared(devdata);
 	kref_put(&devdata->kref, devdata_release);
-
-away:
-	INFODRV("%s finished", __func__);
 }
 
 static void
 destroy_visor_device(struct visor_device *dev)
 {
-	char s[99];
-
 	if (dev == NULL)
 		return;
 	if (dev->visorchannel != NULL) {
-		INFODRV("Channel %s disconnected",
-			visorchannel_id(dev->visorchannel, s));
 		visorchannel_destroy(dev->visorchannel);
 		dev->visorchannel = NULL;
 	}
@@ -593,7 +535,6 @@ simplebus_release_device(struct device *xdev)
 {
 	struct visor_device *dev = to_visor_device(xdev);
 
-	INFODEV(dev_name(&dev->device), "child device destroyed");
 	destroy_visor_device(dev);
 }
 
@@ -604,24 +545,17 @@ create_visor_device(u64 addr)
 	struct visorchannel *visorchannel = NULL;
 	struct visor_device *dev = NULL;
 	BOOL gotten = FALSE;
-	char s[99];
 	uuid_le guid = SPAR_DIAG_CHANNEL_PROTOCOL_UUID;
 
 	/* prepare chan_hdr (abstraction to read/write channel memory) */
 	visorchannel = visorchannel_create(addr, DIAG_CH_SIZE, guid);
-	if (visorchannel == NULL) {
-		ERRDRV("channel addr = 0x%-16.16Lx", addr);
-		ERRDRV("visorchannel_create failed: (status=0)\n");
-		goto away;
-	}
+	if (visorchannel == NULL)
+			goto away;
 
-	INFODRV("Channel %s discovered and connected",
-		visorchannel_id(visorchannel, s));
 	dev = kmalloc(sizeof(*dev), GFP_KERNEL|__GFP_NORETRY);
-	if (dev == NULL) {
-		ERRDRV("failed to allocate visor_device: (status=0)\n");
-		goto away;
-	}
+	if (dev == NULL)
+			goto away;
+
 	memset(dev, 0, sizeof(struct visor_device));
 	dev->visorchannel = visorchannel;
 	sema_init(&dev->visordriver_callback_lock, 1);	/* unlocked */
@@ -638,15 +572,10 @@ create_visor_device(u64 addr)
 	 */
 	dev_set_name(&dev->device, "visordiag");
 
-	if (device_add(&dev->device) < 0) {
-		ERRDRV("device_add failed: (status=0)\n");
-		goto away;
-	}
-	/* note: device_register is simply device_initialize + device_add */
-
-	INFODEV(dev_name(&dev->device),
-		"child device 0x%p created", &dev->device);
+	if (device_add(&dev->device) < 0)
+			goto away;
 
+	/* note: device_register is simply device_initialize + device_add */
 	rc = dev;
 away:
 	if (rc == NULL) {
@@ -687,46 +616,29 @@ visordiag_init(void)
 	int rc = -1;
 	u64 diag_addr = 0;
 
-	INFODRV("driver version %s loaded", VERSION);
-	/* uintpool_test(); */
-	INFODRV("Options:");
-	INFODRV("         visordiag_channeladdress=0x%lx",
-		visordiag_channeladdress);
-	INFODRV("         major=%d", visordiag_major);
-	INFODRV("         debugref=%d", visordiag_debugref);
-
 	spin_lock_init(&devnopool_lock);
 	dev_no_pool = kzalloc(BITS_TO_LONGS(MAXDEVICES), GFP_KERNEL);
-	if (dev_no_pool == NULL) {
-		ERRDRV("Unable to create dev_no_pool");
-		goto away;
-	}
+	if (dev_no_pool == NULL)
+			goto away;
+
 	rc = bus_register(&simplebus_type);
-	if (rc < 0) {
-		ERRDRV("bus_register(&simplebus_type) failed: (status=%d)\n",
-		       rc);
-		goto away;
-	}
+	if (rc < 0)
+			goto away;
+
 	if (!visordiag_channeladdress) {
-		INFODRV("channeladdress module/kernel parameter not specified so issue vmcall");
 		if (!VMCALL_SUCCESSFUL(issue_vmcall_io_diag_addr(&diag_addr))) {
-			ERRDRV("channeladdress module/kernel parameter not specified and vmcall failed.");
 			rc = -1;
 			goto away;
 		}
-		INFODRV("diag addr=%llx", diag_addr);
 		visordiag_channeladdress = diag_addr;
 	}
 	standalone_device =
 	    create_visor_device(visordiag_channeladdress);
 	if (standalone_device == NULL) {
-		ERRDRV("failed to initialize channel @ 0x%lx",
-		       visordiag_channeladdress);
 		rc = -1;
 		goto away;
 	}
 	if (visordiag_probe(standalone_device) < 0) {
-		ERRDRV("probe failed");
 		put_visordev(standalone_device, "create", visordiag_debugref);
 		device_unregister(&standalone_device->device);
 		standalone_device = NULL;
@@ -746,7 +658,6 @@ visordiag_cleanup(void)
 {
 	subsystem_severity_filter_global = NULL;
 	visordiag_cleanup_guts();
-	INFODRV("driver unloaded");
 }
 
 /* Send ACTION=online for DEVPATH=/sys/devices/platform/visordiag. */
@@ -1122,10 +1033,9 @@ new_message_to_host(void *context, struct diag_channel_event *event)
 	int tries = 0;
 	unsigned long long cur_cycles, elapsed_cycles;
 
-	if (devdata->dev == NULL) {
-		HUHDRV("dev is NULL in %s??", __func__);
-		return;
-	}
+	if (devdata->dev == NULL)
+			return;
+
 	if (devdata->last_send_was_good) {
 		devdata->start_cycles = (unsigned long long)get_cycles();
 		tries = MSGRETRYMAX;
@@ -1145,8 +1055,6 @@ new_message_to_host(void *context, struct diag_channel_event *event)
 		if (!devdata->last_send_was_good) {
 			cur_cycles = (unsigned long long)get_cycles();
 			elapsed_cycles = cur_cycles - devdata->start_cycles;
-			INFODEV(devdata->name, "Was blocked, but now is going again dropped_msg_cnt=%u, elapsed_cycles=%llu\n",
-				devdata->dropped_msg_cnt, elapsed_cycles);
 		}
 		devdata->dropped_msg_cnt = 0;
 		devdata->last_send_was_good = TRUE;
@@ -1169,17 +1077,11 @@ host_side_disappeared(struct visordiag_devdata *devdata)
 static void
 first_file_opened(struct visordiag_filedata *filedata)
 {
-	struct visordiag_devdata *devdata = filedata->devdata;
-
-	INFODEV(devdata->name, "lights on");
 }
 
 static void
 last_file_closed(struct visordiag_filedata *filedata)
 {
-	struct visordiag_devdata *devdata = filedata->devdata;
-
-	INFODEV(devdata->name, "lights off");
 }
 
 static int
@@ -1193,18 +1095,12 @@ visordiag_file_open(struct inode *inode, struct file *file)
 
 	list_for_each_entry(devdata, &list_all_devices, list_all) {
 		if (MAJOR(devdata->devt) == major_number) {
-			DEBUGDEV(devdata->name,
-				 "%s minor=%d", __func__, minor_number);
 			if (minor_number >= NCHARDEVICES) {
-				ERRDRV("minor number is too large: (status=%d)\n",
-				       -ENODEV);
 				rc = -ENODEV;
 				goto away;
 			}
 			filedata = create_file(devdata, minor_number);
 			if (filedata == NULL) {
-				ERRDRV("cannot alloc file data: (status=%d)\n",
-				       -ENOMEM);
 				rc = -ENOMEM;
 				goto away;
 			}
@@ -1224,15 +1120,9 @@ visordiag_file_open(struct inode *inode, struct file *file)
 	}
 	rc = -ENODEV;
 away:
-	if (rc < 0) {
-		ERRDRV("%s minor=%d failed", __func__, minor_number);
-	} else {
-		if (file->f_mode & FMODE_WRITE) {
-			INFODEV(devdata->name,
-				"syslogd opened visordiag.%d - disabling primitive message logging",
-				minor_number);
-			SVLOG_ENABLE(0);
-		}
+	if (rc >= 0) {
+		if (file->f_mode & FMODE_WRITE)
+				SVLOG_ENABLE(0);
 	}
 	return rc;
 }
@@ -1245,17 +1135,12 @@ visordiag_file_release(struct inode *inode, struct file *file)
 	    (struct visordiag_filedata *)(file->private_data);
 	struct visordiag_devdata *devdata = NULL;
 
-	if (filedata == NULL) {
-		ERRDRV("unknown file: (status=-1)\n");
-		goto away;
-	}
-	devdata = filedata->devdata;
-	if (devdata == NULL) {
-		ERRDRV("unknown device: (status=-1)\n");
-		goto away;
-	}
+	if (filedata == NULL)
+			goto away;
 
-	DEBUGDEV(devdata->name, "%s", __func__);
+	devdata = filedata->devdata;
+	if (devdata == NULL)
+			goto away;
 
 	/* If this is the Platform Diagnostic device then write a zero
 	 * length record which will be used as an indication of end-of-file.
@@ -1277,9 +1162,6 @@ visordiag_file_release(struct inode *inode, struct file *file)
 away:
 	if (rc >= 0) {
 		if (file->f_mode & FMODE_WRITE) {
-			INFODEV(devdata->name,
-				"syslogd closed visordiag.%d - enabling primitive message logging",
-				iminor(inode));
 			SVLOG_ENABLE(1);
 		}
 	}
@@ -1324,35 +1206,30 @@ visordiag_file_write_guts(struct file *file,
 			  const char __user *buf,
 			  size_t count, loff_t *ppos, int default_pri)
 {
-	int rc = -1, i = 0;
+	int i = 0;
 	struct visordiag_filedata *filedata =
 	    (struct visordiag_filedata *)(file->private_data);
 	struct visordiag_devdata *devdata = NULL;
 	struct diag_channel_event event;
 
-	if (filedata == NULL) {
-		ERRDRV("unknown file\n");
-		goto away;
-	}
+	if (filedata == NULL)
+			return -1;
+
 	devdata = filedata->devdata;
-	if (devdata == NULL) {
-		ERRDRV("unknown device\n");
-		goto away;
-	}
-	DEBUGDEV(devdata->name, "%s", __func__);
+	if (devdata == NULL)
+			return -1;
+
 	if (count > (NFILEWRITEBYTESTOBUFFER - filedata->nbuf))
 		count = NFILEWRITEBYTESTOBUFFER - filedata->nbuf;
-	if (copy_from_user(filedata->buf + filedata->nbuf, buf, count)) {
-		rc = -EFAULT;
-		goto away;
-	}
+	if (copy_from_user(filedata->buf + filedata->nbuf, buf, count))
+		return -EFAULT;
+
 	devdata->counter.umode_bytes_in += count;
 	filedata->nbuf += count;
 	down_read(&devdata->lock_visor_dev);
 	if (devdata->dev == NULL) {	/* host channel is gone */
 		up_read(&devdata->lock_visor_dev);
-		rc = 0;	/* eof */
-		goto away;
+		return 0;
 	}
 	i = 0;
 	while (i < filedata->nbuf) {
@@ -1379,11 +1256,7 @@ visordiag_file_write_guts(struct file *file,
 	filedata->nbuf -= i;
 
 	up_read(&devdata->lock_visor_dev);
-
-	rc = count;
-away:
-	DEBUGDEV(devdata->name, "%s wrote %d", __func__, count);
-	return rc;
+	return count;
 }
 
 /*
@@ -1411,33 +1284,22 @@ visordiag_file_xfer(struct file *file, const char __user *buf,
 	int slots_avail, max_slots;
 	BOOL timed_out = FALSE;
 
-	if (filedata == NULL) {
-		ERRDRV("unknown file: (status=%d)\n", rc);
-		goto away;
-	}
+	if (filedata == NULL)
+			goto away;
+
 	devdata = filedata->devdata;
-	if (devdata == NULL) {
-		ERRDRV("unknown device: (status=%d)\n", rc);
-		goto away;
-	}
-	DEBUGDEV(devdata->name, "%s", __func__);
+	if (devdata == NULL)
+			goto away;
 
 	/* If data exceeds the size of the buffer (should never
 	 * happen) return an error.
 	 */
-	if (count > sizeof(event.additional_info)) {
-		ERRDEV(devdata->name,
-		       "%s failed. Num of chars (%d) exceeded limit of %d.\n",
-		       __func__, (int)count,
-		       (int)sizeof(event.additional_info));
-		rc = -EFAULT;
-		goto away;
-	}
+	if (count > sizeof(event.additional_info))
+			goto away;
 
 	devdata->counter.umode_bytes_in += count;
 	down_read(&devdata->lock_visor_dev);
 	if (devdata->dev == NULL) {	/* host channel is gone */
-		INFODEV(devdata->name, "Host channel is gone.");
 		up_read(&devdata->lock_visor_dev);
 		rc = 0;	/* eof */
 		goto away;
@@ -1452,8 +1314,6 @@ visordiag_file_xfer(struct file *file, const char __user *buf,
 					 * device. Zero value marks end-of-file
 					 * being transferred. */
 	if (copy_from_user(event.additional_info, buf, count)) {
-		ERRDEV(devdata->name, "%s failed. copy_from_user call returned non-zero result.\n",
-		       __func__);
 		up_read(&devdata->lock_visor_dev);
 		rc = -EFAULT;
 		goto away;
@@ -1490,14 +1350,11 @@ visordiag_file_xfer(struct file *file, const char __user *buf,
 					devdata->dev->visorchannel,
 					devdata->xmitqueue);
 		}
-		INFODEV(devdata->name, "Throttling of msgs going to diag channel occurred.  throttled_count = %d, timed_out=%d.",
-			throttled_count, timed_out);
 	}
 
 	if (!timed_out) {
 		new_message_to_host(devdata, &event);
 	} else {
-		INFODEV(devdata->name, "File transfer has timed out.");
 		up_read(&devdata->lock_visor_dev);
 		rc = -EAGAIN;
 		goto away;
@@ -1507,15 +1364,12 @@ visordiag_file_xfer(struct file *file, const char __user *buf,
 away:
 	if (rc > 0)
 		filedata->offset += rc;
-	DEBUGDEV(devdata->name, "%s wrote %d", __func__, rc);
 	return rc;
 }
 
 static int
 visordiag_mmap(struct file *file, struct vm_area_struct *vma)
 {
-	int rc;
-
 	ulong offset = vma->vm_pgoff << PAGE_SHIFT;
 	ulong phys_addr = 0;
 	pgprot_t pgprot;
@@ -1523,29 +1377,18 @@ visordiag_mmap(struct file *file, struct vm_area_struct *vma)
 	    (file->private_data);
 	struct visordiag_devdata *devdata = NULL;
 
-	if (filedata == NULL) {
-		rc = -1;
-		ERRDRV("unknown file: (status=%d)\n", rc);
-		goto away;
-	}
+	if (filedata == NULL)
+			return -1;
+
 	devdata = filedata->devdata;
-	if (devdata == NULL) {
-		rc = -1;
-		ERRDRV("unknown device: (status=%d)\n", rc);
-		goto away;
-	}
+	if (devdata == NULL)
+			return -1;
 
-	if (pgprot_val(vma->vm_page_prot) != pgprot_val(PAGE_READONLY)) {
-		rc = -EACCES;
-		ERRDRV("unknown device: (status=%d)\n", rc);
-		goto away;
-	}
+	if (pgprot_val(vma->vm_page_prot) != pgprot_val(PAGE_READONLY))
+			return -EACCES;
 
-	if (offset & (PAGE_SIZE - 1)) {
-		rc = -ENXIO;
-		ERRDRV("need aligned mmap offset: (status=%d)\n", rc);
-		goto away;
-	}
+	if (offset & (PAGE_SIZE - 1))
+			return -ENXIO;
 
 	switch (offset) {
 	case VISORDIAG_MMAP_CHANNEL_OFF:
@@ -1561,20 +1404,14 @@ visordiag_mmap(struct file *file, struct vm_area_struct *vma)
 				       phys_addr >> PAGE_SHIFT,
 				       vma->vm_end - vma->vm_start,
 				       vma->vm_page_prot)) {
-			rc = -EAGAIN;
-			ERRDRV("io_remap_pfn_range failed: (status=%d)\n", rc);
-			goto away;
+			return -EAGAIN;
 		}
 		break;
 	default:
-		rc = -ENOSYS;
-		ERRDRV("invalid offset: (status=%d)\n", rc);
-		goto away;
+		return -ENOSYS;
 	}
 
-	rc = 0;
-away:
-	return rc;
+	return 0;
 }
 
 module_param_named(channeladdress, visordiag_channeladdress,
diff --git a/drivers/staging/unisys/visorhid/Kconfig b/drivers/staging/unisys/visorhid/Kconfig
new file mode 100644
index 0000000..e41007b
--- /dev/null
+++ b/drivers/staging/unisys/visorhid/Kconfig
@@ -0,0 +1,10 @@
+#
+# Unisys visorhid configuration
+#
+
+config UNISYS_VISORHID
+	tristate "Unisys visorhid driver"
+	depends on UNISYSSPAR && UNISYS_VISORUTIL && UNISYS_VISORCHANNEL && UNISYS_VISORBUS && FB
+	---help---
+	If you say Y here, you will enable the Unisys visorhid driver.
+
diff --git a/drivers/staging/unisys/visorhid/Makefile b/drivers/staging/unisys/visorhid/Makefile
new file mode 100644
index 0000000..2d17fd2
--- /dev/null
+++ b/drivers/staging/unisys/visorhid/Makefile
@@ -0,0 +1,14 @@
+#
+# Makefile for Unisys visorhid
+#
+
+obj-$(CONFIG_UNISYS_VISORHID)	+= visorhid.o
+
+ccflags-y += -Idrivers/staging/unisys/include
+ccflags-y += -Idrivers/staging/unisys/visorutil
+ccflags-y += -Idrivers/staging/unisys/visorbus
+ccflags-y += -Idrivers/staging/unisys/visorchannel
+ccflags-y += -Idrivers/staging/unisys/common-spar/include
+ccflags-y += -Idrivers/staging/unisys/common-spar/include/channels
+ccflags-y += -DCONFIG_SPAR_GUEST -DGUESTDRIVERBUILD -DNOAUTOVERSION
+
diff --git a/drivers/staging/unisys/visorhid/globals.h b/drivers/staging/unisys/visorhid/globals.h
new file mode 100644
index 0000000..1bf7647
--- /dev/null
+++ b/drivers/staging/unisys/visorhid/globals.h
@@ -0,0 +1,24 @@
+/* globals.h
+ *
+ * Copyright (c) 2011 - 2014 UNISYS CORPORATION
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ * NON INFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ */
+
+#include "version.h"
+
+#define MYDRVNAME "visorhid"
+#define MAXDEVICES     16384
+
+extern int visorhid_debug;
+extern int visorhid_debugref;
diff --git a/drivers/staging/unisys/visorhid/visorhid.c b/drivers/staging/unisys/visorhid/visorhid.c
new file mode 100644
index 0000000..52f614c
--- /dev/null
+++ b/drivers/staging/unisys/visorhid/visorhid.c
@@ -0,0 +1,889 @@
+/* visorhid.c
+ *
+ * Copyright (c) 2011 - 2014 UNISYS CORPORATION
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ * NON INFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ */
+
+/* This driver lives in a generic guest Linux partition, and registers to
+ * receive keyboard and mouse channels from the visorbus driver.  It reads
+ * inputs from such channels, and delivers it to the Linux OS in the
+ * standard way the Linux expects for input drivers.
+ */
+
+#include "diagnostics/appos_subsystems.h"
+#include "timskmod.h"
+#include "globals.h"
+#include "visorbus.h"
+#include "visorchannel.h"
+#include "keyboardchannel.h"
+#include "mousechannel.h"
+#include <linux/input.h>
+#include <linux/serio.h>
+#include <linux/fs.h>
+#include <linux/fb.h>
+#include <asm/segment.h>
+#include <linux/uaccess.h>
+#include <linux/buffer_head.h>
+
+#define PIXELS_ACROSS_DEFAULT 800
+#define PIXELS_DOWN_DEFAULT   600
+#define SYSFS_VIRTUALSIZE "/sys/class/graphics/fb0/virtual_size"
+
+static spinlock_t devnopool_lock;
+static void *dev_no_pool; /**< pool to grab device numbers from */
+
+static int visorhid_probe(struct visor_device *dev);
+static void visorhid_remove(struct visor_device *dev);
+static void visorhid_channel_interrupt(struct visor_device *dev);
+static int visorhid_pause(struct visor_device *dev,
+			  VISORBUS_STATE_COMPLETE_FUNC complete_func);
+static int visorhid_resume(struct visor_device *dev,
+			   VISORBUS_STATE_COMPLETE_FUNC complete_func);
+static struct input_dev *register_client_keyboard(void);
+static struct input_dev *register_client_mouse(void);
+static struct input_dev *register_client_wheel(void);
+static void unregister_client_input(struct input_dev *visorinput_dev);
+
+/**  GUIDS for all channel types supported by this driver.
+ */
+static struct visor_channeltype_descriptor visorhid_channel_types[] = {
+	{SPAR_KEYBOARD_CHANNEL_PROTOCOL_UUID, "keyboard",
+	 KEYBOARD_CH_SIZE, KEYBOARD_CH_SIZE},
+	{SPAR_MOUSE_CHANNEL_PROTOCOL_UUID, "mouse",
+	 MOUSE_CH_SIZE, MOUSE_CH_SIZE},
+	{ NULL_UUID_LE, NULL, 0, 0}
+};
+
+/** This is used to tell the visor bus driver which types of visor devices
+ *  we support, and what functions to call when a visor device that we support
+ *  is attached or removed.
+ */
+static struct visor_driver visorhid_driver = {
+	.name = MYDRVNAME,
+	.version = VERSION,
+	.vertag = NULL,
+	.owner = THIS_MODULE,
+	.channel_types = visorhid_channel_types,
+	.probe = visorhid_probe,
+	.remove = visorhid_remove,
+	.channel_interrupt = visorhid_channel_interrupt,
+	.pause = visorhid_pause,
+	.resume = visorhid_resume,
+};
+
+/** This is the private data that we store for each device.
+ *  A pointer to this struct is kept in each "struct device", and can be
+ *  obtained using visor_get_drvdata(dev).
+ */
+struct visorhid_devdata {
+	int devno;
+	struct visor_device *dev;
+	/** lock for dev */
+	struct rw_semaphore lock_visor_dev;
+	char name[99];
+	struct list_head list_all;   /**< link within list_all_devices list */
+	struct kref kref;
+	struct input_dev *visorinput_dev;
+	struct input_dev *visorinput_dev2;
+	BOOL supported_client_device;
+	BOOL paused;
+};
+
+/** List of all visorhid_devdata structs,
+  * linked via the list_all member */
+static LIST_HEAD(list_all_devices);
+static DEFINE_SPINLOCK(lock_all_devices);
+
+#define devdata_put(devdata, why)					\
+	{								\
+		int refcount;						\
+		kref_put(&devdata->kref, devdata_release);		\
+		refcount = atomic_read(&devdata->kref.refcount);	\
+	}
+
+#define devdata_get(deevdata, why)					\
+	{								\
+		int refcount;						\
+		kref_get(&devdata->kref);				\
+		refcount = atomic_read(&devdata->kref.refcount);	\
+	}
+
+/* Borrowed from drivers/input/keyboard/atakbd.c */
+/* This maps 1-byte scancodes to keycodes. */
+static unsigned char visorkbd_keycode[256] = {	/* American layout */
+	[0] = KEY_GRAVE,
+	[1] = KEY_ESC,
+	[2] = KEY_1,
+	[3] = KEY_2,
+	[4] = KEY_3,
+	[5] = KEY_4,
+	[6] = KEY_5,
+	[7] = KEY_6,
+	[8] = KEY_7,
+	[9] = KEY_8,
+	[10] = KEY_9,
+	[11] = KEY_0,
+	[12] = KEY_MINUS,
+	[13] = KEY_EQUAL,
+	[14] = KEY_BACKSPACE,
+	[15] = KEY_TAB,
+	[16] = KEY_Q,
+	[17] = KEY_W,
+	[18] = KEY_E,
+	[19] = KEY_R,
+	[20] = KEY_T,
+	[21] = KEY_Y,
+	[22] = KEY_U,
+	[23] = KEY_I,
+	[24] = KEY_O,
+	[25] = KEY_P,
+	[26] = KEY_LEFTBRACE,
+	[27] = KEY_RIGHTBRACE,
+	[28] = KEY_ENTER,
+	[29] = KEY_LEFTCTRL,
+	[30] = KEY_A,
+	[31] = KEY_S,
+	[32] = KEY_D,
+	[33] = KEY_F,
+	[34] = KEY_G,
+	[35] = KEY_H,
+	[36] = KEY_J,
+	[37] = KEY_K,
+	[38] = KEY_L,
+	[39] = KEY_SEMICOLON,
+	[40] = KEY_APOSTROPHE,
+	[41] = KEY_GRAVE,	/* FIXME, '#' */
+	[42] = KEY_LEFTSHIFT,
+	[43] = KEY_BACKSLASH,	/* FIXME, '~' */
+	[44] = KEY_Z,
+	[45] = KEY_X,
+	[46] = KEY_C,
+	[47] = KEY_V,
+	[48] = KEY_B,
+	[49] = KEY_N,
+	[50] = KEY_M,
+	[51] = KEY_COMMA,
+	[52] = KEY_DOT,
+	[53] = KEY_SLASH,
+	[54] = KEY_RIGHTSHIFT,
+	[55] = KEY_KPASTERISK,
+	[56] = KEY_LEFTALT,
+	[57] = KEY_SPACE,
+	[58] = KEY_CAPSLOCK,
+	[59] = KEY_F1,
+	[60] = KEY_F2,
+	[61] = KEY_F3,
+	[62] = KEY_F4,
+	[63] = KEY_F5,
+	[64] = KEY_F6,
+	[65] = KEY_F7,
+	[66] = KEY_F8,
+	[67] = KEY_F9,
+	[68] = KEY_F10,
+	[69] = KEY_NUMLOCK,
+	[70] = KEY_SCROLLLOCK,
+	[71] = KEY_KP7,
+	[72] = KEY_KP8,
+	[73] = KEY_KP9,
+	[74] = KEY_KPMINUS,
+	[75] = KEY_KP4,
+	[76] = KEY_KP5,
+	[77] = KEY_KP6,
+	[78] = KEY_KPPLUS,
+	[79] = KEY_KP1,
+	[80] = KEY_KP2,
+	[81] = KEY_KP3,
+	[82] = KEY_KP0,
+	[83] = KEY_KPDOT,
+	[87] = KEY_F11,
+	[88] = KEY_F12,
+	[90] = KEY_KPLEFTPAREN,
+	[91] = KEY_KPRIGHTPAREN,
+	[92] = KEY_KPASTERISK,	/* FIXME */
+	[93] = KEY_KPASTERISK,
+	[94] = KEY_KPPLUS,
+	[95] = KEY_HELP,
+	[96] = KEY_KPENTER,
+	[97] = KEY_RIGHTCTRL,
+	[98] = KEY_KPSLASH,
+	[99] = KEY_KPLEFTPAREN,
+	[100] = KEY_KPRIGHTPAREN,
+	[101] = KEY_KPSLASH,
+	[102] = KEY_HOME,
+	[103] = KEY_UP,
+	[104] = KEY_PAGEUP,
+	[105] = KEY_LEFT,
+	[106] = KEY_RIGHT,
+	[107] = KEY_END,
+	[108] = KEY_DOWN,
+	[109] = KEY_PAGEDOWN,
+	[110] = KEY_INSERT,
+	[111] = KEY_DELETE,
+	[112] = KEY_MACRO,
+	[113] = KEY_MUTE
+};
+
+/* This maps the <xx> in extended scancodes of the form "0xE0 <xx>" into */
+/* keycodes. */
+static unsigned char ext_keycode[256] = {
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x00 */
+	0, 0, 0, 0, 0, 0, 0, 0,	/* 0x10 */
+	0, 0, 0, 0, KEY_KPENTER, KEY_RIGHTCTRL, 0, 0,	/* 0x18 */
+	0, 0, 0, 0, 0, 0, 0, 0,	/* 0x20 */
+	KEY_RIGHTALT, 0, 0, 0, 0, 0, 0, 0,	/* 0x28 */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x30 */
+	0, 0, 0, 0, 0, 0, 0, KEY_HOME,	/* 0x40 */
+	KEY_UP, KEY_PAGEUP, 0, KEY_LEFT, 0, KEY_RIGHT, 0, KEY_END, /* 0x48 */
+	KEY_DOWN, KEY_PAGEDOWN, KEY_INSERT, KEY_DELETE, 0, 0, 0, 0, /* 0x50 */
+	0, 0, 0, 0, 0, 0, 0, 0,	/* 0x58 */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x60 */
+	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0x70 */
+};
+
+static struct visorhid_devdata *
+devdata_create(struct visor_device *dev)
+{
+	void *rc = NULL;
+	struct visorhid_devdata *devdata = NULL;
+	int devno = -1;
+	uuid_le guid;
+
+	guid = visorchannel_get_uuid(dev->visorchannel);
+	devdata = kmalloc(sizeof(*devdata),
+			  GFP_KERNEL | __GFP_NORETRY);
+	if (!devdata)
+			goto cleanups;
+
+	memset(devdata, '\0', sizeof(struct visorhid_devdata));
+	spin_lock(&devnopool_lock);
+	devno = find_first_zero_bit(dev_no_pool, MAXDEVICES);
+	set_bit(devno, dev_no_pool);
+	spin_unlock(&devnopool_lock);
+	if (devno == MAXDEVICES)
+		devno = -1;
+	if (devno < 0)
+			goto cleanups;
+	devdata->devno = devno;
+	devdata->dev = dev;
+	strncpy(devdata->name, dev_name(&dev->device), sizeof(devdata->name));
+
+	/* This is an input device in a client guest partition,
+	 * so we need to create whatever gizmos are necessary to
+	 * deliver our inputs to the guest OS. */
+	if (memcmp(&guid, &spar_keyboard_channel_protocol_uuid,
+		   sizeof(guid)) == 0) {
+		devdata->visorinput_dev = register_client_keyboard();
+		if (!devdata->visorinput_dev)
+				goto cleanups;
+		devdata->supported_client_device = TRUE;
+	} else if (memcmp(&guid, &spar_mouse_channel_protocol_uuid,
+			  sizeof(guid)) == 0) {
+		devdata->visorinput_dev = register_client_mouse();
+		if (!devdata->visorinput_dev)
+				goto cleanups;
+		devdata->visorinput_dev2 = register_client_wheel();
+		if (!devdata->visorinput_dev2)
+				goto cleanups;
+		devdata->supported_client_device = TRUE;
+	}
+
+	init_rwsem(&devdata->lock_visor_dev);
+	kref_init(&devdata->kref);
+
+	spin_lock(&lock_all_devices);
+	list_add_tail(&devdata->list_all, &list_all_devices);
+	spin_unlock(&lock_all_devices);
+
+	rc = devdata;
+cleanups:
+	if (!rc) {
+		if (devno >= 0) {
+			spin_lock(&devnopool_lock);
+			clear_bit(devno, dev_no_pool);
+			spin_unlock(&devnopool_lock);
+		}
+		if (devdata) {
+			if (devdata->visorinput_dev) {
+				unregister_client_input
+				    (devdata->visorinput_dev);
+				devdata->visorinput_dev = NULL;
+			}
+			if (devdata->visorinput_dev2) {
+				unregister_client_input
+				    (devdata->visorinput_dev2);
+				devdata->visorinput_dev2 = NULL;
+			}
+			kfree(devdata);
+		}
+	}
+	return rc;
+}
+
+static void
+devdata_release(struct kref *mykref)
+{
+	struct visorhid_devdata *devdata =
+	    container_of(mykref, struct visorhid_devdata, kref);
+	spin_lock(&devnopool_lock);
+	clear_bit(devdata->devno, dev_no_pool);
+	spin_unlock(&devnopool_lock);
+	spin_lock(&lock_all_devices);
+	list_del(&devdata->list_all);
+	spin_unlock(&lock_all_devices);
+}
+
+static int
+visorhid_probe(struct visor_device *dev)
+{
+	int rc = 0;
+	struct visorhid_devdata *devdata = NULL;
+	uuid_le guid;
+
+	devdata = devdata_create(dev);
+	if (!devdata) {
+		rc = -1;
+		goto cleanups;
+	}
+	visor_set_drvdata(dev, devdata);
+	guid = visorchannel_get_uuid(dev->visorchannel);
+	if (memcmp(&guid, &spar_mouse_channel_protocol_uuid,
+		   sizeof(guid)) != 0 &&
+		   memcmp(&guid, &spar_keyboard_channel_protocol_uuid,
+			  sizeof(guid)) != 0) {
+		rc = -1;
+		goto cleanups;
+	}
+
+	if (devdata->supported_client_device)
+		visorbus_enable_channel_interrupts(dev);
+
+cleanups:
+	if (rc < 0) {
+		if (devdata)
+			devdata_put(devdata, "existence");
+	}
+	return rc;
+}
+
+static void
+host_side_disappeared(struct visorhid_devdata *devdata)
+{
+	down_write(&devdata->lock_visor_dev);
+	sprintf(devdata->name, "<dev#%d-history>", devdata->devno);
+	devdata->dev = NULL;	/* indicate device destroyed */
+	up_write(&devdata->lock_visor_dev);
+}
+
+static void
+visorhid_remove(struct visor_device *dev)
+{
+	struct visorhid_devdata *devdata = visor_get_drvdata(dev);
+
+	if (!devdata)
+			return;
+
+	visor_set_drvdata(dev, NULL);
+	host_side_disappeared(devdata);
+	unregister_client_input(devdata->visorinput_dev);
+	devdata->visorinput_dev = NULL;
+	unregister_client_input(devdata->visorinput_dev2);
+	devdata->visorinput_dev2 = NULL;
+	devdata_put(devdata, "existence");
+}
+
+static void
+visorhid_cleanup_guts(void)
+{
+	visorbus_unregister_visor_driver(&visorhid_driver);
+		kfree(dev_no_pool);
+		dev_no_pool = NULL;
+}
+
+static void
+unregister_client_input(struct input_dev *visorinput_dev)
+{
+	if (visorinput_dev)
+			input_unregister_device(visorinput_dev);
+}
+
+/* register_client_keyboard() initializes and returns a Linux gizmo that we
+ * can use to deliver keyboard inputs to Linux.  We of course do this when
+ * we see keyboard inputs coming in on a keyboard channel.
+ */
+static struct input_dev *
+register_client_keyboard(void)
+{
+	int i, error;
+	struct input_dev *visorinput_dev = NULL;
+
+	visorinput_dev = input_allocate_device();
+	if (!visorinput_dev)
+			return NULL;
+
+	visorinput_dev->name = "visor Keyboard";
+	visorinput_dev->phys = "visorkbd/input0";
+	visorinput_dev->id.bustype = BUS_HOST;
+	visorinput_dev->id.vendor = 0x0001;
+	visorinput_dev->id.product = 0x0001;
+	visorinput_dev->id.version = 0x0100;
+
+	visorinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_REP)
+	    | BIT_MASK(EV_LED);
+	visorinput_dev->ledbit[0] = BIT_MASK(LED_CAPSL)
+	    | BIT_MASK(LED_SCROLLL) | BIT_MASK(LED_NUML);
+	visorinput_dev->keycode = visorkbd_keycode;
+	visorinput_dev->keycodesize = sizeof(unsigned char);
+	visorinput_dev->keycodemax = ARRAY_SIZE(visorkbd_keycode);
+
+	for (i = 1; i < ARRAY_SIZE(visorkbd_keycode); i++)
+		set_bit(visorkbd_keycode[i], visorinput_dev->keybit);
+
+	error = input_register_device(visorinput_dev);
+	if (error) {
+		input_free_device(visorinput_dev);
+		return NULL;
+	}
+	return visorinput_dev;
+}
+
+/* register_client_mouse() initializes and returns a Linux gizmo that we
+ * can use to deliver mouse inputs to Linux.  We of course do this when
+ * we see mouse inputs coming in on a mouse channel.
+ *
+ * Note that in order to use the mouse in X, it needs to be declared like
+ * this in xorg.conf:
+ *
+ *    Section "InputDevice"
+ *      Driver       "evdev"
+ *      Identifier   "sPAR virtual mouse"
+ *      Option       "Device" "/dev/input/event1"
+ *      Option       "AccelerationProfile" "-1"
+ *      Option       "AccelerationScheme" "none"
+ *      Option       "CorePointer"
+ *    EndSection
+ *
+ * Then reference that from your ServerLayout section, like this:
+ *
+ *    InputDevice  "sPAR virtual mouse" "CoreMouse"
+ *
+ * This command can be used to determine which /dev/input/event* device
+ * is the sPAR mouse:
+ *
+ *    udevadm info --attribute-walk --name=/dev/input/event*
+ */
+static struct input_dev *
+register_client_mouse(void)
+{
+	int error;
+	struct input_dev *visorinput_dev = NULL;
+	int xres, yres;
+	struct fb_info *fb0;
+
+	visorinput_dev = input_allocate_device();
+	if (!visorinput_dev)
+			return NULL;
+
+	visorinput_dev->name = "visor Mouse";
+	visorinput_dev->phys = "visormou/input0";
+	visorinput_dev->id.bustype = BUS_HOST;
+	visorinput_dev->id.vendor = 0x0001;
+	visorinput_dev->id.product = 0x0001;
+	visorinput_dev->id.version = 0x0100;
+
+	visorinput_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	set_bit(BTN_LEFT, visorinput_dev->keybit);
+	set_bit(BTN_RIGHT, visorinput_dev->keybit);
+	set_bit(BTN_MIDDLE, visorinput_dev->keybit);
+
+	if (registered_fb[0]) {
+		fb0 = registered_fb[0];
+		xres = fb0->var.xres_virtual;
+		yres = fb0->var.yres_virtual;
+	} else {
+		xres = PIXELS_ACROSS_DEFAULT;
+		yres = PIXELS_DOWN_DEFAULT;
+	}
+	input_set_abs_params(visorinput_dev, ABS_X, 0, xres, 0, 0);
+	input_set_abs_params(visorinput_dev, ABS_Y, 0, yres, 0, 0);
+
+	error = input_register_device(visorinput_dev);
+	if (error) {
+		input_free_device(visorinput_dev);
+		return NULL;
+	}
+
+	/* Sending top-left and bottom-right positions is ABSOLUTELY
+	* REQUIRED if we want X to move the mouse to the exact points
+	* we tell it.  I have NO IDEA why.
+	*/
+	input_report_abs(visorinput_dev, ABS_X, 0);
+	input_report_abs(visorinput_dev, ABS_Y, 0);
+	input_sync(visorinput_dev);
+	input_report_abs(visorinput_dev, ABS_X, xres - 1);
+	input_report_abs(visorinput_dev, ABS_Y, yres - 1);
+	input_sync(visorinput_dev);
+
+	return visorinput_dev;
+}
+
+/* register_client_wheel() initializes and returns a Linux gizmo that we
+ * can use to deliver mouse wheel inputs to Linux.  We of course do this when
+ * we see wheel inputs coming in on a mouse channel.  It would be NICE to be
+ * able to report wheel events on the mouse device, but X can't deal with a
+ * single device that has both absolute (X and Y) and relative (wheel) axes.
+ * That's why we create 2 devices for Linux: 1 mouse device and 1 wheel device.
+ *
+ * Note that in order to use the wheel in X, it needs to be declared like
+ * this in xorg.conf:
+ *
+ *    Section "InputDevice"
+ *      Driver       "evdev"
+ *      Identifier   "sPAR virtual wheel"
+ *      Option       "Device" "/dev/input/event4"
+ *    EndSection
+ *
+ * Then reference that from your ServerLayout section, like this:
+ *
+ *    InputDevice  "sPAR virtual wheel"
+ *
+ * This command can be used to determine which /dev/input/event* device
+ * is the sPAR wheel:
+ *
+ *    udevadm info --attribute-walk --name=/dev/input/event*
+ */
+static struct input_dev *
+register_client_wheel(void)
+{
+	int error;
+	struct input_dev *visorinput_dev = NULL;
+
+	visorinput_dev = input_allocate_device();
+	if (!visorinput_dev)
+		return NULL;
+
+	visorinput_dev->name = "visor Wheel";
+	visorinput_dev->phys = "visorwhl/input0";
+	visorinput_dev->id.bustype = BUS_HOST;
+	visorinput_dev->id.vendor = 0x0001;
+	visorinput_dev->id.product = 0x0001;
+	visorinput_dev->id.version = 0x0100;
+
+	/* We need to lie a little to prevent the evdev driver "Don't
+	* know how to use device" error.  (evdev erroneously thinks
+	* that a device without an X and Y axis is useless.)
+	*/
+	visorinput_dev->evbit[0] = BIT_MASK(EV_REL)
+	    | /*lie */ BIT_MASK(EV_KEY)	/*lie */
+	    ;
+	visorinput_dev->relbit[0] = BIT_MASK(REL_WHEEL)
+	    | /*lie */ BIT_MASK(REL_X)	/*lie */
+	    | /*lie */ BIT_MASK(REL_Y)	/*lie */
+	    ;
+	set_bit(BTN_LEFT, visorinput_dev->keybit);	/*lie */
+	set_bit(BTN_RIGHT, visorinput_dev->keybit);	/*lie */
+	set_bit(BTN_MIDDLE, visorinput_dev->keybit);	/*lie */
+
+	error = input_register_device(visorinput_dev);
+	if (error) {
+		input_free_device(visorinput_dev);
+		return NULL;
+	}
+	return visorinput_dev;
+}
+
+static void
+do_key(struct input_dev *inpt, int keycode, int down)
+{
+	input_report_key(inpt, keycode, down);
+}
+
+/* Make it so the current locking state of the locking key indicated by
+ * <keycode> is as indicated by <desired_state> (1=locked, 0=unlocked).
+ */
+static void
+handle_locking_key(struct input_dev *visorinput_dev,
+		   int keycode, int desired_state)
+{
+	int led;
+	char *sled;
+
+	switch (keycode) {
+	case KEY_CAPSLOCK:
+		led = LED_CAPSL;
+		sled = "CAP";
+		break;
+	case KEY_SCROLLLOCK:
+		led = LED_SCROLLL;
+		sled = "SCR";
+		break;
+	case KEY_NUMLOCK:
+		led = LED_NUML;
+		sled = "NUM";
+		break;
+	default:
+		led = -1;
+		break;
+	}
+	if (led >= 0) {
+		int old_state = (test_bit(led, visorinput_dev->led) != 0);
+
+		if (old_state != desired_state) {
+			do_key(visorinput_dev, keycode, 1);
+			do_key(visorinput_dev, keycode, 0);
+			input_sync(visorinput_dev);
+			__change_bit(led, visorinput_dev->led);
+		}
+	}
+}
+
+/* <scancode> is either a 1-byte scancode, or an extended 16-bit scancode
+ * with 0xE0 in the low byte and the extended scancode value in the next
+ * higher byte.
+ */
+static int
+scancode_to_keycode(int scancode)
+{
+	int keycode;
+
+	if (scancode > 0xff)
+		keycode = ext_keycode[(scancode >> 8) & 0xff];
+	else
+		keycode = visorkbd_keycode[scancode];
+	return keycode;
+}
+
+static int
+calc_button(int x)
+{
+	switch (x) {
+	case 1:
+		return BTN_LEFT;
+	case 2:
+		return BTN_MIDDLE;
+	case 3:
+		return BTN_RIGHT;
+	default:
+		return -1;
+	}
+}
+
+/* This is used only when this driver is active as an input driver in the
+ * client guest partition.  It is called periodically so we can obtain inputs
+ * from the channel, and deliver them to the guest OS.
+ */
+static void
+visorhid_channel_interrupt(struct visor_device *dev)
+{
+	ULTRA_INPUTREPORT r;
+	int scancode, keycode;
+	struct input_dev *visorinput_dev;
+	struct input_dev *visorinput_dev2;
+	int xmotion, ymotion, zmotion, button;
+	int i;
+	BOOL locked = FALSE;
+
+	struct visorhid_devdata *devdata = visor_get_drvdata(dev);
+
+	if (!devdata)
+			goto cleanups;
+
+	down_write(&devdata->lock_visor_dev);
+	locked = TRUE;
+	if (devdata->paused) /* don't touch device/channel when paused */
+			goto cleanups;
+
+	visorinput_dev = devdata->visorinput_dev;
+	if (!visorinput_dev)
+			goto cleanups;
+
+	visorinput_dev2 = devdata->visorinput_dev2;
+	while (visorchannel_signalremove(dev->visorchannel, 0, &r)) {
+		scancode = r.activity.arg1;
+		keycode = scancode_to_keycode(scancode);
+		switch (r.activity.action) {
+		case inputAction_keyDown:
+			do_key(visorinput_dev, keycode, 1);
+			input_sync(visorinput_dev);
+			break;
+		case inputAction_keyUp:
+			do_key(visorinput_dev, keycode, 0);
+			input_sync(visorinput_dev);
+			break;
+		case inputAction_keyDownUp:
+			do_key(visorinput_dev, keycode, 1);
+			do_key(visorinput_dev, keycode, 0);
+			input_sync(visorinput_dev);
+			break;
+		case inputAction_setLockingKeyState:
+			handle_locking_key(visorinput_dev, keycode,
+					   r.activity.arg2);
+			break;
+		case inputAction_xyMotion:
+			xmotion = r.activity.arg1;
+			ymotion = r.activity.arg2;
+			input_report_abs(visorinput_dev, ABS_X, xmotion);
+			input_report_abs(visorinput_dev, ABS_Y, ymotion);
+			input_sync(visorinput_dev);
+			break;
+		case inputAction_mouseButtonDown:
+			button = calc_button(r.activity.arg1);
+			if (button < 0)
+				break;
+			input_report_key(visorinput_dev, button, 1);
+			input_sync(visorinput_dev);
+			break;
+		case inputAction_mouseButtonUp:
+			button = calc_button(r.activity.arg1);
+			if (button < 0)
+				break;
+			input_report_key(visorinput_dev, button, 0);
+			input_sync(visorinput_dev);
+			break;
+		case inputAction_mouseButtonClick:
+			button = calc_button(r.activity.arg1);
+			if (button < 0)
+				break;
+			input_report_key(visorinput_dev, button, 1);
+
+			input_sync(visorinput_dev);
+			input_report_key(visorinput_dev, button, 0);
+			input_sync(visorinput_dev);
+			break;
+		case inputAction_mouseButtonDclick:
+			button = calc_button(r.activity.arg1);
+			if (button < 0)
+				break;
+			for (i = 0; i < 2; i++) {
+				input_report_key(visorinput_dev, button, 1);
+				input_sync(visorinput_dev);
+				input_report_key(visorinput_dev, button, 0);
+				input_sync(visorinput_dev);
+			}
+			break;
+		case inputAction_wheelRotateAway:
+			if (!visorinput_dev2)
+					goto cleanups;
+			zmotion = r.activity.arg1;
+			input_report_rel(visorinput_dev2, REL_WHEEL, 1);
+			input_sync(visorinput_dev2);
+			break;
+		case inputAction_wheelRotateToward:
+			if (!visorinput_dev2)
+					goto cleanups;
+			zmotion = r.activity.arg1;
+			input_report_rel(visorinput_dev2, REL_WHEEL, -1);
+			input_sync(visorinput_dev2);
+			break;
+		}
+	}
+
+cleanups:
+	if (locked) {
+		up_write(&devdata->lock_visor_dev);
+		locked = FALSE;
+	}
+}
+
+static int
+visorhid_pause(struct visor_device *dev,
+	       VISORBUS_STATE_COMPLETE_FUNC complete_func)
+{
+	BOOL locked = FALSE;
+	int rc = -1;
+	struct visorhid_devdata *devdata = visor_get_drvdata(dev);
+
+	if (!devdata)
+			goto cleanups;
+
+	down_write(&devdata->lock_visor_dev);
+	locked = TRUE;
+	if (devdata->paused)
+			goto cleanups;
+	/* SLEEP(5);  // test */
+	devdata->paused = TRUE;
+	complete_func(dev, 0);
+	rc = 0;
+cleanups:
+	if (locked) {
+		up_write(&devdata->lock_visor_dev);
+		locked = FALSE;
+	}
+	return rc;
+}
+
+static int
+visorhid_resume(struct visor_device *dev,
+		VISORBUS_STATE_COMPLETE_FUNC complete_func)
+{
+	BOOL locked = FALSE;
+	int rc = -1;
+	struct visorhid_devdata *devdata = visor_get_drvdata(dev);
+
+	if (!devdata)
+			goto cleanups;
+	down_write(&devdata->lock_visor_dev);
+	locked = TRUE;
+	if (!devdata->paused)
+			goto cleanups;
+	devdata->paused = FALSE;
+	complete_func(dev, 0);
+	rc = 0;
+cleanups:
+	if (locked) {
+		up_write(&devdata->lock_visor_dev);
+		locked = FALSE;
+	}
+	return rc;
+}
+
+static int
+visorhid_init(void)
+{
+	int rc = 0;
+
+	spin_lock_init(&devnopool_lock);
+	dev_no_pool = kzalloc(BITS_TO_LONGS(MAXDEVICES), GFP_KERNEL);
+	if (!dev_no_pool) {
+		rc = -1;
+		goto cleanups;
+	}
+	visorbus_register_visor_driver(&visorhid_driver);
+
+cleanups:
+	if (rc < 0)
+		visorhid_cleanup_guts();
+	return rc;
+}
+
+static void
+visorhid_cleanup(void)
+{
+	visorhid_cleanup_guts();
+}
+
+module_param_named(debug, visorhid_debug, int, S_IRUGO);
+MODULE_PARM_DESC(visorhid_debug, "1 to debug");
+int visorhid_debug = 0;
+
+module_param_named(debugref, visorhid_debugref, int, S_IRUGO);
+MODULE_PARM_DESC(visorhid_debugref, "1 to debug reference counts");
+int visorhid_debugref = 0;
+
+module_init(visorhid_init);
+module_exit(visorhid_cleanup);
+
+MODULE_AUTHOR("Unisys");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sPAR human input driver for guest Linux: ver " VERSION);
+MODULE_VERSION(VERSION);
diff --git a/drivers/staging/unisys/visornic/Kconfig b/drivers/staging/unisys/visornic/Kconfig
new file mode 100644
index 0000000..32541fb
--- /dev/null
+++ b/drivers/staging/unisys/visornic/Kconfig
@@ -0,0 +1,10 @@
+#
+# Unisys visornic configuration
+#
+
+config UNISYS_VISORNIC
+	tristate "Unisys visornic driver"
+	depends on UNISYSSPAR && UNISYS_VISORUTIL && UNISYS_VISORCHANNEL && UNISYS_VISORCHIPSET && UNISYS_VISORBUS
+	---help---
+	If you say Y here, you will enable the Unisys visornic driver.
+
diff --git a/drivers/staging/unisys/visornic/Makefile b/drivers/staging/unisys/visornic/Makefile
new file mode 100644
index 0000000..2621d37
--- /dev/null
+++ b/drivers/staging/unisys/visornic/Makefile
@@ -0,0 +1,16 @@
+#
+# Makefile for Unisys channel
+#
+
+obj-$(CONFIG_UNISYS_VISORNIC)	+= visornic.o
+
+visornic-y := visornic_main.o
+
+ccflags-y += -Idrivers/staging/unisys/include
+ccflags-y += -Idrivers/staging/unisys/visorutil
+ccflags-y += -Idrivers/staging/unisys/visorbus
+ccflags-y += -Idrivers/staging/unisys/visorchannel
+ccflags-y += -Idrivers/staging/unisys/common-spar/include
+ccflags-y += -Idrivers/staging/unisys/common-spar/include/channels
+ccflags-y += -DCONFIG_SPAR_GUEST -DGUESTDRIVERBUILD -DNOAUTOVERSION
+
diff --git a/drivers/staging/unisys/visornic/globals.h b/drivers/staging/unisys/visornic/globals.h
new file mode 100644
index 0000000..38aa83f
--- /dev/null
+++ b/drivers/staging/unisys/visornic/globals.h
@@ -0,0 +1,21 @@
+/* globals.h
+ *
+ * Copyright (c) 2011 - 2014 UNISYS CORPORATION
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ * NON INFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ */
+
+#include "version.h"
+
+#define MYDRVNAME "visornic"
+#define MAXDEVICES     16384
diff --git a/drivers/staging/unisys/visornic/visornic_main.c b/drivers/staging/unisys/visornic/visornic_main.c
new file mode 100644
index 0000000..24fab5c
--- /dev/null
+++ b/drivers/staging/unisys/visornic/visornic_main.c
@@ -0,0 +1,274 @@
+/* Copyright (c) 2012 - 2014 UNISYS CORPORATION
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ * NON INFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ */
+
+/* This driver lives in a sparlinux service partition, and registers to
+ * receive director channels from the visorbus driver.  Currently, we don't need
+ * any implementation here other than to accept the director channel.
+ * The reason we need to accept the director channel is so the visorbus driver
+ * will return successful DEVICE_CREATEs to CONTROL, which enables the partition
+ * state to go RUNNING.
+ */
+
+#include "diagnostics/appos_subsystems.h"
+#include "timskmod.h"
+#include "globals.h"
+#include "visorbus.h"
+#include "visorchannel.h"
+#include "controlframework.h"
+#include "channel_guid.h"
+#include "linux/debugfs.h"
+
+#define VISORNIC_XMIT_TIMEOUT (5 * HZ)
+#define VISORNIC_INFINITE_RESPONSE_WAIT 0
+#define INTERRUPT_VECTOR_MASK 0x3F
+
+static spinlock_t dev_no_pool_lock;
+static void *dev_no_pool;	/**< pool to grab device numbers from */
+
+static int visornic_probe(struct visor_device *dev);
+static void visornic_remove(struct visor_device *dev);
+static int visornic_pause(struct visor_device *dev,
+			  VISORBUS_STATE_COMPLETE_FUNC complete_func);
+static int visornic_resume(struct visor_device *dev,
+			   VISORBUS_STATE_COMPLETE_FUNC complete_func);
+/** DEBUGFS declarations
+ */
+static ssize_t info_debugfs_read(struct file *file, char __user *buf,
+				 size_t len, loff_t *offset);
+static ssize_t enable_ints_write(struct file *file, const char __user *buf,
+				 size_t len, loff_t *ppos);
+static struct dentry *visornic_debugfs_dir;
+static const struct file_operations debugfs_info_fops = {
+	.read = info_debugfs_read,
+};
+
+static const struct file_operations debugfs_enable_ints_fops = {
+	.write = enable_ints_write,
+};
+
+static struct workqueue_struct *visornic_serverdown_workqueue;
+static struct workqueue_struct *visornic_timeout_reset_workqueue;
+
+/**  GUIDS for director channel type supported by this driver.
+*/
+static struct visor_channeltype_descriptor visornic_channel_types[] = {
+	/*  Note that the only channel type we expect to be reported by the
+	 *  bus driver is the ULTRAVNIC channel.
+	 */
+	{ SPAR_VNIC_CHANNEL_PROTOCOL_UUID,
+	  "ultravnic", 1, ULONG_MAX },
+	{ NULL_UUID_LE, NULL, 0, 0 }
+};
+
+/** This is used to tell the visor bus driver which types of visor devices
+ *  we support, and what functions to call when a visor device that we support
+ *  is attached or removed.
+ */
+static struct visor_driver visornic_driver = {
+	.name = MYDRVNAME,
+	.version = VERSION,
+	.vertag = NULL,
+	.owner = THIS_MODULE,
+	.channel_types = visornic_channel_types,
+	.probe = visornic_probe,
+	.remove = visornic_remove,
+	.pause = visornic_pause,
+	.resume = visornic_resume,
+	.channel_interrupt = NULL,
+};
+
+/** This is the private data that we store for each device.
+ *  A pointer to this struct is kept in each "struct device", and can be
+ *  obtained using visor_get_drvdata(dev).
+ */
+struct visornic_devdata {
+	int devno;
+	struct visor_device *dev;
+	/** lock for dev */
+	struct rw_semaphore lock_visor_dev;
+	char name[99];
+	struct list_head list_all;   /**< link within list_all_devices list */
+	struct kref kref;
+};
+
+/** DebugFS code
+ */
+static ssize_t info_debugfs_read(struct file *file, char __user *buf,
+				 size_t len, loff_t *offset)
+{
+	/* DO NOTHING FOR NOW */
+	return len;
+}
+
+static ssize_t enable_ints_write(struct file *file, const char __user *buf,
+				 size_t len, loff_t *ppos)
+{
+	/* DO NOTHING FOR NOW */
+	return len;
+}
+
+/** List of all visornic_devdata structs,
+  * linked via the list_all member
+  */
+static LIST_HEAD(list_all_devices);
+static DEFINE_SPINLOCK(lock_all_devices);
+
+static struct visornic_devdata *devdata_create(struct visor_device *dev)
+{
+	struct visornic_devdata *devdata = NULL;
+	int devno = -1;
+
+	devdata = kmalloc(sizeof(*devdata),
+			  GFP_KERNEL|__GFP_NORETRY);
+	if (!devdata) {
+		return NULL;
+	}
+	memset(devdata, '\0', sizeof(struct visornic_devdata));
+	spin_lock(&dev_no_pool_lock);
+	devno = find_first_zero_bit(dev_no_pool, MAXDEVICES);
+	set_bit(devno, dev_no_pool);
+	spin_unlock(&dev_no_pool_lock);
+	if (devno == MAXDEVICES)
+		devno = -1;
+	if (devno < 0) {
+		kfree(devdata);
+		return NULL;
+	}
+	devdata->devno = devno;
+	devdata->dev = dev;
+	strncpy(devdata->name, dev_name(&dev->device), sizeof(devdata->name));
+	init_rwsem(&devdata->lock_visor_dev);
+	kref_init(&devdata->kref);
+	spin_lock(&lock_all_devices);
+	list_add_tail(&devdata->list_all, &list_all_devices);
+	spin_unlock(&lock_all_devices);
+	return devdata;
+}
+
+static void devdata_release(struct kref *mykref)
+{
+	struct visornic_devdata *devdata =
+		container_of(mykref, struct visornic_devdata, kref);
+
+	spin_lock(&dev_no_pool_lock);
+	clear_bit(devdata->devno, dev_no_pool);
+	spin_unlock(&dev_no_pool_lock);
+	spin_lock(&lock_all_devices);
+	list_del(&devdata->list_all);
+	spin_unlock(&lock_all_devices);
+	kfree(devdata);
+}
+
+static int visornic_probe(struct visor_device *dev)
+{
+	struct visornic_devdata *devdata = NULL;
+
+	devdata = devdata_create(dev);
+	if (!devdata)
+		return -1;
+	visor_set_drvdata(dev, devdata);
+	return 0;
+}
+
+static void host_side_disappeared(struct visornic_devdata *devdata)
+{
+	down_write(&devdata->lock_visor_dev);
+	sprintf(devdata->name, "<dev#%d-history>", devdata->devno);
+	devdata->dev = NULL;   /* indicate device destroyed */
+	up_write(&devdata->lock_visor_dev);
+}
+
+static void visornic_remove(struct visor_device *dev)
+{
+	struct visornic_devdata *devdata = visor_get_drvdata(dev);
+
+	if (!devdata) {
+		return;
+	}
+	visor_set_drvdata(dev, NULL);
+	host_side_disappeared(devdata);
+	kref_put(&devdata->kref, devdata_release);
+
+}
+
+static int visornic_pause(struct visor_device *dev,
+			  VISORBUS_STATE_COMPLETE_FUNC complete_func)
+{
+	complete_func(dev, 0);
+	return 0;
+}
+
+static int visornic_resume(struct visor_device *dev,
+			   VISORBUS_STATE_COMPLETE_FUNC complete_func)
+{
+	complete_func(dev, 0);
+	return 0;
+}
+
+static void visornic_cleanup_guts(void)
+{
+	visorbus_unregister_visor_driver(&visornic_driver);
+	kfree(dev_no_pool);
+	dev_no_pool = NULL;
+}
+
+static int visornic_init(void)
+{
+	/* DAK -- ASSERTS were here, RCVPOST_BUF_SIZE < 4K &
+	   RCVPOST_BUF_SIZE < ETH_HEADER_SIZE.  We own these, why do we
+	   need to assert?  No one is going to change the headers and if
+	   they do oh well
+	*/
+	/* create workqueue for serverdown completion */
+	visornic_serverdown_workqueue =
+		create_singlethread_workqueue("visornic_serverdown");
+	if (!visornic_serverdown_workqueue)
+		return -1;
+
+	/* creaet workqueue for tx timeout reset */
+	visornic_timeout_reset_workqueue =
+		create_singlethread_workqueue("visornic_timeout_reset");
+	if (!visornic_timeout_reset_workqueue)
+		return -1;
+
+	visornic_debugfs_dir = debugfs_create_dir("visornic", NULL);
+	debugfs_create_file("info", S_IRUSR, visornic_debugfs_dir, NULL,
+			    &debugfs_info_fops);
+	debugfs_create_file("enable_ints", S_IWUSR, visornic_debugfs_dir,
+			    NULL, &debugfs_enable_ints_fops);
+
+	spin_lock_init(&dev_no_pool_lock);
+	dev_no_pool = kzalloc(BITS_TO_LONGS(MAXDEVICES), GFP_KERNEL);
+	if (!dev_no_pool) {
+		visornic_cleanup_guts();
+		return -1;
+	}
+	visorbus_register_visor_driver(&visornic_driver);
+	return 0;
+}
+
+static void visornic_cleanup(void)
+{
+	visornic_cleanup_guts();
+}
+
+module_init(visornic_init);
+module_exit(visornic_cleanup);
+
+MODULE_AUTHOR("Unisys");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("sPAR nic driver for sparlinux: ver "
+		   VERSION);
+MODULE_VERSION(VERSION);
diff --git a/drivers/staging/unisys/visornoop/visornoop_main.c b/drivers/staging/unisys/visornoop/visornoop_main.c
index e02a075..1e7f0ff 100644
--- a/drivers/staging/unisys/visornoop/visornoop_main.c
+++ b/drivers/staging/unisys/visornoop/visornoop_main.c
@@ -21,7 +21,6 @@
  * state to go RUNNING.
  */
 
-#include "uniklog.h"
 #include "diagnostics/appos_subsystems.h"
 #include "timskmod.h"
 #include "globals.h"
@@ -96,21 +95,19 @@ static struct visornoop_devdata *devdata_create(struct visor_device *dev)
 
 	devdata = kmalloc(sizeof(*devdata),
 			  GFP_KERNEL|__GFP_NORETRY);
-	if (devdata == NULL) {
-		ERRDRV("allocation of visornoop_devdata failed\n");
-		goto cleanups;
-	}
+	if (devdata == NULL)
+			goto cleanups;
+
 	memset(devdata, '\0', sizeof(struct visornoop_devdata));
 	spin_lock(&dev_no_pool_lock);
 	devno = find_first_zero_bit(dev_no_pool, MAXDEVICES);
 	set_bit(devno, dev_no_pool);
 	spin_unlock(&dev_no_pool_lock);
 	if (devno == MAXDEVICES)
-		devno = -1;
-	if (devno < 0) {
-		ERRDRV("unknown device\n");
-		goto cleanups;
-	}
+			devno = -1;
+	if (devno < 0)
+			goto cleanups;
+
 	devdata->devno = devno;
 	devdata->dev = dev;
 	strncpy(devdata->name, dev_name(&dev->device), sizeof(devdata->name));
@@ -138,7 +135,6 @@ static void devdata_release(struct kref *mykref)
 	struct visornoop_devdata *devdata =
 		container_of(mykref, struct visornoop_devdata, kref);
 
-	INFODRV("%s", __func__);
 	spin_lock(&dev_no_pool_lock);
 	clear_bit(devdata->devno, dev_no_pool);
 	spin_unlock(&dev_no_pool_lock);
@@ -146,7 +142,6 @@ static void devdata_release(struct kref *mykref)
 	list_del(&devdata->list_all);
 	spin_unlock(&lock_all_devices);
 	kfree(devdata);
-	INFODRV("%s finished", __func__);
 }
 
 static int visornoop_probe(struct visor_device *dev)
@@ -154,7 +149,6 @@ static int visornoop_probe(struct visor_device *dev)
 	int rc = 0;
 	struct visornoop_devdata *devdata = NULL;
 
-	INFODRV("%s", __func__);
 	devdata = devdata_create(dev);
 	if (devdata == NULL) {
 		rc = -1;
@@ -162,7 +156,6 @@ static int visornoop_probe(struct visor_device *dev)
 	}
 	visor_set_drvdata(dev, devdata);
 cleanups:
-	INFODRV("%s finished", __func__);
 	if (rc < 0) {
 		if (devdata != NULL)
 			kref_put(&devdata->kref, devdata_release);
@@ -182,22 +175,17 @@ static void visornoop_remove(struct visor_device *dev)
 {
 	struct visornoop_devdata *devdata = visor_get_drvdata(dev);
 
-	INFODRV("%s", __func__);
-	if (devdata == NULL) {
-		ERRDRV("no devdata in %s", __func__);
-		goto cleanups;
-	}
+	if (devdata == NULL)
+			return;
+
 	visor_set_drvdata(dev, NULL);
 	host_side_disappeared(devdata);
 	kref_put(&devdata->kref, devdata_release);
-cleanups:
-	INFODRV("%s finished", __func__);
 }
 
 static int visornoop_pause(struct visor_device *dev,
 			   VISORBUS_STATE_COMPLETE_FUNC complete_func)
 {
-	INFODEV(dev_name(&dev->device), "paused");
 	complete_func(dev, 0);
 	return 0;
 }
@@ -205,7 +193,6 @@ static int visornoop_pause(struct visor_device *dev,
 static int visornoop_resume(struct visor_device *dev,
 			    VISORBUS_STATE_COMPLETE_FUNC complete_func)
 {
-	INFODEV(dev_name(&dev->device), "resumed");
 	complete_func(dev, 0);
 	return 0;
 }
@@ -221,29 +208,19 @@ static void visornoop_cleanup_guts(void)
 
 static int visornoop_init(void)
 {
-	int rc = 0;
-
-	INFODRV("driver version %s loaded", VERSION);
-
 	spin_lock_init(&dev_no_pool_lock);
 	dev_no_pool = kzalloc(BITS_TO_LONGS(MAXDEVICES), GFP_KERNEL);
 	if (dev_no_pool == NULL) {
-		ERRDRV("Unable to create dev_no_pool");
-		rc = -1;
-		goto cleanups;
+		visornoop_cleanup_guts();
+		return -1;
 	}
 	visorbus_register_visor_driver(&visornoop_driver);
-
-cleanups:
-	if (rc < 0)
-		visornoop_cleanup_guts();
-	return rc;
+	return 0;
 }
 
 static void visornoop_cleanup(void)
 {
 	visornoop_cleanup_guts();
-	INFODRV("driver unloaded");
 }
 
 module_init(visornoop_init);
diff --git a/drivers/staging/unisys/visorserial/linuxserial.c b/drivers/staging/unisys/visorserial/linuxserial.c
index c51ce10..4034b0d 100644
--- a/drivers/staging/unisys/visorserial/linuxserial.c
+++ b/drivers/staging/unisys/visorserial/linuxserial.c
@@ -206,17 +206,14 @@ lxser_startup(struct uart_port *port)
 	struct linux_serial *ls =
 	(__force struct linux_serial *)(port->membase);
 
-	INFODRV("%s", __func__);
 	ls->periodic_work = visor_periodic_work_create(DELAY_TIME,
 						       workqueue,
 						       lxser_periodic_work,
 						       ls, "visortty");
-	if (ls->periodic_work == NULL) {
-		ERRDEVX(ls->devno, "failed to create periodic_work");
-		return -ENOMEM;
-	}
+	if (ls->periodic_work == NULL)
+			return -ENOMEM;
+
 	visor_periodic_work_start(ls->periodic_work);
-	INFODRV("port started");
 	return 0;
 }
 
@@ -228,7 +225,6 @@ lxser_shutdown(struct uart_port *port)
 	struct linux_serial *ls =
 	(__force struct linux_serial *)(port->membase);
 
-	INFODRV("%s", __func__);
 	if (ls->periodic_work != NULL) {
 		visor_periodic_work_stop(ls->periodic_work);
 		visor_periodic_work_destroy(ls->periodic_work);
@@ -289,16 +285,12 @@ linuxserial_create(int devno, void *context, void (*transmit_char) (void *, u8))
 	struct linux_serial *rc = NULL;
 	struct linux_serial *ls = NULL;
 
-	INFODRV("%s", __func__);
 	if (devno >= UART_NR) {
-		ERRDEVX(devno, "tty device NOT created (max tty devices=%d)",
-			UART_NR);
 		rc = NULL;
 		goto cleanups;
 	}
 	ls = kmalloc(sizeof(*ls), GFP_KERNEL|__GFP_NORETRY);
 	if (ls == NULL) {
-		ERRDEVX(devno, "%s allocation failed ", __func__);
 		rc = NULL;
 		goto cleanups;
 	}
@@ -323,29 +315,24 @@ linuxserial_create(int devno, void *context, void (*transmit_char) (void *, u8))
 	if (!driver_registered) {
 		result = uart_register_driver(&visorserial_lxser_reg);
 		if (result) {
-			ERRDEVX(devno, "uart_register_driver failed");
 			rc = NULL;
 			goto cleanups;
 		}
 		workqueue = create_singlethread_workqueue("visortty");
 		if (workqueue == NULL) {
-			ERRDEVX(devno, "cannot create workqueue");
 			uart_unregister_driver(&visorserial_lxser_reg);
 			rc = NULL;
 			goto cleanups;
 		}
-		INFODRV("tty driver registered");
 		driver_registered = TRUE;
 	}
 
 	result = uart_add_one_port(&visorserial_lxser_reg, &ls->port);
 	if (result) {
-		ERRDEVX(devno, "uart_add_one_port failed");
 		uart_unregister_driver(&visorserial_lxser_reg);
 		rc = NULL;
 		goto cleanups;
 	}
-	INFODEVX(devno, "tty port added");
 	registered_ports++;
 
 	rc = ls;
@@ -362,7 +349,6 @@ cleanups:
 void
 linuxserial_destroy(struct linux_serial *ls)
 {
-	INFODEVX(ls->devno, "%s", __func__);
 	if (ls == NULL)
 		return;
 	uart_remove_one_port(&visorserial_lxser_reg, &ls->port);
diff --git a/drivers/staging/unisys/visorserial/linuxserial.h b/drivers/staging/unisys/visorserial/linuxserial.h
index 380b5c1..baca643 100644
--- a/drivers/staging/unisys/visorserial/linuxserial.h
+++ b/drivers/staging/unisys/visorserial/linuxserial.h
@@ -18,7 +18,6 @@
 #ifndef __LINUXSERIAL_H__
 #define __LINUXSERIAL_H__
 
-#include "uniklog.h"
 #include "timskmod.h"
 
 /* struct linux_serial is an opaque structure to users.
diff --git a/drivers/staging/unisys/visorserial/visorserial_main.c b/drivers/staging/unisys/visorserial/visorserial_main.c
index 4275900..3b5848e 100644
--- a/drivers/staging/unisys/visorserial/visorserial_main.c
+++ b/drivers/staging/unisys/visorserial/visorserial_main.c
@@ -140,23 +140,17 @@ static LIST_HEAD(list_all_devices);
 static DEFINE_SPINLOCK(lock_all_devices);
 
 #define devdata_put(devdata, why)					\
-	do {								\
+	{								\
 		int refcount;						\
 		kref_put(&devdata->kref, devdata_release);		\
 		refcount = atomic_read(&devdata->kref.refcount);	\
-		if (visorserial_debugref)				\
-			VISORBUS_DEBUG_REFCOUNT_CHANGE			\
-				(refcount+1, refcount, devdata, why);	\
-	} while (0)
+	}
 #define devdata_get(devdata, why)					\
-	do {								\
+	{								\
 		int refcount;						\
 		kref_get(&devdata->kref);				\
 		refcount = atomic_read(&devdata->kref.refcount);	\
-		if (visorserial_debugref)				\
-			VISORBUS_DEBUG_REFCOUNT_CHANGE			\
-				(refcount-1, refcount, devdata, why);	\
-	} while (0)
+	}
 
 /** This is the private data that we store for each file descriptor that is
  *  opened to the "serial" character device.
@@ -212,7 +206,7 @@ devdata_property_show(struct device *ddev,
 static int
 register_devdata_attributes(struct visor_device *dev)
 {
-	int rc, i;
+	int i, rc = 0;
 	struct visorserial_devdata *devdata = visor_get_drvdata(dev);
 	struct device_attribute *pattr = devdata->devdata_property;
 
@@ -222,30 +216,16 @@ register_devdata_attributes(struct visor_device *dev)
 		pattr[i].show = devdata_property_show;
 		pattr[i].store = NULL;
 		rc = device_create_file(&dev->device, &pattr[i]);
-		if (rc < 0) {
-			ERRDRV("device_create_file(&dev->device, &pattr[i]): (status=%d)\n", rc);
-			goto cleanups;
-		}
+		if (rc < 0)
+				return rc;
 	}
-
-	rc = 0;
-cleanups:
-	return rc;
+	return 0;
 }
 
 static int
 register_device_attributes(struct visor_device *dev)
 {
-	int rc;
-
-	rc = register_devdata_attributes(dev);
-	if (rc < 0) {
-		ERRDRV("register_devdata_attributes(dev): (status=%d)\n", rc);
-		goto cleanups;
-	}
-	rc = 0;
-cleanups:
-	return rc;
+	return register_devdata_attributes(dev);
 }
 
 static int
@@ -277,10 +257,9 @@ devdata_create(struct visor_device *dev)
 
 	devdata = kmalloc(sizeof(*devdata),
 			  GFP_KERNEL|__GFP_NORETRY);
-	if (devdata == NULL) {
-		ERRDRV("allocation of visorserial_devdata failed\n");
-		goto cleanups;
-	}
+	if (devdata == NULL)
+			goto cleanups;
+
 	memset(devdata, '\0', sizeof(struct visorserial_devdata));
 	cdev_init(&devdata->cdev_serial, NULL);
 	spin_lock(&devnopool_lock);
@@ -289,10 +268,8 @@ devdata_create(struct visor_device *dev)
 	spin_unlock(&devnopool_lock);
 	if (devno == MAXDEVICES)
 		devno = -1;
-	if (devno < 0) {
-		ERRDRV("attempt to create more than MAXDEVICES devices\n");
-		goto cleanups;
-	}
+	if (devno < 0)
+			goto cleanups;
 
 	devdata->devno = devno;
 	devdata->dev = dev;
@@ -308,7 +285,6 @@ devdata_create(struct visor_device *dev)
 	devdata->cdev_serial.owner = THIS_MODULE;
 	if (cdev_add(&devdata->cdev_serial,
 		     MKDEV(MAJOR(majordevserial), devdata->devno), 1) < 0) {
-		ERRDRV("failed to create serial char device\n");
 		goto cleanups;
 	}
 
@@ -356,7 +332,6 @@ devdata_release(struct kref *mykref)
 							   struct
 							   visorserial_devdata,
 							   kref);
-	INFODRV("%s", __func__);
 	spin_lock(&devnopool_lock);
 	clear_bit(devdata->devno, devnopool);
 	spin_unlock(&devnopool_lock);
@@ -373,49 +348,32 @@ devdata_release(struct kref *mykref)
 		up_read(&devdata->lock_visor_dev);
 	}
 	kfree(devdata);
-	INFODRV("%s finished", __func__);
 }
 
 static int
 visorserial_probe(struct visor_device *dev)
 {
-	int rc = 0;
 	struct visorserial_devdata *devdata = NULL;
 
-	INFODRV("%s", __func__);
-
 	devdata = devdata_create(dev);
-	if (devdata == NULL) {
-		rc = -1;
-		goto cleanups;
-	}
+	if (devdata == NULL)
+			return -1;
+
 	if (ULTRA_CONSOLE_CHANNEL_OK_CLIENT
 	    (visorchannel_get_header(dev->visorchannel), NULL) ||
 	    ULTRA_CONSOLESERIAL_CHANNEL_OK_CLIENT
 	    (visorchannel_get_header(dev->visorchannel), NULL))
 		;
-	else {
-		rc = -1;
-		ERRDRV("consoleserial channel cannot be used: (status=%d)\n",
-		       rc);
-		goto cleanups;
-	}
+	else
+		return -1;
+
 	visor_set_drvdata(dev, devdata);
-	if (register_device_attributes(dev) < 0) {
-		rc = -1;
-		ERRDRV("register_device_attributes failed: (status=%d)\n", rc);
-		goto cleanups;
-	}
+	if (register_device_attributes(dev) < 0)
+			return -1;
+
 	visor_easyproc_InitDevice(&easyproc_driver_info,
 				  &devdata->procinfo, devdata->devno, devdata);
-
-cleanups:
-	INFODRV("%s finished", __func__);
-	if (rc < 0) {
-		if (devdata != NULL)
-			devdata_put(devdata, "existence");
-	}
-	return rc;
+	return 0;
 }
 
 static void
@@ -423,20 +381,14 @@ visorserial_remove(struct visor_device *dev)
 {
 	struct visorserial_devdata *devdata = visor_get_drvdata(dev);
 
-	INFODRV("%s", __func__);
-	if (devdata == NULL) {
-		ERRDRV("no devdata in %s", __func__);
-		goto cleanups;
-	}
+	if (devdata == NULL)
+			return;
+
 	unregister_device_attributes(dev);
 	visor_set_drvdata(dev, NULL);
 	visor_easyproc_DeInitDevice(&easyproc_driver_info,
 				    &devdata->procinfo, devdata->devno);
 	host_side_disappeared(devdata);
-	devdata_put(devdata, "existence");
-
-cleanups:
-	INFODRV("%s finished", __func__);
 }
 
 static void
@@ -445,26 +397,19 @@ visorserial_channel_interrupt(struct visor_device *dev)
 	u8 data;
 	struct visorserial_devdata *devdata = visor_get_drvdata(dev);
 
-	if (devdata == NULL) {
-		ERRDRV("no devdata in %s", __func__);
-		goto cleanups;
-	}
-	/* INFODRV("%s", __func__); */
+	if (devdata == NULL)
+			return;
+
 	while (visorchannel_signalremove(dev->visorchannel,
 					 devdata->recvqueue, &data)) {
 		new_char_from_host(devdata, data);
 		devdata->counter.host_bytes_in++;
 	}
-
-cleanups:
-	;
 }
 
 static void
 destroy_visor_device(struct visor_device *dev)
 {
-	char s[99];
-
 	if (dev == NULL)
 		return;
 	if (dev->periodic_work != NULL) {
@@ -472,8 +417,6 @@ destroy_visor_device(struct visor_device *dev)
 		dev->periodic_work = NULL;
 	}
 	if (dev->visorchannel != NULL) {
-		INFODRV("Channel %s disconnected",
-			visorchannel_id(dev->visorchannel, s));
 		visorchannel_destroy(dev->visorchannel);
 		dev->visorchannel = NULL;
 	}
@@ -485,7 +428,6 @@ simplebus_release_device(struct device *xdev)
 {
 	struct visor_device *dev = to_visor_device(xdev);
 
-	INFODEV(dev_name(&dev->device), "child device destroyed");
 	destroy_visor_device(dev);
 }
 
@@ -536,24 +478,18 @@ create_visor_device(u64 addr)
 	struct visorchannel *visorchannel = NULL;
 	struct visor_device *dev = NULL;
 	BOOL gotten = FALSE;
-	char s[99];
 	uuid_le guid = ULTRA_CONSOLE_CHANNEL_PROTOCOL_GUID;
 
 	/* prepare chan_hdr (abstraction to read/write channel memory) */
 	visorchannel =
 	    visorchannel_create(addr, 0 /*size in chan hdr */ , guid);
-	if (visorchannel == NULL) {
-		ERRDRV("channel addr = 0x%-16.16Lx", addr);
-		ERRDRV("visorchannel_create failed\n");
-		goto cleanups;
-	}
-	INFODRV("Channel %s discovered and connected",
-		visorchannel_id(visorchannel, s));
+	if (visorchannel == NULL)
+			goto cleanups;
+
 	dev = kmalloc(sizeof(dev), GFP_KERNEL|__GFP_NORETRY);
-	if (dev == NULL) {
-		ERRDRV("failed to allocate visor_device\n");
-		goto cleanups;
-	}
+	if (dev == NULL)
+			goto cleanups;
+
 	memset(dev, 0, sizeof(struct visor_device));
 	dev->visorchannel = visorchannel;
 	sema_init(&dev->visordriver_callback_lock, 1);	/* unlocked */
@@ -568,10 +504,8 @@ create_visor_device(u64 addr)
 							dev_periodic_work,
 							dev,
 							dev_name(&dev->device));
-	if (dev->periodic_work == NULL) {
-		ERRDRV("failed to create periodic_work\n");
-		goto cleanups;
-	}
+	if (dev->periodic_work == NULL)
+			goto cleanups;
 
 	/* bus_id must be a unique name with respect to this bus TYPE
 	 * (NOT bus instance).  That's why we need to include the bus
@@ -579,15 +513,9 @@ create_visor_device(u64 addr)
 	 */
 	dev_set_name(&dev->device, "visorconsole");
 
-	if (device_add(&dev->device) < 0) {
-		ERRDRV("device_add failed\n");
-		goto cleanups;
-	}
+	if (device_add(&dev->device) < 0)
+			goto cleanups;
 	/* note: device_register is simply device_initialize + device_add */
-
-	INFODEV(dev_name(&dev->device),
-		"child device 0x%p created", &dev->device);
-
 	rc = dev;
 cleanups:
 	if (rc == NULL) {
@@ -638,31 +566,14 @@ visorserial_init(void)
 	int rc = -1;
 	u64 visorserial_addr = 0;
 
-	INFODRV("driver version %s loaded", VERSION);
-	/* uintpool_test(); */
-	INFODRV("Built with:");
-	INFODRV("         STANDALONE_CLIENT yes");
-	INFODRV("option - rxtxswap=%d", visorserial_rxtxswap);
-	INFODRV("         createttydevice=%d",
-		visorserial_createttydevice);
-	INFODRV("         channeladdress=0x%lx",
-		visorserial_channeladdress);
-	INFODRV("         clearchannel=%d",
-		visorserial_clearchannel);
-	INFODRV("         debug=%d", visorserial_debug);
-	INFODRV("         debugref=%d", visorserial_debugref);
-
 	majordevserial = MKDEV(0, 0);
 	spin_lock_init(&devnopool_lock);
 	devnopool = kzalloc(BITS_TO_LONGS(MAXDEVICES), GFP_KERNEL);
-	if (devnopool == NULL) {
-		ERRDRV("Unable to create devnopool");
-		goto cleanups;
-	}
+	if (devnopool == NULL)
+			goto cleanups;
+
 	if (alloc_chrdev_region(&majordevserial, 0, MAXDEVICES,
 				MYDRVNAME "_serial") < 0) {
-		ERRDRV("Unable to register char device %s",
-		       MYDRVNAME "_serial");
 		goto cleanups;
 	}
 	visor_easyproc_InitDriver(&easyproc_driver_info,
@@ -670,37 +581,29 @@ visorserial_init(void)
 				  visorserial_show_driver_info,
 				  visorserial_show_device_info);
 	rc = bus_register(&simplebus_type);
-	if (rc < 0) {
-		ERRDRV("bus_register(&simplebus_type): (status=%d)\n", rc);
-		goto cleanups;
-	}
+	if (rc < 0)
+			goto cleanups;
+
 	periodic_dev_workqueue = create_singlethread_workqueue("visorconsole");
 	if (periodic_dev_workqueue == NULL) {
 		rc = -ENOMEM;
-		ERRDRV("cannot create dev workqueue: (status=%d)\n", rc);
 		goto cleanups;
 	}
 	if (!visorserial_channeladdress) {
-		INFODRV("channeladdress module/kernel parameter not specified so issuing vmcall");
 		if (!VMCALL_SUCCESSFUL
 		    (issue_vmcall_io_visorserial_addr(&visorserial_addr))) {
-			ERRDRV("channeladdress module/kernel parameter not specified and vmcall failed.");
 			rc = -1;
 			goto cleanups;
 		}
-		INFODRV("visorserial channel addr=%llx", visorserial_addr);
 		visorserial_channeladdress = visorserial_addr;
 	}
 	standalonedevice =
 	    create_visor_device(visorserial_channeladdress);
 	if (standalonedevice == NULL) {
-		ERRDRV("failed to initialize channel @ 0x%lx",
-		       visorserial_channeladdress);
 		rc = -1;
 		goto cleanups;
 	}
 	if (visorserial_probe(standalonedevice) < 0) {
-		ERRDRV("probe failed");
 		rc = -1;
 		goto cleanups;
 	}
@@ -719,7 +622,6 @@ static void
 visorserial_cleanup(void)
 {
 	visorserial_cleanup_guts();
-	INFODRV("driver unloaded");
 }
 
 static struct visorserial_filedata_serial *
@@ -796,10 +698,9 @@ new_char_to_host(void *context, u8 c)
 	    (struct visorserial_devdata *)(context);
 	int done = 0;
 
-	if (devdata->dev == NULL) {
-		HUHDRV("dev is NULL in %s??", __func__);
-		return;
-	}
+	if (devdata->dev == NULL)
+			return;
+
 	while (!done) {
 		if (visorchannel_signalinsert(devdata->dev->visorchannel,
 					      devdata->xmitqueue, &c)) {
@@ -853,7 +754,6 @@ first_file_opened(struct visorserial_filedata_serial *filedata)
 {
 	struct visorserial_devdata *devdata = filedata->devdata;
 
-	INFODEV(devdata->name, "lights on");
 	if (devdata->linuxserial == NULL) {
 		down_read(&devdata->lock_visor_dev);
 		if (devdata->dev != NULL)
@@ -867,7 +767,6 @@ last_file_closed(struct visorserial_filedata_serial *filedata)
 {
 	struct visorserial_devdata *devdata = filedata->devdata;
 
-	INFODEV(devdata->name, "lights off");
 	if (devdata->linuxserial == NULL) {
 		down_read(&devdata->lock_visor_dev);
 		if (devdata->dev != NULL)
@@ -882,19 +781,13 @@ visorserial_serial_open(struct inode *inode, struct file *file)
 	struct visorserial_devdata *devdata = NULL;
 	struct visorserial_filedata_serial *filedata = NULL;
 	unsigned minor_number = iminor(inode);
-	int rc = -ENODEV;
 
 	list_for_each_entry(devdata, &list_all_devices, list_all) {
 		if (devdata->devno == minor_number) {
-			INFODEV(devdata->name,
-				"%s minor=%d", __func__, minor_number);
 			filedata = serial_create_file(devdata);
-			if (filedata == NULL) {
-				rc = -ENOMEM;
-				ERRDRV("cannot alloc file data: (status=%d)\n",
-				       rc);
-				goto cleanups;
-			}
+			if (filedata == NULL)
+					return -ENOMEM;
+
 			file->private_data = filedata;
 			write_lock(&devdata->lock_files);
 			list_add_tail(&filedata->list_all,
@@ -905,36 +798,26 @@ visorserial_serial_open(struct inode *inode, struct file *file)
 			if (devdata->open_file_count == 1)
 				first_file_opened(filedata);
 			up_write(&devdata->lock_open_file_count);
-			rc = 0;
-			goto cleanups;
+			return 0;
 		}
 	}
-	rc = -ENODEV;
-cleanups:
-	if (rc < 0)
-		ERRDRV("%s minor=%d failed", __func__, minor_number);
-	return rc;
+	return -ENODEV;
 }
 
 static int
 visorserial_serial_release(struct inode *inode, struct file *file)
 {
-	int rc = -1;
 	struct visorserial_filedata_serial *filedata =
 	    (struct visorserial_filedata_serial *)(file->private_data);
 	struct visorserial_devdata *devdata = NULL;
 
-	if (filedata == NULL) {
-		ERRDRV("unknown file: (status=%d)\n", rc);
-		goto cleanups;
-	}
+	if (filedata == NULL)
+			return -1;
+
 	devdata = filedata->devdata;
-	if (devdata == NULL) {
-		ERRDRV("unknown device: (status=%d)\n", rc);
-		goto cleanups;
-	}
+	if (devdata == NULL)
+			return -1;
 
-	INFODEV(devdata->name, "%s", __func__);
 	down_write(&devdata->lock_open_file_count);
 	if (devdata->open_file_count == 1)
 		last_file_closed(filedata);
@@ -945,9 +828,7 @@ visorserial_serial_release(struct inode *inode, struct file *file)
 	write_unlock(&devdata->lock_files);
 	serial_destroy_file(filedata);
 	file->private_data = NULL;
-	rc = 0;
-cleanups:
-	return rc;
+	return 0;
 }
 
 #ifdef HAVE_UNLOCKED_IOCTL
@@ -959,33 +840,24 @@ visorserial_serial_ioctl(struct inode *inode, struct file *file,
 			 unsigned int cmd, unsigned long arg)
 #endif
 {
-	int rc = -1;
 	struct visorserial_filedata_serial *filedata =
 	    (struct visorserial_filedata_serial *)(file->private_data);
 	struct visorserial_devdata *devdata = NULL;
 
-	if (filedata == NULL) {
-		ERRDRV("unknown file: (status=%d)\n", rc);
-		goto cleanups;
-	}
-	devdata = filedata->devdata;
-	if (devdata == NULL) {
-		ERRDRV("unknown device: (status=%d)\n", rc);
-		goto cleanups;
-	}
+	if (filedata == NULL)
+			return -1;
 
-	/* void __user *userptr = (void __user *)(arg); */
-	INFODEV(devdata->name, "%s cmd=0x%x", __func__, cmd);
-	rc = 0;
-cleanups:
-	return rc;
+	devdata = filedata->devdata;
+	if (devdata == NULL)
+			return -1;
+	return 0;
 }
 
 static ssize_t
 visorserial_serial_read(struct file *file, char __user *buf,
 			size_t count, loff_t *ppos)
 {
-	int rc = -1, readchars = 0, mycount = count;
+	int readchars = 0, mycount = count;
 	struct visorserial_filedata_serial *filedata =
 	    (struct visorserial_filedata_serial *)(file->private_data);
 	struct visorserial_devdata *devdata = NULL;
@@ -997,81 +869,60 @@ visorserial_serial_read(struct file *file, char __user *buf,
 	if (pos > 0 || !count)
 		return 0;
 
-	if (filedata == NULL) {
-		ERRDRV("unknown file: (status=%d)\n", rc);
-		goto cleanups;
-	}
+	if (filedata == NULL)
+			return -1;
+
 	devdata = filedata->devdata;
-	if (devdata == NULL) {
-		ERRDRV("unknown device: (status=%d)\n", rc);
-		goto cleanups;
-	}
-	DEBUGDEV(devdata->name, "%s", __func__);
+	if (devdata == NULL)
+			return -1;
+
 	if (file->f_flags & O_NONBLOCK)
-		if (!serial_ready_to_read(filedata)) {
-			rc = -EAGAIN;
-			goto cleanups;
-		}
+		if (!serial_ready_to_read(filedata))
+				return -EAGAIN;
 	if (mycount > NFILEREADBYTESTOBUFFER)
 		mycount = NFILEREADBYTESTOBUFFER;
 	while (readchars <= 0) {
 		wait_event_interruptible(filedata->waiting_readers,
 					 serial_ready_to_read(filedata));
-		if (signal_pending(current)) {
-			rc = -EINTR;
-			goto cleanups;
-		}
-		if (devdata->dev == NULL) {	/* channel disappeared */
-			rc = 0;	/* end-of-file */
-			goto cleanups;
-		}
+		if (signal_pending(current))
+				return -EINTR;
+		if (devdata->dev == NULL)
+				return 0;
 		readchars = visor_charqueue_dequeue_n(filedata->data_from_host,
 						      filedata->buf, mycount);
 	}
-	if (copy_to_user(buf, filedata->buf, readchars)) {
-		rc = -EFAULT;
-		goto cleanups;
-	}
+	if (copy_to_user(buf, filedata->buf, readchars))
+			return -EFAULT;
 	devdata->counter.umode_bytes_out += readchars;
 	*ppos += readchars;
-	rc = readchars;
-cleanups:
-	DEBUGDEV(devdata->name, "%s read %d of %d", __func__,
-		 readchars, count);
-	return rc;
+	return readchars;
 }
 
 static ssize_t
 visorserial_serial_write(struct file *file,
 			 const char __user *buf, size_t count, loff_t *ppos)
 {
-	int rc = -1, i = 0, writechars = 0;
+	int i = 0, writechars = 0;
 	struct visorserial_filedata_serial *filedata =
 	    (struct visorserial_filedata_serial *)(file->private_data);
 	struct visorserial_devdata *devdata = NULL;
 
-	if (filedata == NULL) {
-		ERRDRV("unknown file: (status=%d)\n", rc);
-		goto cleanups;
-	}
+	if (filedata == NULL)
+			return -1;
+
 	devdata = filedata->devdata;
-	if (devdata == NULL) {
-		ERRDRV("unknown device: (status=%d)\n", rc);
-		goto cleanups;
-	}
-	DEBUGDEV(devdata->name, "%s", __func__);
+	if (devdata == NULL)
+			return -1;
+
 	if (count > NFILEWRITEBYTESTOBUFFER)
 		count = NFILEWRITEBYTESTOBUFFER;
-	if (copy_from_user(filedata->buf, buf, count)) {
-		rc = -EFAULT;
-		goto cleanups;
-	}
+	if (copy_from_user(filedata->buf, buf, count))
+			return -EFAULT;
 	devdata->counter.umode_bytes_in += count;
 	down_read(&devdata->lock_visor_dev);
 	if (devdata->dev == NULL) {	/* host channel is gone */
 		up_read(&devdata->lock_visor_dev);
-		rc = 0;	/* eof */
-		goto cleanups;
+		return 0;
 	}
 
 	for (i = 0; i < count; i++) {
@@ -1080,40 +931,27 @@ visorserial_serial_write(struct file *file,
 	}
 	up_read(&devdata->lock_visor_dev);
 
-	rc = count;
-cleanups:
-	DEBUGDEV(devdata->name, "%s wrote %d of %d", __func__,
-		 writechars, count);
-	return rc;
+	return count;
 }
 
 static unsigned int
 visorserial_serial_poll(struct file *file, poll_table *wait)
 {
-	int rc = -1;
 	struct visorserial_filedata_serial *filedata =
 	    (struct visorserial_filedata_serial *)(file->private_data);
 	struct visorserial_devdata *devdata = NULL;
 
-	if (filedata == NULL) {
-		ERRDRV("unknown file: (status=%d)\n", rc);
-		goto cleanups;
-	}
+	if (filedata == NULL)
+			return -1;
+
 	devdata = filedata->devdata;
-	if (devdata == NULL) {
-		ERRDRV("unknown device: (status=%d)\n", rc);
-		goto cleanups;
-	}
+	if (devdata == NULL)
+			return -1;
 
 	poll_wait(file, &filedata->waiting_readers, wait);
-	if (serial_ready_to_read(filedata)) {
-		rc = POLLIN | POLLRDNORM;
-		goto cleanups;
-	}
-
-	rc = 0;
-cleanups:
-	return rc;
+	if (serial_ready_to_read(filedata))
+			return POLLIN | POLLRDNORM;
+	return 0;
 }
 
 static void
diff --git a/drivers/staging/unisys/visorvideoclient/visorvideoclient_main.c b/drivers/staging/unisys/visorvideoclient/visorvideoclient_main.c
index ef460e6..21e1c6f 100644
--- a/drivers/staging/unisys/visorvideoclient/visorvideoclient_main.c
+++ b/drivers/staging/unisys/visorvideoclient/visorvideoclient_main.c
@@ -24,7 +24,6 @@
  * RUNNING.
  */
 
-#include "uniklog.h"
 #include "diagnostics/appos_subsystems.h"
 #include "timskmod.h"
 #include "globals.h"
@@ -104,24 +103,18 @@ static LIST_HEAD(list_all_devices);
 static DEFINE_SPINLOCK(lock_all_devices);
 
 #define devdata_put(devdata, why)					\
-	do {								\
+	{								\
 		int refcount;						\
 		kref_put(&devdata->kref, devdata_release);		\
 		refcount = atomic_read(&devdata->kref.refcount);	\
-		if (visorvideoclient_debugref)				\
-			VISORBUS_DEBUG_REFCOUNT_CHANGE			\
-				(refcount+1, refcount, devdata, why);	\
-	} while (0)
+	}
 
 #define devdata_get(devdata, why)					\
-	do {								\
+	{								\
 		int refcount;						\
 		kref_get(&devdata->kref);				\
 		refcount = atomic_read(&devdata->kref.refcount);	\
-		if (visorvideoclient_debugref)				\
-			VISORBUS_DEBUG_REFCOUNT_CHANGE			\
-				(refcount-1, refcount, devdata, why);	\
-	} while (0)
+	}
 
 static struct visorvideoclient_devdata *
 devdata_create(struct visor_device *dev)
@@ -132,10 +125,9 @@ devdata_create(struct visor_device *dev)
 
 	devdata = kmalloc(sizeof(*devdata),
 			  GFP_KERNEL|__GFP_NORETRY);
-	if (devdata == NULL) {
-		ERRDRV("allocation of visorvideoclient_devdata failed)\n");
-		goto cleanups;
-	}
+	if (devdata == NULL)
+			goto cleanups;
+
 	memset(devdata, '\0', sizeof(struct visorvideoclient_devdata));
 	spin_lock(&devnopool_lock);
 	devno = find_first_zero_bit(dev_no_pool, MAXDEVICES);
@@ -143,10 +135,9 @@ devdata_create(struct visor_device *dev)
 	spin_unlock(&devnopool_lock);
 	if (devno == MAXDEVICES)
 		devno = -1;
-	if (devno < 0) {
-		ERRDRV("attempt to create more than MAXDEVICES devices\n");
-		goto cleanups;
-	}
+	if (devno < 0)
+			goto cleanups;
+
 	devdata->devno = devno;
 	devdata->dev = dev;
 	strncpy(devdata->name, dev_name(&dev->device), sizeof(devdata->name));
@@ -175,7 +166,6 @@ devdata_release(struct kref *mykref)
 	struct visorvideoclient_devdata *devdata =
 	    container_of(mykref, struct visorvideoclient_devdata, kref);
 
-	INFODRV("%s", __func__);
 	spin_lock(&devnopool_lock);
 	clear_bit(devdata->devno, dev_no_pool);
 	spin_unlock(&devnopool_lock);
@@ -183,31 +173,18 @@ devdata_release(struct kref *mykref)
 	list_del(&devdata->list_all);
 	spin_unlock(&lock_all_devices);
 	kfree(devdata);
-	INFODRV("%s finished", __func__);
 }
 
 static int
 visorvideoclient_probe(struct visor_device *dev)
 {
-	int rc;
 	struct visorvideoclient_devdata *devdata = NULL;
 
-	INFODRV("%s", __func__);
 	devdata = devdata_create(dev);
-	if (devdata == NULL) {
-		rc = -1;
-		goto cleanups;
-	}
+	if (devdata == NULL)
+			return -1;
 	visor_set_drvdata(dev, devdata);
-	rc = 0;
-
-cleanups:
-	INFODRV("%s finished", __func__);
-	if (rc < 0) {
-		if (devdata != NULL)
-			devdata_put(devdata, "existence");
-	}
-	return rc;
+	return 0;
 }
 
 static void
@@ -223,24 +200,18 @@ static void
 visorvideoclient_remove(struct visor_device *dev)
 {
 	struct visorvideoclient_devdata *devdata = visor_get_drvdata(dev);
+	if (devdata == NULL)
+			return;
 
-	INFODRV("%s", __func__);
-	if (devdata == NULL) {
-		ERRDRV("no devdata in %s", __func__);
-		goto cleanups;
-	}
 	visor_set_drvdata(dev, NULL);
 	host_side_disappeared(devdata);
 	devdata_put(devdata, "existence");
-cleanups:
-	INFODRV("%s finished", __func__);
 }
 
 static int
 visorvideoclient_pause(struct visor_device *dev,
 		       VISORBUS_STATE_COMPLETE_FUNC complete_func)
 {
-	INFODEV(dev_name(&dev->device), "paused");
 	complete_func(dev, 0);
 	return 0;
 }
@@ -249,7 +220,6 @@ static int
 visorvideoclient_resume(struct visor_device *dev,
 			VISORBUS_STATE_COMPLETE_FUNC complete_func)
 {
-	INFODEV(dev_name(&dev->device), "resumed");
 	complete_func(dev, 0);
 	return 0;
 }
@@ -267,35 +237,20 @@ visorvideoclient_cleanup_guts(void)
 static int
 visorvideoclient_init(void)
 {
-	int rc;
-
-	INFODRV("driver version %s loaded", VERSION);
-
-	/* show module options */
-	INFODRV("option - debug=%d", visorvideoclient_debug);
-	INFODRV("         debugref=%d", visorvideoclient_debugref);
-
 	spin_lock_init(&devnopool_lock);
 	dev_no_pool = kzalloc(BITS_TO_LONGS(MAXDEVICES), GFP_KERNEL);
 	if (dev_no_pool == NULL) {
-		ERRDRV("Unable to create dev_no_pool");
-		rc = -1;
-		goto cleanups;
+		visorvideoclient_cleanup_guts();
+		return -1;
 	}
 	visorbus_register_visor_driver(&visorvideoclient_driver);
-	rc = 0;
-
-cleanups:
-	if (rc < 0)
-		visorvideoclient_cleanup_guts();
-	return rc;
+	return 0;
 }
 
 static void
 visorvideoclient_cleanup(void)
 {
 	visorvideoclient_cleanup_guts();
-	INFODRV("driver unloaded");
 }
 
 module_param_named(debug, visorvideoclient_debug, int, S_IRUGO);
